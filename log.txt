commit 007b5e42696f19f54469147dc7be1bdd4e63901c
Merge: fad91fc 6c5dabe
Author: xuqi <xuqi18268712006@163.com>
Date:   Fri Dec 9 00:08:48 2022 +0800

    Merge remote-tracking branch 'origin/main'

commit fad91fca95a3696a9d445f5e39f5a2e268c78a61
Author: xuqi <xuqi18268712006@163.com>
Date:   Fri Dec 9 00:02:32 2022 +0800

    md

diff --git a/markdown/xq.md b/markdown/xq.md
index 43d4e09..a67c828 100644
--- a/markdown/xq.md
+++ b/markdown/xq.md
@@ -97,7 +97,7 @@ Status Code:
 
 ### 订单查询
 
-**买家查询自己所有的历史订单信息**  
+### 买家查询自己所有的历史订单信息  
 买家权限接口：search_order  
 
 实现逻辑和数据库操作：  
@@ -107,7 +107,7 @@ Status Code:
 检查查询的detail是否为空，空则返回订单错误  
 将订单和订单具体信息返回。    
 
-**请求地址：**
+**请求地址：**  
 POST http://[address]/buyer/search_order
 
 **Request**
@@ -167,7 +167,7 @@ Status Code:
 
 买家id错误/订单没有内容
 
-**卖家查询自己商店的所有订单**
+### 卖家查询自己商店的所有订单
 
 实现逻辑和数据库操作：  
 传入卖家id和商店id  
@@ -178,7 +178,8 @@ Status Code:
 
 卖家权限接口：seller_search
 
-**请求地址：**
+**请求地址：**  
+
 POST http://[address]/seller/seller_search
 
 **Request**
@@ -203,7 +204,7 @@ Status Code:
 | 518 | 无效订单   |
 | 523 | 商店没有订单 |
 
-##### Body:
+Body:
 ```json
 {
   "order_list": 
@@ -243,7 +244,7 @@ Status Code:
 
 取消订单的步骤：
 
-1. 主动取消
+1. 主动取消  
 取消订单接口：获取买家id和订单id  
 用order_id查询NewOrder表获取订单信息  
 检查商店id是否存在，status 不是已收货/已发货，用户id是买家id  
@@ -251,16 +252,19 @@ If 订单状态是未支付
 只需要修改仓库信息，order_id查询NewOrderDetail表获取订单购买的具体信息，更新相应store里的库存信息。
 If 已支付  
 需要修改仓库信息/余额变动，计算总金额，查询User表里商家id的记录判断商家的钱够不够扣除，够则扣除订单金额，在买家金额里加上相同金额。    
-最后都要删除new_order/new_order_detail里的该订单记录    
+最后都要删除new_order/new_order_detail里的该订单记录  
+
+
 2. 超时取消
 超过一定时间未支付，自动取消  
 每次查询，如果计算时间（当前时间 - 订单创建时间）>= 1s 删除订单  
 
-**买家主动取消**  
+### 买家主动取消  
 
 买家权限接口：cancel_order  
 
-**请求地址：**
+**请求地址：**  
+
 POST http://[address]/buyer/cancel_order
 
 **Request**
@@ -296,10 +300,10 @@ Status Code:
 未支付/已支付订单取消成功  
 已发货/已收货订单取消失败、订单id错误、重复取消、错误买家id、卖家的钱不够扣除  
 
-**未支付订单超时自动取消**  
+### 未支付订单超时自动取消
 
 实现思路：  
-每次查询订单时（买家查询自己的历史订单，卖家查询自己商店的订单），如果查询得到的未支付订单超时，则自动取消该订单，从数据库中删去。  
+每次查询订单时（买家查询自己的历史订单/卖家查询自己商店的订单），如果查询得到的未支付订单超时，则自动取消该订单，从数据库中删去。  
 
 Status Code:  
 
@@ -318,3 +322,8 @@ Status Code:
 2. 后端传json文件一直报错UnicodeEncodeError: 'gbk' codec can't encode character '\ufffd' in position 494: illegal multibyte sequence，这个\ufffd的码本应该不存在于json中，寻找原因无果，print前后端传递的内容调试后，突然解决。  
 3. 后端接口函数返回的参数个数不同
     解决方法：参考new_order的函数写法，在无值的情况下，在error后加上 + ("",)，从而达到返回参数个数相同的目的  
+
+**心得体会**  
+数据库的事务处理需要考虑多种错误情况，当同时对多个表进行修改时，放在一个session中能够解决事务中断或是冲突的情况，一整个事务回滚。  
+测试代码的编写应当考虑到多种情况，仅是实现正确情况的测试是不够的，错误返回的测试也很重要。  
+前后端的json文件传递可以通过print后端/前端获得的信息进行调试。  
\ No newline at end of file

commit 6c5dabe992738521cc64290db5cf5bad7115258c
Author: Li Sihan <10205501407@stu.ecnu.edu.cn>
Date:   Fri Dec 9 00:01:52 2022 +0800

    lsh_md

diff --git a/markdown/lsh.md b/markdown/lsh.md
index e903947..2439770 100644
--- a/markdown/lsh.md
+++ b/markdown/lsh.md
@@ -1,6 +1,7 @@
-#### 搜索图书（附加功能）
+## 搜索图书（附加功能）
+### 接口
 #### 搜索
-**请求地址：**`POST` `/searcher/search`
+**请求地址** `POST` `/searcher/search`
 
 **Request**
 
@@ -15,40 +16,137 @@ Body:
 ```
 {
     "user_id":"$user name$",
-    "store_id":"$user password$",
-    "keyword":"$terminal code$"
-    "variable":
+    "store_id":"$store name$",
+    "keyword":"$search content$"
+    "variable":"$error test judgment$"
 }
 ```
 
-| 变量名   | 类型   | 描述     | 是否可为空 |
-| -------- | ------ | -------- | ---------- |
-| user_id  | string | 用户名   | N          |
-| password | string | 登陆密码 | N          |
-| terminal | string | 终端代码 | N          |
+| 变量名      | 类型     | 描述          | 是否可为空     |
+|----------|--------|-------------|-----------|
+| user_id  | string | 用户名         | N         |
+| store_id | string | 店铺名         | 全站搜索时为空   |
+| keyword  | string | 搜索内容（已分词）   | N         |
+| variable | bool   | 判断是否为错误测试   | N         |
 
 **Response**
 
 Status Code:
 
-| 码   | 描述                       |
-| ---- | -------------------------- |
-| 200  | 登录成功                   |
-| 401  | 登录失败，用户名或密码错误 |
+| 码   | 描述             |
+|-----|----------------|
+| 200 | 搜索成功，返回相应内容    |
+| 511 | 不存在用户名         |
+| 513 | 不存在店铺名         |
+| 522 | 无相关搜索结果        |
+| 528 | SQLAlchemyError |
+| 530 | BaseException  |
 
 Body:
 
 ```
-{
+{   
     "message":"$error message$",
-    "token":"$access token$"
+    "pagenum":"number of pages",
+    "row":"search result",
+    "show":"the content displayed on the page"
 }
 ```
 
-| 变量名  | 类型   | 描述                                                         | 是否可为空   |
-| ------- | ------ | ------------------------------------------------------------ | ------------ |
-| message | string | 返回错误消息，成功时为"ok"                                   | N            |
-| token   | string | 访问token，用户登录后每个需要授权的请求应在headers中传入这个token | 成功时不为空 |
+| 变量名     | 类型     | 描述                    | 是否可为空      |
+|---------|--------|-----------------------|------------|
+| message | string | 返回错误消息，成功时为"ok"       | N          |
+| pagenum | int    | 搜索内容共可分成多少页（5条一页）     | 不成功时不返回该字段 |
+| row     | list   | 所有的搜索结果               | 不成功时不返回该字段 |
+| show    | list   | 第一页应该显示的内容（长度一定小于等于5） | 不成功时不返回该字段           |
 
 #### 分页显示
-**请求地址：**`POST` `/searcher/show_pages`
\ No newline at end of file
+**请求地址** `POST` `/searcher/show_pages`
+
+**Request**
+
+Headers:
+
+| key   | 类型   | 描述      |
+| ----- | ------ | --------- |
+| token | string | 访问token |
+
+Body:
+
+```
+{
+    "user_id":"$user name$",
+    "page":"$the selected page$",
+    "content":"$search content$"
+    "variable":"$error test judgment$"
+}
+```
+
+| 变量名      | 类型     | 描述        | 是否可为空 |
+|----------|--------|-----------|-------|
+| user_id  | string | 用户名       | N     |
+| page     | string | 选中的要显示的页面 | N     |
+| content  | string | 全部搜索结果    | N     |
+| variable | bool   | 判断是否为错误测试 | N     |
+
+**Response**
+
+Status Code:
+
+| 码   | 描述          |
+|-----|-------------|
+| 200 | 搜索成功，返回相应内容 |
+| 511 | 不存在用户名      |
+| 528 | SQLAlchemyError |
+| 530 | BaseException   |
+
+Body:
+
+```
+{   
+    "message":"$error message$",
+    "pagenum":"number of pages",
+    "row":"search result",
+    "show":"the content displayed on the page"
+}
+```
+
+| 变量名     | 类型     | 描述                      | 是否可为空 |
+|---------|--------|-------------------------|-------|
+| message | string | 返回错误消息，成功时为"ok"         | N     |
+| row     | list   | 所有的搜索结果                 | N     |
+| show    | list   | 选中的页面应该显示的内容（长度一定小于总页数） | N     |
+
+### 函数实现 be\model\search.py
+#### 搜索 def search()
+传入三个参数：用户名、店铺名和查询关键字。先调用 user_id_exist 函数判断用户名是否存在，否则返回相应 code and message。接下来判断是店铺内搜索还是全站搜索，如果店铺名为空则为全站搜索。  
+具体的搜索功能实现，我一开始使用 .like("%" + keyword + "%") 实现了初步的模糊搜索，后面进一步实现了 GIN索引全文检索，代码里两种方法都有，下文仅描述后者。  
+**创建索引 be\model\jieba_book.py**  
+首先，在原来的 book 表中新建一个 token 字段，用于储存 GIN索引。读取数据库，对搜索的范围（标题、作者、关键词、图书信息）使用 jieba 进行分词，用空格隔开，以便后面使用 to_tsvector 函数的 simple 
+方法进行转换。再使用 setweight 对不同的内容赋予权重，我设置的是标题优先于关键词优先于图书信息优先于作者。最后将对应内容更新至token字段，成功创建索引。  
+一开始我遇到很多问题，包括对 GIN索引的不熟悉，分词失败等，后来在助教的指导下找到了好的方法。我这里是直接用 sql 语句创建的索引，我尝试使用 ORM 但是一直出错，可能是语法有点问题。我后面还遇到了一个问题就是
+后面查找时发现每本书计算出的分数都相同，后面才发现是我把所有 book 元组的 token 整合到一起最后每个元组都重复储存了同一个，之后我分别用列表储存标题和分词结果对应赋值 token 解决了问题。  
+**全文搜索过程**  
+创建子查询，得到与搜索关键字有关的每本书的标题，和使用 ts_rank 函数计算得到的对应的分数。再创建查询，搜索 book 表中对应子查询的书的标题、作者、出版商、翻译、作者信息、图书信息、关键词，按照分数降序排序，
+即越符合搜索关键字的越靠前，且图书必须在 store 表有记录且库存须大于0，即搜索范围实际是 bookstore 中有库存的书。对于店铺内搜索，限制 store_id 为输入的店铺名即可。得到所有搜索结果（row），需要判断是否为空，
+否则返回相应 code and message。以5条结果为1页，计算总页数（pagenum），再另外储存前5条结果为第一页显示的内容（show）以显示在当前页面。最后返回所有所需参数。  
+#### 分页显示 def show_pages()
+传入三个参数：用户名、选中的页数和搜索得到的全部结果。类似地，先调用 user_id_exist 函数判断用户名是否存在，否则返回相应 code and message。该函数实现很简单，计算得到在选中页面需要显示的结果（show）即可，
+最后返回显示内容和所有搜索结果（以便可以连续选择页面）。其实我最后发现这里好像可以再查询一次得到结果，然后显示相应页面，就不要传递整个搜索结果，但是我感觉搜索结果也不是很多，而且这样也能实现所以就没管了
+，而且我也不清楚是每次都查询一次的消耗更大还是直接传递结果的消耗更大。。。
+### 测试过程
+整个搜索功能的测试分为五个部分，分别测试：店铺内搜索、全站搜索、搜索结果不存在、用户名不存在、店铺名不存在。  
+在测试之前使用函数 def pre_run_initialization() 定义相关参数：self.store_id1 为随机生 成的店铺名，self.store_id0 为空字符串表示全站搜索；self.add1 和 self.add0 新建 AddStoreBook 类。
+该类实现代码我写在 fe\test\add_store_book.py 中，接收参数store_id，当店铺名为空时随机创建5到 20个店铺，向其中随机插入图书，否则就根据传入的店铺名指定创建并插入图书；self.keyword1 为查询关键字
+，self.keyword0为一个生僻字，为了后面查询不到结果的test。  
+在具体的5个test中，先调用 AddStoreBook 类的 add 方法新建店铺并插入图书。在两个 test_ok 中，赋值布尔变量 True，接收 search 的正确的四个返回参数，如果总页数超过1，随机选中1个页面（小于总页数），调用 show_pages 实现
+分页显示，判断两个 code 都等于200。在三个 error测试中，赋值布尔变量 False，接收 search 的一个返回参数 code，判断其不等于200。
+### 心得体会
+对整个搜索功能的实现，我主要遇到以下问题：前后端传参，如何结合正确测试和错误测试以及 GIN索引的创建和使用。  
+对于前后端传参，一是数量的匹配，二是参数类型。因为正确测试和错误测试传递到前端的参数数量不同，所以不能以同一个格式来接收。而在参数类型方面，一开始我发现后端传回的搜索结果前端一直接收不到，后来经过一系列的
+类型转换才成功传递。对于如何结合正确测试和错误测试，主要就是在参数数量上体现的差别，所以我设置了一个布尔变量，通过判断这个变量选择不同的传参语句。对于 GIN索引的创建和使用，这是整个实现过程对于我挑战最大的地方，
+因为之前没有接触过，网上参考的资料也不是很多，所以一度陷入困境。感谢助教对我不厌其烦地答疑和发给我的知乎链接，非常有用！后面我又找到两个类似的，虽然是 JAVA 的，但是参考价值很大。我深入理解了 GIN索引的创建逻辑
+和查找时的使用方法，学会了相关函数的定义和使用，进一步提升了使用 jieba 分词的能力。  
+当然，还有不得不提的各种配置环境和安包的问题。每次做大作业这个环节都是最费时和让人烦躁的。一开始我运行出来始终 response 500，困扰我很久，但同样的代码在组员的电脑上又可以成功运行。所以挣扎了很久，最后还是重新
+创建 conda 的虚拟环境并安装相关的各种包，幸好是成功解决了问题。后面安装 jieba 包也挺麻烦，具体的倒也不讲了。  
+总之，我收获了很多实际应用的经验，编程能力也有所提高。
\ No newline at end of file

commit 250bc3b46e3b2d7fbec73d7d8918508d548b8afa
Author: xuqi <xuqi18268712006@163.com>
Date:   Thu Dec 8 21:34:04 2022 +0800

    md

diff --git a/markdown/xq.md b/markdown/xq.md
index 7a5b5f1..43d4e09 100644
--- a/markdown/xq.md
+++ b/markdown/xq.md
@@ -4,6 +4,14 @@
 
 卖家权限接口： delivered
 
+实现逻辑和数据库操作：  
+传入卖家id和订单id  
+检查订单是否存在：用order_id查询NewOrder表
+是否属于该卖家：用user_id查询UserStore表  
+检查订单状态：用order_id查询NewOrder表获取status  
+如果订单状态为已支付，则将NewOrder表中该记录的status修改为已发货  
+其他状态不允许修改订单状态为已发货。  
+
 **请求地址：**
 POST http://[address]/seller/delivered
 
@@ -42,6 +50,14 @@ order_id错误/未支付订单/重复发货/卖家id错误
 
 买家权限接口： received
 
+实现逻辑和数据库操作：  
+传入买家id和订单id  
+检查订单是否存在：用order_id查询NewOrder表  
+是否属于该买家：用user_id查询UserStore表  
+检查订单状态：用order_id查询NewOrder表获取status  
+如果订单状态为已发货，则将NewOrder表中该记录的status修改为已收货  
+其他状态不允许修改订单状态为已收货。  
+
 **请求地址：**
 POST http://[address]/buyer/received
 
@@ -76,6 +92,7 @@ Status Code:
 
 ### 订单状态
 在NewOrder表增加status，该属性存储订单的状态，分为：  
+
 未支付 -> 已支付 -> 已发货 -> 已收货  
 
 ### 订单查询
@@ -83,6 +100,13 @@ Status Code:
 **买家查询自己所有的历史订单信息**  
 买家权限接口：search_order  
 
+实现逻辑和数据库操作：  
+传入买家id  
+检查该用户是否有订单：用user_id查询NewOrder表获取订单列表信息    
+用查询到的order_id查询NewOrderDetail表获取订单具体信息
+检查查询的detail是否为空，空则返回订单错误  
+将订单和订单具体信息返回。    
+
 **请求地址：**
 POST http://[address]/buyer/search_order
 
@@ -145,6 +169,13 @@ Status Code:
 
 **卖家查询自己商店的所有订单**
 
+实现逻辑和数据库操作：  
+传入卖家id和商店id  
+检查该商店是否有订单，用store_id查询NewOrder表获取订单列表信息    
+用查询到的order_id查询NewOrderDetail表获取订单具体信息  
+检查查询的detail是否为空，空则返回订单错误  
+将订单和订单具体信息返回。  
+
 卖家权限接口：seller_search
 
 **请求地址：**
@@ -213,13 +244,14 @@ Status Code:
 取消订单的步骤：
 
 1. 主动取消
-取消订单接口：  
-前提（status 不是已收货/已发货）   
-If 未支付  
-只需要修改仓库信息  
+取消订单接口：获取买家id和订单id  
+用order_id查询NewOrder表获取订单信息  
+检查商店id是否存在，status 不是已收货/已发货，用户id是买家id  
+If 订单状态是未支付  
+只需要修改仓库信息，order_id查询NewOrderDetail表获取订单购买的具体信息，更新相应store里的库存信息。
 If 已支付  
-需要修改仓库信息/余额变动  
-删除new_order/new_order_detail  
+需要修改仓库信息/余额变动，计算总金额，查询User表里商家id的记录判断商家的钱够不够扣除，够则扣除订单金额，在买家金额里加上相同金额。    
+最后都要删除new_order/new_order_detail里的该订单记录    
 2. 超时取消
 超过一定时间未支付，自动取消  
 每次查询，如果计算时间（当前时间 - 订单创建时间）>= 1s 删除订单  

commit 693d5bdbde541ec8ba774075f45fa47dd338b1c9
Author: Li Sihan <10205501407@stu.ecnu.edu.cn>
Date:   Thu Dec 8 20:33:01 2022 +0800

    search_modify_3

diff --git a/be/model/searcher.py b/be/model/searcher.py
index 35e4aa0..b639008 100644
--- a/be/model/searcher.py
+++ b/be/model/searcher.py
@@ -44,21 +44,7 @@ class Searcher(db_conn.CheckExist):
                         .filter(book_model.title == sub.c.title) \
                         .order_by(desc(sub.c.score)) \
                         .all()
-
-                    if len(row) == 0:
-                        return error.error_non_exist_search()
-                    else:
-                        pagenum = len(row) // 5
-                        if pagenum == 0 :
-                            pagenum = 1
-                            show = row
-                        else:
-                            page = len(row) % 5
-                            if page != 0:
-                                pagenum += 1
-                            show = row[:5]
-                        # return 200, "ok", pagenum, row, show
-            # 店铺搜索
+            # 店铺内搜索
             else:
                 if not self.store_id_exist(store_id):
                     return error.error_non_exist_store_id(store_id)
@@ -91,20 +77,19 @@ class Searcher(db_conn.CheckExist):
                         .order_by(desc(sub.c.score)) \
                         .all()
 
-                    if len(row) == 0:
-                        return error.error_non_exist_search()
-                    else:
-                        pagenum = len(row) // 5
-                        if pagenum == 0:
-                            pagenum = 1
-                            show = row
-                        else:
-                            page = len(row) % 5
-                            if page != 0:
-                                pagenum += 1
-                            show = row[:5]
-                        #print(pagenum, row, show)
-                        # return 200, "ok", pagenum, row, show
+            # 计算得到总页数（5条一页）和第一页展示内容
+            if len(row) == 0:
+                return error.error_non_exist_search()
+            else:
+                pagenum = len(row) // 5
+                if pagenum == 0:
+                    pagenum = 1
+                    show = row
+                else:
+                    page = len(row) % 5
+                    if page != 0:
+                        pagenum += 1
+                    show = row[:5]
 
         except SQLAlchemyError as e:
             return 528, "{}".format(str(e))
@@ -123,7 +108,6 @@ class Searcher(db_conn.CheckExist):
                 show = content[off:(off+5)]
             else:
                 show = content[off:]
-            # return 200, "ok", show, content
 
         except SQLAlchemyError as e:
             return 528, "{}".format(str(e))

commit 6740c03138dc5800686bb79451032f286dc8a0ee
Author: Li Sihan <10205501407@stu.ecnu.edu.cn>
Date:   Thu Dec 8 19:53:57 2022 +0800

    search_modify_2

diff --git a/be/model/searcher.py b/be/model/searcher.py
index 2c85b09..35e4aa0 100644
--- a/be/model/searcher.py
+++ b/be/model/searcher.py
@@ -8,14 +8,13 @@ from sqlalchemy.sql import func
 
 class Searcher(db_conn.CheckExist):
 
-
     def search(self, user_id: str, store_id: str, keyword: str):
         try:
+            if not self.user_id_exist(user_id):
+                return error.error_non_exist_user_id(user_id)
+
             # 全站搜索
             if store_id == '':
-                if not self.user_id_exist(user_id):
-                    return error.error_non_exist_user_id(user_id)
-
                 with self.get_session() as session:
                     #一般模糊查询
                     """
@@ -61,8 +60,6 @@ class Searcher(db_conn.CheckExist):
                         # return 200, "ok", pagenum, row, show
             # 店铺搜索
             else:
-                if not self.user_id_exist(user_id):
-                    return error.error_non_exist_user_id(user_id)
                 if not self.store_id_exist(store_id):
                     return error.error_non_exist_store_id(store_id)
 

commit de1438e12cd3b662e781fc173e996485b34a44a7
Author: Li Sihan <10205501407@stu.ecnu.edu.cn>
Date:   Thu Dec 8 19:35:31 2022 +0800

    search_modify

diff --git a/be/view/searcher.py b/be/view/searcher.py
index 20b83ea..bbc9858 100644
--- a/be/view/searcher.py
+++ b/be/view/searcher.py
@@ -24,7 +24,7 @@ def search():
         data2 = []
         for item in show:
             data2.append(list(item))
-        return json.dumps({"pagenum": pagenum, "row": data1, "show": data2}), code
+        return json.dumps({"message":message, "pagenum": pagenum, "row": data1, "show": data2}), code
     else:
         code, message = se.search(user_id, store_id, keyword)
         return jsonify({"message": message}), code
@@ -45,7 +45,7 @@ def show_pages():
         data2 = []
         for item in show:
             data2.append(list(item))
-        return jsonify({"show": data2, "row": data1}), code
+        return jsonify({"message":message, "show": data2, "row": data1}), code
     else:
         code, message = se.search(user_id, page, content)
         return jsonify({"message": message}), code

commit ba407d21a39cc504278a83fc4ac526efbacbbf43
Author: Li Sihan <10205501407@stu.ecnu.edu.cn>
Date:   Thu Dec 8 18:47:40 2022 +0800

    search_finish

diff --git a/be/model/jieba_book.py b/be/model/jieba_book.py
new file mode 100644
index 0000000..684f615
--- /dev/null
+++ b/be/model/jieba_book.py
@@ -0,0 +1,55 @@
+import jieba
+from sqlalchemy import create_engine
+from sqlalchemy.orm import sessionmaker
+from be.model.orm_models import Book as book_model
+
+engine = create_engine(
+    "postgresql+psycopg2://stu10205501460:Stu10205501460@dase-cdms-2022-pub.pg.rds.aliyuncs.com:5432/stu10205501460",
+    max_overflow=0,
+    # 链接池大小
+    pool_size=10,
+    # 链接池中没有可用链接则最多等待的秒数，超过该秒数后报错
+    pool_timeout=5,
+    # 多久之后对链接池中的链接进行一次回收
+    pool_recycle=5,
+    # 查看原生语句（未格式化）
+    echo=True
+    )
+
+DBSession = sessionmaker(bind=engine)
+session = DBSession()
+
+res = session.query(book_model.id, book_model.title, book_model.author, book_model.tags, book_model.book_intro).all()
+c_t = []
+c_a = []
+c_ta = []
+c_b = []
+c_i = []
+for i in range(0,len(res)):
+    c_i.append(res[i][0])
+    #分词
+    str_t = str(res[i][1])
+    c_t.append(' '.join(jieba.cut(str_t, cut_all=False)))
+    str_a = str(res[i][2])
+    c_a.append(' '.join(jieba.cut(str_a, cut_all=False)))
+    str_ta = str(res[i][3])
+    c_ta.append(' '.join(jieba.cut(str_ta, cut_all=False)))
+    str_b = str(res[i][4])
+    c_b.append(' '.join(jieba.cut(str_b, cut_all=False)))
+
+#建gin索引
+sql = "UPDATE bookstore_book  \
+      SET token = setweight(to_tsvector('simple', %s), 'A') || setweight(to_tsvector('simple', %s), 'B') || setweight(to_tsvector('simple', %s), 'C') || setweight(to_tsvector('simple', %s), 'D') \
+       WHERE id = %s"
+for i in range(0, len(res)):
+    engine.execute(sql, [c_t[i], c_ta[i], c_b[i], c_a[i], c_i[i]])
+
+to = session.query(book_model.token).all()
+print(to)
+
+session.close()
+
+
+
+
+
diff --git a/be/model/orm_models.py b/be/model/orm_models.py
index 4d5a301..bea61e7 100644
--- a/be/model/orm_models.py
+++ b/be/model/orm_models.py
@@ -5,11 +5,7 @@ from sqlalchemy.dialects.postgresql import TSVECTOR
 
 
 Base = declarative_base()
-"""
-def to_tsvector_ix(*columns):
-    s = " || ' ' || ".join(columns)
-    return func.to_tsvector('english', text(s))
-"""
+
 class Book(Base):
     __tablename__ = 'bookstore_book'
 
@@ -31,15 +27,7 @@ class Book(Base):
     tags = Column(Text)
     picture = Column(LargeBinary)
     token = Column(TSVECTOR)
-"""
-    __table_args__ = (
-        Index(
-            'ix_book_tsv',
-            to_tsvector_ix('title', 'author', 'tags', 'book_intro', 'content'),
-            postgresql_using='gin'
-        ),
-    )
-"""
+
 class NewOrder(Base):
     __tablename__ = 'bookstore_new_order'
 
diff --git a/be/model/searcher.py b/be/model/searcher.py
index cf82da6..2c85b09 100644
--- a/be/model/searcher.py
+++ b/be/model/searcher.py
@@ -3,12 +3,12 @@ from be.model import db_conn
 from be.model.orm_models import Store as Store_model
 from be.model.orm_models import Book as book_model
 from sqlalchemy.exc import SQLAlchemyError
-from sqlalchemy import and_, or_
-
+from sqlalchemy import desc
+from sqlalchemy.sql import func
 
 class Searcher(db_conn.CheckExist):
 
-    # 题目，作者，出版商，翻译，出版日期，页数，价格，标签，简介，目录
+
     def search(self, user_id: str, store_id: str, keyword: str):
         try:
             # 全站搜索
@@ -17,10 +17,10 @@ class Searcher(db_conn.CheckExist):
                     return error.error_non_exist_user_id(user_id)
 
                 with self.get_session() as session:
-
+                    #一般模糊查询
+                    """
                     row = session.query(book_model.title, book_model.author, book_model.publisher,
                                         book_model.translator,
-                                        book_model.pub_year, book_model.pages, book_model.price,
                                         book_model.author_intro,
                                         book_model.book_intro, book_model.tags) \
                         .join(Store_model, Store_model.book_id == book_model.id) \
@@ -29,6 +29,22 @@ class Searcher(db_conn.CheckExist):
                         book_model.tags.like("%" + keyword + "%"), book_model.book_intro.like("%" + keyword + "%"),
                         book_model.content.like("%" + keyword + "%")
                     ))).all()
+                    """
+                    #gin索引查询
+                    sub = session.query(book_model.title,
+                                        func.ts_rank(book_model.token, func.to_tsquery('simple', keyword)).label('score')) \
+                        .filter(book_model.token.op('@@')(func.to_tsquery('simple', keyword))) \
+                        .subquery()
+
+                    row = session.query(book_model.title, book_model.author, book_model.publisher,
+                                        book_model.translator,
+                                        book_model.author_intro,
+                                        book_model.book_intro, book_model.tags) \
+                        .join(Store_model, Store_model.book_id == book_model.id) \
+                        .filter(Store_model.stock_level > 0) \
+                        .filter(book_model.title == sub.c.title) \
+                        .order_by(desc(sub.c.score)) \
+                        .all()
 
                     if len(row) == 0:
                         return error.error_non_exist_search()
@@ -51,9 +67,9 @@ class Searcher(db_conn.CheckExist):
                     return error.error_non_exist_store_id(store_id)
 
                 with self.get_session() as session:
+                    """
                     row = session.query(book_model.title, book_model.author, book_model.publisher,
                                         book_model.translator,
-                                        book_model.pub_year, book_model.pages, book_model.price,
                                         book_model.author_intro,
                                         book_model.book_intro, book_model.tags) \
                         .join(Store_model, Store_model.book_id == book_model.id) \
@@ -62,6 +78,21 @@ class Searcher(db_conn.CheckExist):
                         book_model.tags.like("%" + keyword + "%"), book_model.book_intro.like("%" + keyword + "%"),
                         book_model.content.like("%" + keyword + "%")
                     ))).all()
+                    """
+                    sub = session.query(book_model.title,
+                                        func.ts_rank(book_model.token, func.to_tsquery('simple', keyword)).label('score')) \
+                        .filter(book_model.token.op('@@')(func.to_tsquery('simple', keyword))) \
+                        .subquery()
+
+                    row = session.query(book_model.title, book_model.author, book_model.publisher,
+                                        book_model.translator,
+                                        book_model.author_intro,
+                                        book_model.book_intro, book_model.tags) \
+                        .join(Store_model, Store_model.book_id == book_model.id) \
+                        .filter(Store_model.stock_level > 0) \
+                        .filter(book_model.title == sub.c.title) \
+                        .order_by(desc(sub.c.score)) \
+                        .all()
 
                     if len(row) == 0:
                         return error.error_non_exist_search()
@@ -89,7 +120,7 @@ class Searcher(db_conn.CheckExist):
             if not self.user_id_exist(user_id):
                 return error.error_non_exist_user_id(user_id)
 
-            off = (page-1) * 5
+            off = (int(page)-1) * 5
             remain = len(content) - off
             if remain > 5:
                 show = content[off:(off+5)]
diff --git a/be/model/store.py b/be/model/store.py
index cec7d98..f2e3614 100644
--- a/be/model/store.py
+++ b/be/model/store.py
@@ -14,10 +14,10 @@ class Store:
     #database: str
 
     def __init__(self):
-        self.database = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "data/bookstore.db")
+        #self.database = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "data/bookstore.db")
         # 最后我们只要换掉这个db_address就可以换成psql
-        self.engine = create_engine("sqlite:///"+self.database)
-        '''
+        #self.engine = create_engine("sqlite:///"+self.database)
+
         self.engine = create_engine("postgresql+psycopg2://stu10205501460:Stu10205501460@dase-cdms-2022-pub.pg.rds.aliyuncs.com:5432/stu10205501460",
         max_overflow=0,
         # 链接池大小
@@ -29,7 +29,7 @@ class Store:
         # 查看原生语句（未格式化）
         echo=True
         )
-        '''
+
         
         #self.engine = create_engine("postgresql+psycopg2://postgres:123456@localhost:5432/postgres",echo=True)
         self.DBSession = sessionmaker(bind=self.engine)
diff --git a/be/view/searcher.py b/be/view/searcher.py
index 90b7092..20b83ea 100644
--- a/be/view/searcher.py
+++ b/be/view/searcher.py
@@ -16,10 +16,8 @@ def search():
     va: bool = request.json.get("variable")
 
     se = Searcher()
-    #print(se.search(user_id, store_id, keyword))
     if va:
         code, message, pagenum, row, show = se.search(user_id, store_id, keyword)
-        #print(code)
         data1 = []
         for item in row:
             data1.append(list(item))
@@ -34,10 +32,10 @@ def search():
 @bp_searcher.route("/show_pages", methods=["POST"])
 def show_pages():
     user_id: str = request.json.get("user_id")
-    page: int = request.json.get("page")
+    page: str = request.json.get("page")
     content: str = request.json.get("content")
     va: bool = request.json.get("variable")
-    print(va)
+
     se = Searcher()
     if va:
         code, message, show, row = se.show_pages(user_id, page, content)
diff --git a/fe/access/searcher.py b/fe/access/searcher.py
index cc5a417..68ebe04 100644
--- a/fe/access/searcher.py
+++ b/fe/access/searcher.py
@@ -2,6 +2,7 @@ import requests
 from urllib.parse import urljoin
 from fe.access.auth import Auth
 import json
+import jieba
 
 
 class Searcher:
@@ -15,26 +16,23 @@ class Searcher:
         assert code == 200
 
     def search(self, store_id: str, keyword: str, va: bool):
+        #分词
+        kw = ' | '.join(jieba.cut(keyword, cut_all=False))
+
         json = {
             "user_id": self.user_id,
             "store_id": store_id,
-            "keyword": keyword,
+            "keyword": kw,
             "variable": va
         }
         url = urljoin(self.url_prefix, "search")
-        headers = {"token": self.token, "Content-Type": "application/json"}
+        headers = {"token": self.token}
 
-        #json_str = json.dumps(json_)
-        #print(json_str)
-        #print(url)
         r = requests.post(url, headers=headers, json=json)
         response_json = r.json()
         if va:
             return r.status_code, response_json.get("pagenum"), response_json.get("row"), response_json.get("show")
-        #print(r)
-        #return r.status_code
         else:
-            print(r)
             return r.status_code
 
 
diff --git a/fe/test/test_search.py b/fe/test/test_search.py
index b976339..85365da 100644
--- a/fe/test/test_search.py
+++ b/fe/test/test_search.py
@@ -14,21 +14,23 @@ class TestSearch:
         self.searcher = register_new_searcher(self.searcher_id, self.password)
 
         self.store_id1 = "test_search_store_id_{}".format(str(uuid.uuid1())) #店铺内
-        #self.store_id1 = "test_search_store_id_a6493f19-7565-11ed-a111-f8ac65b9cbec"
+        #self.store_id1 = 'test_search_store_id_4886fd75-761c-11ed-8bc4-145afc1fa211'
         self.store_id0 = "" #全站
         self.add1 = AddStoreBook(self.store_id1) #店铺内
         self.add0 = AddStoreBook(self.store_id0) #全站
 
-        self.keyword = "人"
+        self.keyword1 = "美丽人生"
+        self.keyword0 = "繺"
         self.page = 0
 
         yield
 
     def test_store_ok(self):
+
         ok = self.add1.add()
         assert ok
-        code1,pagenum,row,_ = self.searcher.search(self.store_id1, self.keyword, True)
-        #code1 = self.searcher.search(store_id=self.store_id1, keyword=self.keyword)
+
+        code1,pagenum,row,_ = self.searcher.search(self.store_id1, self.keyword1, True)
         assert code1 == 200
 
         if pagenum > 1:
@@ -37,9 +39,11 @@ class TestSearch:
             assert code2 == 200
 
     def test_all_ok(self):
+
         ok = self.add0.add()
         assert ok
-        code1, pagenum, row, _ = self.searcher.search(self.store_id0, self.keyword, True)
+
+        code1, pagenum, row, _ = self.searcher.search(self.store_id0, self.keyword1, True)
         assert code1 == 200
 
         if pagenum > 1:
@@ -48,20 +52,26 @@ class TestSearch:
             assert code2 == 200
 
     def test_error_non_exist_search(self):
+
         ok = self.add0.add()
         assert ok
-        code = self.searcher.search(self.store_id1, self.keyword+"xx", False)
+
+        code = self.searcher.search(self.store_id1, self.keyword0, False)
         assert code != 200
 
     def test_non_exist_user_id(self):
+
         ok = self.add0.add()
         assert ok
+
         self.searcher.user_id = self.searcher.user_id + "_x"
-        code = self.searcher.search(self.store_id1, self.keyword, False)
+        code = self.searcher.search(self.store_id1, self.keyword1, False)
         assert code != 200
 
     def test_non_exist_store_id(self):
+
         ok = self.add0.add()
         assert ok
-        code = self.searcher.search(self.store_id1+"x", self.keyword ,False)
+
+        code = self.searcher.search(self.store_id1+"x", self.keyword1 ,False)
         assert code != 200
\ No newline at end of file
diff --git a/markdown/lsh.md b/markdown/lsh.md
index e69de29..e903947 100644
--- a/markdown/lsh.md
+++ b/markdown/lsh.md
@@ -0,0 +1,54 @@
+#### 搜索图书（附加功能）
+#### 搜索
+**请求地址：**`POST` `/searcher/search`
+
+**Request**
+
+Headers:
+
+| key   | 类型   | 描述      |
+| ----- | ------ | --------- |
+| token | string | 访问token |
+
+Body:
+
+```
+{
+    "user_id":"$user name$",
+    "store_id":"$user password$",
+    "keyword":"$terminal code$"
+    "variable":
+}
+```
+
+| 变量名   | 类型   | 描述     | 是否可为空 |
+| -------- | ------ | -------- | ---------- |
+| user_id  | string | 用户名   | N          |
+| password | string | 登陆密码 | N          |
+| terminal | string | 终端代码 | N          |
+
+**Response**
+
+Status Code:
+
+| 码   | 描述                       |
+| ---- | -------------------------- |
+| 200  | 登录成功                   |
+| 401  | 登录失败，用户名或密码错误 |
+
+Body:
+
+```
+{
+    "message":"$error message$",
+    "token":"$access token$"
+}
+```
+
+| 变量名  | 类型   | 描述                                                         | 是否可为空   |
+| ------- | ------ | ------------------------------------------------------------ | ------------ |
+| message | string | 返回错误消息，成功时为"ok"                                   | N            |
+| token   | string | 访问token，用户登录后每个需要授权的请求应在headers中传入这个token | 成功时不为空 |
+
+#### 分页显示
+**请求地址：**`POST` `/searcher/show_pages`
\ No newline at end of file

commit 8ba24ad91c75460c8afb54a9575f63e82a4d9b57
Merge: f4e2e93 68d4b45
Author: dirtyDan0 <ray3218@outlook.com>
Date:   Wed Dec 7 23:24:26 2022 +0800

    Merge branch 'main' of https://github.com/dirtyDan0/bookstore_CDMS2022

commit f4e2e938e9eeb3768881cc9cdf29d69fd2a7e49a
Author: dirtyDan0 <ray3218@outlook.com>
Date:   Wed Dec 7 23:24:09 2022 +0800

    feat:Book(token)

diff --git a/be/model/orm_models.py b/be/model/orm_models.py
index 80a2aad..4d5a301 100644
--- a/be/model/orm_models.py
+++ b/be/model/orm_models.py
@@ -1,6 +1,8 @@
 from sqlalchemy import text, Index, Column, Integer, Text, LargeBinary, DateTime
 from sqlalchemy.orm import declarative_base
 from sqlalchemy.sql import func
+from sqlalchemy.dialects.postgresql import TSVECTOR
+
 
 Base = declarative_base()
 """
@@ -28,6 +30,7 @@ class Book(Base):
     content = Column(Text)
     tags = Column(Text)
     picture = Column(LargeBinary)
+    token = Column(TSVECTOR)
 """
     __table_args__ = (
         Index(

commit 68d4b45a1e35e1e5181220faf6be172661f479f9
Author: xuqi <xuqi18268712006@163.com>
Date:   Wed Dec 7 21:22:14 2022 +0800

    md

diff --git a/markdown/xq.md b/markdown/xq.md
index e69de29..7a5b5f1 100644
--- a/markdown/xq.md
+++ b/markdown/xq.md
@@ -0,0 +1,288 @@
+## 功能1：订单收货和发货
+
+### 发货
+
+卖家权限接口： delivered
+
+**请求地址：**
+POST http://[address]/seller/delivered
+
+**Request**
+
+Body:
+
+```json
+{
+    "user_id":"$user_id$",
+    "order_id":"$order_id$"
+}
+```
+
+| 变量名      | 类型   | 描述      | 是否可为空 |
+|----------| ------ |---------|-------|
+| user_id  | string | 卖家用户的id | N     |
+| order_id | string | 卖家要发货的订单id | N     |
+
+**Response**
+
+Status Code:
+
+| 码   | 描述                   |
+|-----|----------------------|
+| 200 | 发货成功                 |
+| 401 | 权限错误，该订单的卖家不是该用户     |
+| 518 | 无效订单                 |
+| 520 | 不是已支付的订单：未支付/已发货/已收货 |
+
+**test**  
+
+order_id错误/未支付订单/重复发货/卖家id错误  
+
+### 收货
+
+买家权限接口： received
+
+**请求地址：**
+POST http://[address]/buyer/received
+
+**Request**
+
+Body:
+```json
+{"user_id": "$user_id$", "order_id": "$order_id$"}
+```
+
+| 变量名      | 类型   | 描述         | 是否可为空 |
+|----------| ------ |------------|-------|
+| user_id  | string | 买家用户的id    | N     |
+| order_id | string | 买家要收货的订单id | N     |
+
+**Response**
+
+Status Code:
+
+| 码   | 描述                   |
+|-----|----------------------|
+| 200 | 收货成功                 |
+| 401 | 权限错误，该订单的买家不是该用户     |
+| 518 | 无效订单                 |
+| 520 | 不是已发货的订单：未支付/已支付/已收货 |
+
+**test**  
+
+未支付订单/未发货订单/订单id错误/重复收货/买家id错误  
+
+## 功能2：订单状态，订单查询和取消定单
+
+### 订单状态
+在NewOrder表增加status，该属性存储订单的状态，分为：  
+未支付 -> 已支付 -> 已发货 -> 已收货  
+
+### 订单查询
+
+**买家查询自己所有的历史订单信息**  
+买家权限接口：search_order  
+
+**请求地址：**
+POST http://[address]/buyer/search_order
+
+**Request**
+
+Body:
+```json
+{"user_id": "$user_id$"}
+```
+
+| 变量名      | 类型   | 描述         | 是否可为空 |
+|----------| ------ |------------|-------|
+| user_id  | string | 买家用户的id    | N     |
+
+**Response**
+
+Status Code:  
+
+| 码   | 描述                   |
+|-----|----------------------|
+| 200 | 查询成功                 |
+| 518 | 无效订单     |
+| 521 | 用户没有订单               |
+
+##### Body:
+```json
+{
+  "order_list": 
+  [{
+    "order_id": "$order_id$",
+    "store_id": "$store_id$",
+    "time": "$time$",
+    "status": "$status$",
+    "details": 
+        [{
+          "book_id": "$book_id$",
+          "count": "$count$",
+          "price": "$price$"
+        }]
+  }]
+}
+```
+
+##### 属性说明：
+
+| 变量名            | 类型 | 描述 | 是否可为空|
+|----------------|---|---|---|
+| order_id       | string | 订单号，只有返回200时才有效 | N |
+| store_id       | string | 商店号，只有返回200时才有效 | N|
+| time           | string | 订单创建时间 | N|
+| status         | string | 订单状态 | N|
+| detail         | list | 存储订单具体信息 | N|
+| detail.book_id | string | 购买的书号 | N|
+| detail.count   | int | 购买的数量 | N|
+|  detail.price  | int | 书的价格 | N|
+
+**test**  
+
+买家id错误/订单没有内容
+
+**卖家查询自己商店的所有订单**
+
+卖家权限接口：seller_search
+
+**请求地址：**
+POST http://[address]/seller/seller_search
+
+**Request**
+
+Body:
+```json
+{"user_id": "$seller_id$","store_id": "$store_id$"}
+```
+
+| 变量名      | 类型   | 描述      | 是否可为空 |
+|----------| ------ |---------|-------|
+| user_id  | string | 卖家用户的id | N     |
+| store_id | string | 要查询的商店id | N |
+
+**Response**
+
+Status Code:  
+
+| 码   | 描述     |
+|-----|--------|
+| 200 | 查询成功   |
+| 518 | 无效订单   |
+| 523 | 商店没有订单 |
+
+##### Body:
+```json
+{
+  "order_list": 
+  [{
+    "order_id": "$order_id$",
+    "user_id": "$user_id$",
+    "time": "$time$",
+    "status": "$status$",
+    "details": 
+        [{
+          "book_id": "$book_id$",
+          "count": "$count$",
+          "price": "$price$"
+        }]
+  }]
+}
+```
+
+##### 属性说明：
+
+| 变量名            | 类型 | 描述              | 是否可为空|
+|----------------|---|-----------------|---|
+| order_id       | string | 订单号，只有返回200时才有效 | N |
+| user_id        | string | 买家号，只有返回200时才有效 | N|
+| time           | string | 订单创建时间          | N|
+| status         | string | 订单状态            | N|
+| detail         | list | 存储订单具体信息        | N|
+| detail.book_id | string | 购买的书号           | N|
+| detail.count   | int | 购买的数量           | N|
+| detail.price   | int | 书的价格            | N|
+
+**test**  
+
+卖家id错误/订单没有内容  
+
+### 取消订单功能
+
+取消订单的步骤：
+
+1. 主动取消
+取消订单接口：  
+前提（status 不是已收货/已发货）   
+If 未支付  
+只需要修改仓库信息  
+If 已支付  
+需要修改仓库信息/余额变动  
+删除new_order/new_order_detail  
+2. 超时取消
+超过一定时间未支付，自动取消  
+每次查询，如果计算时间（当前时间 - 订单创建时间）>= 1s 删除订单  
+
+**买家主动取消**  
+
+买家权限接口：cancel_order  
+
+**请求地址：**
+POST http://[address]/buyer/cancel_order
+
+**Request**
+
+Body:
+```json
+{"user_id": "$user_id$", "order_id": "$order_id$"}
+```
+
+| 变量名      | 类型   | 描述         | 是否可为空 |
+|----------| ------ |------------|-------|
+| user_id  | string | 买家用户的id    | N     |
+| order_id | string | 要取消的订单id | N |
+
+**Response**
+
+Status Code:  
+
+| 码   | 描述                    |
+|-----|-----------------------|
+| 200 | 取消成功                  |
+| 518 | 无效订单                  |
+| 513 | 该商店id不存在              |
+| 520 | 该状态不允许取消订单操作，已发货/已收货  |
+| 401 | 权限错误                  |
+| 515 | 不存在该book_id           |
+| 514 | 该商店id对应的卖家不存在         |
+| 511 | 该买家id不存在              |
+| 519 | 买家已支付订单，取消订单时卖家的钱不够退回 |
+
+**test**  
+
+未支付/已支付订单取消成功  
+已发货/已收货订单取消失败、订单id错误、重复取消、错误买家id、卖家的钱不够扣除  
+
+**未支付订单超时自动取消**  
+
+实现思路：  
+每次查询订单时（买家查询自己的历史订单，卖家查询自己商店的订单），如果查询得到的未支付订单超时，则自动取消该订单，从数据库中删去。  
+
+Status Code:  
+
+| 码       | 描述                       |
+|---------|--------------------------|
+| 200     | 查询成功                     |
+| 523/521 | 删去已超时的未支付订单后，该商店或该用户没有订单 |
+
+**test**  
+
+两个订单，一个超时，查询到一个/一个订单超时，该买家无订单/一个订单超时，该商店无订单  
+
+**中间的问题和bug**  
+1. 状态码一直报错为530  
+    解决方法：降低flask和Werkzeug版本为2.0.0后重启  
+2. 后端传json文件一直报错UnicodeEncodeError: 'gbk' codec can't encode character '\ufffd' in position 494: illegal multibyte sequence，这个\ufffd的码本应该不存在于json中，寻找原因无果，print前后端传递的内容调试后，突然解决。  
+3. 后端接口函数返回的参数个数不同
+    解决方法：参考new_order的函数写法，在无值的情况下，在error后加上 + ("",)，从而达到返回参数个数相同的目的  

commit f8b0f1c592e7f24dd0db2c25ab7945e4a9b94ba6
Author: xuqi <xuqi18268712006@163.com>
Date:   Wed Dec 7 19:01:56 2022 +0800

    超时取消订单

diff --git a/be/model/buyer.py b/be/model/buyer.py
index 06a3f9b..da46af4 100644
--- a/be/model/buyer.py
+++ b/be/model/buyer.py
@@ -357,7 +357,7 @@ class Buyer(db_conn.CheckExist):
                 if len(rows) == 0:
                     return error.error_user_no_order(user_id) + ("", )
 
-            out = timedelta(seconds=5)  # 设置为5s后未支付取消
+            out = timedelta(seconds=1)  # 设置为1s后未支付取消
 
             with self.get_session() as session:
                 order_list = []
@@ -382,10 +382,7 @@ class Buyer(db_conn.CheckExist):
 
                             detail = []
                             for item in details:
-                                book_id = item.book_id
-                                count = item.count
-                                price = item.price
-                                detail.append({'book_id':book_id, 'count':count, 'price':price})
+                                detail.append({'book_id':item.book_id, 'count':item.count, 'price':item.price})
 
                             order_list.append({'order_id':order_id, 'store_id':store_id, 'time':time, 'status':status, 'detail':detail})
                     else:
@@ -396,10 +393,7 @@ class Buyer(db_conn.CheckExist):
 
                         detail = []
                         for item in details:
-                            book_id = item.book_id
-                            count = item.count
-                            price = item.price
-                            detail.append({'book_id': book_id, 'count': count, 'price': price})
+                            detail.append({'book_id': item.book_id, 'count': item.count, 'price': item.price})
 
                         order_list.append({'order_id': order_id, 'store_id': store_id, 'time': time, 'status': status,
                                            'detail': detail})
diff --git a/be/model/seller.py b/be/model/seller.py
index 439fb73..21c2261 100644
--- a/be/model/seller.py
+++ b/be/model/seller.py
@@ -122,7 +122,7 @@ class Seller(db_conn.CheckExist):
                                      NewOrder_model.status, NewOrder_model.time).filter(NewOrder_model.store_id == store_id).all()
                 if len(rows) == 0:
                     return error.error_store_no_order(store_id) + ("", )
-            out = timedelta(seconds=5)  # 设置为5s后未支付取消
+            out = timedelta(seconds=1)  # 设置为1s后未支付取消
             with self.get_session() as session:
                 order_list = []
                 for row in rows:
@@ -145,10 +145,7 @@ class Seller(db_conn.CheckExist):
 
                             detail = []
                             for item in details:
-                                book_id = item.book_id
-                                count = item.count
-                                price = item.price
-                                detail.append({'book_id':book_id, 'count':count, 'price':price})
+                                detail.append({'book_id':item.book_id, 'count':item.count, 'price':item.price})
 
                             order_list.append({'order_id':order_id, 'user_id':buyer_id, 'time':time, 'status':status, 'detail':detail})
                     else:
@@ -159,10 +156,7 @@ class Seller(db_conn.CheckExist):
 
                         detail = []
                         for item in details:
-                            book_id = item.book_id
-                            count = item.count
-                            price = item.price
-                            detail.append({'book_id': book_id, 'count': count, 'price': price})
+                            detail.append({'book_id': item.book_id, 'count': item.count, 'price': item.price})
 
                         order_list.append({'order_id': order_id, 'user_id': buyer_id, 'time': time, 'status': status,
                                            'detail': detail})
diff --git a/fe/test/test_timeout_cancel.py b/fe/test/test_timeout_cancel.py
index 8c80592..4149033 100644
--- a/fe/test/test_timeout_cancel.py
+++ b/fe/test/test_timeout_cancel.py
@@ -26,7 +26,7 @@ class TestTimeOut:
         b = register_new_buyer(self.buyer_id, self.password)
         code, order_id1 = b.new_order(self.store_id, buy_book_id_list1)
         assert code == 200
-        sleep(6)
+        sleep(2)
         code, order_id2 = b.new_order(self.store_id+'_y', buy_book_id_list2)
         assert code == 200
         code, order_list = b.search_order()
@@ -40,7 +40,7 @@ class TestTimeOut:
         b = register_new_buyer(self.buyer_id, self.password)
         code, order_id1 = b.new_order(self.store_id, buy_book_id_list1)
         assert code == 200
-        sleep(6)
+        sleep(2)
         code, order_list = b.search_order()
         assert code != 200
 
@@ -52,7 +52,7 @@ class TestTimeOut:
         b = register_new_buyer(self.buyer_id, self.password)
         code, order_id1 = b.new_order(self.store_id, buy_book_id_list1)
         assert code == 200
-        sleep(6)
+        sleep(2)
         code = s.seller_search(self.store_id)
         assert code != 200
 

commit a418187da25b9aa88abb717fbc6f242f80a8e064
Author: xuqi <xuqi18268712006@163.com>
Date:   Wed Dec 7 18:52:29 2022 +0800

    xq3 超时取消订单

diff --git a/be/model/buyer.py b/be/model/buyer.py
index fad0672..06a3f9b 100644
--- a/be/model/buyer.py
+++ b/be/model/buyer.py
@@ -8,7 +8,7 @@ from be.model.orm_models import UserStore as UserStore_model
 from sqlalchemy.exc import SQLAlchemyError
 from sqlalchemy import and_,or_
 from datetime import datetime
-import json
+from datetime import timedelta
 
 class CJsonEncoder(json.JSONEncoder):
     def default(self, obj):
@@ -346,7 +346,8 @@ class Buyer(db_conn.CheckExist):
 
         return 200, "ok"
 
-    # 用户查询自己所有的历史订单
+    # 用户查询自己所有的历史订单，
+    # 计算查询的时间，如果超时10s，则删去该订单
     # [{order_id,store_id,status,detail:[{book_id,count,price}]}]
     def search_order(self, user_id: str):
         try:
@@ -356,26 +357,55 @@ class Buyer(db_conn.CheckExist):
                 if len(rows) == 0:
                     return error.error_user_no_order(user_id) + ("", )
 
+            out = timedelta(seconds=5)  # 设置为5s后未支付取消
+
             with self.get_session() as session:
                 order_list = []
                 for row in rows:
                     order_id = row.order_id
                     store_id = row.store_id
-                    time = json.dumps(row.time, cls=CJsonEncoder)
                     status = row.status
+                    time = json.dumps(row.time, cls=CJsonEncoder)
 
-                    details = session.query(NewOrderDetail_model).filter(NewOrderDetail_model.order_id == order_id).all()
-                    if len(details) == 0:
-                        return error.error_invalid_order_id(order_id) + ("", )
-
-                    detail = []
-                    for item in details:
-                        book_id = item.book_id
-                        count = item.count
-                        price = item.price
-                        detail.append({'book_id':book_id, 'count':count, 'price':price})
-
-                    order_list.append({'order_id':order_id, 'store_id':store_id, 'time':time, 'status':status, 'detail':detail})
+                    if status == "未支付":
+                        time_create = row.time  # 创建订单的时间
+                        time_now = datetime.now()  # 现在的时间
+                        time_delta = time_now - time_create  # 创建订单的时间到现在的时间差
+                        if time_delta >= out:  # 删除NewOrder,NewOrderDetail
+                            session.query(NewOrder_model).filter(NewOrder_model.order_id == order_id).delete()
+                            session.query(NewOrderDetail_model).filter(
+                                NewOrderDetail_model.order_id == order_id).delete()
+                        else:
+                            details = session.query(NewOrderDetail_model).filter(NewOrderDetail_model.order_id == order_id).all()
+                            if len(details) == 0:
+                                return error.error_invalid_order_id(order_id) + ("", )
+
+                            detail = []
+                            for item in details:
+                                book_id = item.book_id
+                                count = item.count
+                                price = item.price
+                                detail.append({'book_id':book_id, 'count':count, 'price':price})
+
+                            order_list.append({'order_id':order_id, 'store_id':store_id, 'time':time, 'status':status, 'detail':detail})
+                    else:
+                        details = session.query(NewOrderDetail_model).filter(
+                            NewOrderDetail_model.order_id == order_id).all()
+                        if len(details) == 0:
+                            return error.error_invalid_order_id(order_id) + ("",)
+
+                        detail = []
+                        for item in details:
+                            book_id = item.book_id
+                            count = item.count
+                            price = item.price
+                            detail.append({'book_id': book_id, 'count': count, 'price': price})
+
+                        order_list.append({'order_id': order_id, 'store_id': store_id, 'time': time, 'status': status,
+                                           'detail': detail})
+
+                if not order_list:
+                    return error.error_user_no_order(user_id) + ("", )
 
         except SQLAlchemyError as e:
             return 528, "{}".format(str(e)), ""
diff --git a/be/model/seller.py b/be/model/seller.py
index 170ff68..439fb73 100644
--- a/be/model/seller.py
+++ b/be/model/seller.py
@@ -4,6 +4,7 @@ from be.model.orm_models import Store as Store_model,UserStore as UserStore_mode
 from sqlalchemy.exc import SQLAlchemyError
 from sqlalchemy import and_,or_
 from datetime import datetime
+from datetime import timedelta
 import json
 
 class CJsonEncoder(json.JSONEncoder):
@@ -121,7 +122,7 @@ class Seller(db_conn.CheckExist):
                                      NewOrder_model.status, NewOrder_model.time).filter(NewOrder_model.store_id == store_id).all()
                 if len(rows) == 0:
                     return error.error_store_no_order(store_id) + ("", )
-
+            out = timedelta(seconds=5)  # 设置为5s后未支付取消
             with self.get_session() as session:
                 order_list = []
                 for row in rows:
@@ -129,19 +130,45 @@ class Seller(db_conn.CheckExist):
                     buyer_id = row.user_id
                     time = json.dumps(row.time, cls=CJsonEncoder)
                     status = row.status
-
-                    details = session.query(NewOrderDetail_model).filter(NewOrderDetail_model.order_id == order_id).all()
-                    if len(details) == 0:
-                        return error.error_invalid_order_id(order_id) + ("", )
-
-                    detail = []
-                    for item in details:
-                        book_id = item.book_id
-                        count = item.count
-                        price = item.price
-                        detail.append({'book_id':book_id, 'count':count, 'price':price})
-
-                    order_list.append({'order_id':order_id, 'user_id':buyer_id, 'time':time, 'status':status, 'detail':detail})
+                    if status == "未支付":
+                        time_create = row.time  # 创建订单的时间
+                        time_now = datetime.now()  # 现在的时间
+                        time_delta = time_now - time_create  # 创建订单的时间到现在的时间差
+                        if time_delta >= out:  # 删除NewOrder,NewOrderDetail
+                            session.query(NewOrder_model).filter(NewOrder_model.order_id == order_id).delete()
+                            session.query(NewOrderDetail_model).filter(
+                                NewOrderDetail_model.order_id == order_id).delete()
+                        else:
+                            details = session.query(NewOrderDetail_model).filter(NewOrderDetail_model.order_id == order_id).all()
+                            if len(details) == 0:
+                                return error.error_invalid_order_id(order_id) + ("", )
+
+                            detail = []
+                            for item in details:
+                                book_id = item.book_id
+                                count = item.count
+                                price = item.price
+                                detail.append({'book_id':book_id, 'count':count, 'price':price})
+
+                            order_list.append({'order_id':order_id, 'user_id':buyer_id, 'time':time, 'status':status, 'detail':detail})
+                    else:
+                        details = session.query(NewOrderDetail_model).filter(
+                            NewOrderDetail_model.order_id == order_id).all()
+                        if len(details) == 0:
+                            return error.error_invalid_order_id(order_id) + ("",)
+
+                        detail = []
+                        for item in details:
+                            book_id = item.book_id
+                            count = item.count
+                            price = item.price
+                            detail.append({'book_id': book_id, 'count': count, 'price': price})
+
+                        order_list.append({'order_id': order_id, 'user_id': buyer_id, 'time': time, 'status': status,
+                                           'detail': detail})
+
+                if not order_list:
+                    return error.error_store_no_order(store_id) + ("", )
 
         except SQLAlchemyError as e:
             return 528, "{}".format(str(e)), ""
diff --git a/fe/test/test_timeout_cancel.py b/fe/test/test_timeout_cancel.py
new file mode 100644
index 0000000..8c80592
--- /dev/null
+++ b/fe/test/test_timeout_cancel.py
@@ -0,0 +1,59 @@
+import pytest
+
+from fe.test.gen_book_data import GenBook
+from fe.access.new_buyer import register_new_buyer
+import uuid
+from time import sleep
+
+class TestTimeOut:
+
+    @pytest.fixture(autouse=True)
+    def pre_run_initialization(self):
+        self.seller_id = "test_payment_seller_id_{}".format(str(uuid.uuid1()))
+        self.store_id = "test_payment_store_id_{}".format(str(uuid.uuid1()))
+        self.buyer_id = "test_payment_buyer_id_{}".format(str(uuid.uuid1()))
+        self.password = self.seller_id
+
+        yield
+
+    def test_timeout_cancel_buyer(self):
+        gen_book1 = GenBook(self.seller_id, self.store_id)
+        ok, buy_book_id_list1 = gen_book1.gen(non_exist_book_id=False, low_stock_level=False, max_book_count=5)
+        assert ok
+        gen_book2 = GenBook(self.seller_id+'_y', self.store_id+'_y')
+        ok, buy_book_id_list2 = gen_book2.gen(non_exist_book_id=False, low_stock_level=False, max_book_count=5)
+        assert ok
+        b = register_new_buyer(self.buyer_id, self.password)
+        code, order_id1 = b.new_order(self.store_id, buy_book_id_list1)
+        assert code == 200
+        sleep(6)
+        code, order_id2 = b.new_order(self.store_id+'_y', buy_book_id_list2)
+        assert code == 200
+        code, order_list = b.search_order()
+        assert code == 200
+        assert len(order_list) == 1
+
+    def test_timeout_no_order_buyer(self):
+        gen_book1 = GenBook(self.seller_id, self.store_id)
+        ok, buy_book_id_list1 = gen_book1.gen(non_exist_book_id=False, low_stock_level=False, max_book_count=5)
+        assert ok
+        b = register_new_buyer(self.buyer_id, self.password)
+        code, order_id1 = b.new_order(self.store_id, buy_book_id_list1)
+        assert code == 200
+        sleep(6)
+        code, order_list = b.search_order()
+        assert code != 200
+
+    def test_timeout_cancel_seller(self):
+        gen_book1 = GenBook(self.seller_id, self.store_id)
+        ok, buy_book_id_list1 = gen_book1.gen(non_exist_book_id=False, low_stock_level=False, max_book_count=5)
+        assert ok
+        s = gen_book1.seller
+        b = register_new_buyer(self.buyer_id, self.password)
+        code, order_id1 = b.new_order(self.store_id, buy_book_id_list1)
+        assert code == 200
+        sleep(6)
+        code = s.seller_search(self.store_id)
+        assert code != 200
+
+

commit 163c5ab259acd03a1fe07fb0738e581d74d970e0
Author: xuqi <xuqi18268712006@163.com>
Date:   Wed Dec 7 17:20:36 2022 +0800

    xq2 买家主动取消订单/卖家、买家查询订单

diff --git a/be/model/buyer.py b/be/model/buyer.py
index f8ae9dc..fad0672 100644
--- a/be/model/buyer.py
+++ b/be/model/buyer.py
@@ -8,6 +8,14 @@ from be.model.orm_models import UserStore as UserStore_model
 from sqlalchemy.exc import SQLAlchemyError
 from sqlalchemy import and_,or_
 from datetime import datetime
+import json
+
+class CJsonEncoder(json.JSONEncoder):
+    def default(self, obj):
+        if isinstance(obj, datetime):
+            return obj.strftime('%Y-%m-%d %H:%M:%S')
+        else:
+            return json.JSONEncoder.default(self, obj)
 
 class Buyer(db_conn.CheckExist):
 
@@ -249,3 +257,128 @@ class Buyer(db_conn.CheckExist):
             return 530, "{}".format(str(e))
 
         return 200, "ok"
+
+    # 取消订单功能（用户主动，未实现超时取消）
+    def cancel_order(self, user_id: str, order_id: str) -> (int, str):
+        try:
+            row = None
+            with self.get_session() as session:
+                row = session.query(NewOrder_model.order_id, NewOrder_model.user_id,
+                                    NewOrder_model.store_id, NewOrder_model.status).filter(NewOrder_model.order_id == order_id).all()
+
+                if len(row) != 1:
+                    return error.error_invalid_order_id(order_id)
+
+            row = row[0]
+            buyer_id = row.user_id
+            store_id = row.store_id
+            status = row.status
+
+            if not self.store_id_exist(store_id):
+                return error.error_non_exist_store_id(store_id)
+            if status == "已发货" or status == "已收货":
+                return error.error_status_not_allowed(order_id)  # 已发货/已收货的订单不能取消
+            if user_id != buyer_id:
+                return error.error_authorization_fail()
+
+            # 放在一个session里，可以rollback
+            # 执行cancel(两种status，分情况: 已支付的订单要多增加 更改卖家和买家的余额变动，其他一样)
+            with self.get_session() as session:
+                details = session.query(NewOrderDetail_model.order_id, NewOrderDetail_model.book_id
+                                       , NewOrderDetail_model.count, NewOrderDetail_model.price).filter(NewOrderDetail_model.order_id == order_id).all()
+                if len(details) == 0:
+                    return error.error_invalid_order_id(order_id)
+
+                # 在仓库添加书的数量,同时计算获得total_price
+                total_price = 0
+                for detail in details:
+                    book_id = detail.book_id
+                    count = detail.count
+                    price = detail.price
+                    total_price += count * price
+
+                    stock = session.query(Store_model).filter(and_(Store_model.store_id == store_id, Store_model.book_id == book_id)).all()
+                    if len(stock) != 1:
+                        return error.error_non_exist_book_id(book_id)
+                    stock = stock[0]
+                    stock.stock_level = stock.stock_level + count
+                    session.add(stock)
+
+                # 卖家扣钱。买家加钱
+                if status == "已支付":
+                    # 获取卖家id
+                    seller = session.query(UserStore_model.user_id).filter(UserStore_model.store_id == store_id).all()
+                    if len(seller) != 1:
+                        return error.error_exist_store_id(store_id)
+                    seller_id = seller[0].user_id
+                    # 检查卖家是否有足够的余额被扣去
+                    seller = session.query(User_model).filter(
+                        and_(User_model.user_id == seller_id, User_model.balance >= total_price)).all()
+                    if len(seller) != 1:
+                        return error.error_not_sufficient_funds(order_id)
+                    seller = seller[0]
+                    seller.balance = seller.balance - total_price
+                    session.add(seller)
+
+                    buyer = session.query(User_model).filter(User_model.user_id == buyer_id).all()
+                    if len(buyer) != 1:
+                        return error.error_non_exist_user_id(buyer_id)
+                    buyer = buyer[0]
+                    buyer.balance = buyer.balance + total_price
+                    session.add(buyer)
+
+                # 删除new_order, new_order_detail
+                new_order = session.query(NewOrder_model).filter(NewOrder_model.order_id==order_id).all()
+                if len(new_order) !=1:
+                    return error.error_invalid_order_id(order_id)
+                session.query(NewOrder_model).filter(NewOrder_model.order_id==order_id).delete()
+
+                new_order = session.query(NewOrderDetail_model).filter(NewOrderDetail_model.order_id==order_id).all()
+                if len(new_order) ==0:
+                    return error.error_invalid_order_id(order_id)
+                session.query(NewOrderDetail_model).filter(NewOrderDetail_model.order_id==order_id).delete()
+
+        except SQLAlchemyError as e:
+            return 528, "{}".format(str(e))
+
+        except BaseException as e:
+            return 530, "{}".format(str(e))
+
+        return 200, "ok"
+
+    # 用户查询自己所有的历史订单
+    # [{order_id,store_id,status,detail:[{book_id,count,price}]}]
+    def search_order(self, user_id: str):
+        try:
+            with self.get_session() as session:
+                rows = session.query(NewOrder_model.order_id, NewOrder_model.store_id,
+                                     NewOrder_model.status, NewOrder_model.time).filter(NewOrder_model.user_id == user_id).all()
+                if len(rows) == 0:
+                    return error.error_user_no_order(user_id) + ("", )
+
+            with self.get_session() as session:
+                order_list = []
+                for row in rows:
+                    order_id = row.order_id
+                    store_id = row.store_id
+                    time = json.dumps(row.time, cls=CJsonEncoder)
+                    status = row.status
+
+                    details = session.query(NewOrderDetail_model).filter(NewOrderDetail_model.order_id == order_id).all()
+                    if len(details) == 0:
+                        return error.error_invalid_order_id(order_id) + ("", )
+
+                    detail = []
+                    for item in details:
+                        book_id = item.book_id
+                        count = item.count
+                        price = item.price
+                        detail.append({'book_id':book_id, 'count':count, 'price':price})
+
+                    order_list.append({'order_id':order_id, 'store_id':store_id, 'time':time, 'status':status, 'detail':detail})
+
+        except SQLAlchemyError as e:
+            return 528, "{}".format(str(e)), ""
+        except BaseException as e:
+            return 530, "{}".format(str(e)), ""
+        return 200, "ok", order_list
diff --git a/be/model/error.py b/be/model/error.py
index 97c1b0a..9a136c7 100644
--- a/be/model/error.py
+++ b/be/model/error.py
@@ -11,9 +11,9 @@ error_code = {
     518: "invalid order id {}",
     519: "not sufficient funds, order id {}",
     520: "status not allowed, order id {}",
-    521: "",
+    521: "user have no orders, user id",
     522: "non exist query result",
-    523: "",
+    523: "store have no orders, store id {}",
     524: "",
     525: "",
     526: "",
@@ -65,9 +65,18 @@ def error_authorization_fail():
 def error_and_message(code, message):
     return code, message
 
+
 def error_non_exist_search():
     return 522, error_code[522]
 
+
 def error_status_not_allowed(order_id):
     return 520, error_code[520].format(order_id)
 
+
+def error_user_no_order(user_id):
+    return 521, error_code[521].format(user_id)
+
+
+def error_store_no_order(store_id):
+    return 523, error_code[523].format(store_id)
diff --git a/be/model/seller.py b/be/model/seller.py
index 69f3119..170ff68 100644
--- a/be/model/seller.py
+++ b/be/model/seller.py
@@ -3,6 +3,15 @@ from be.model import db_conn
 from be.model.orm_models import Store as Store_model,UserStore as UserStore_model,NewOrder as NewOrder_model, NewOrderDetail as NewOrderDetail_model
 from sqlalchemy.exc import SQLAlchemyError
 from sqlalchemy import and_,or_
+from datetime import datetime
+import json
+
+class CJsonEncoder(json.JSONEncoder):
+    def default(self, obj):
+        if isinstance(obj, datetime):
+            return obj.strftime('%Y-%m-%d %H:%M:%S')
+        else:
+            return json.JSONEncoder.default(self, obj)
 
 class Seller(db_conn.CheckExist):
 
@@ -101,4 +110,41 @@ class Seller(db_conn.CheckExist):
             return 528, "{}".format(str(e))
         except BaseException as e:
             return 530, "{}".format(str(e))
-        return 200, "ok"
\ No newline at end of file
+        return 200, "ok"
+
+    # 卖家查询商店的订单信息
+    # [{order_id,user_id,status,time,detail:{book_id,count,price}}]
+    def seller_search(self, user_id: str, store_id: str):
+        try:
+            with self.get_session() as session:
+                rows = session.query(NewOrder_model.order_id, NewOrder_model.user_id,
+                                     NewOrder_model.status, NewOrder_model.time).filter(NewOrder_model.store_id == store_id).all()
+                if len(rows) == 0:
+                    return error.error_store_no_order(store_id) + ("", )
+
+            with self.get_session() as session:
+                order_list = []
+                for row in rows:
+                    order_id = row.order_id
+                    buyer_id = row.user_id
+                    time = json.dumps(row.time, cls=CJsonEncoder)
+                    status = row.status
+
+                    details = session.query(NewOrderDetail_model).filter(NewOrderDetail_model.order_id == order_id).all()
+                    if len(details) == 0:
+                        return error.error_invalid_order_id(order_id) + ("", )
+
+                    detail = []
+                    for item in details:
+                        book_id = item.book_id
+                        count = item.count
+                        price = item.price
+                        detail.append({'book_id':book_id, 'count':count, 'price':price})
+
+                    order_list.append({'order_id':order_id, 'user_id':buyer_id, 'time':time, 'status':status, 'detail':detail})
+
+        except SQLAlchemyError as e:
+            return 528, "{}".format(str(e)), ""
+        except BaseException as e:
+            return 530, "{}".format(str(e)), ""
+        return 200, "ok", order_list
diff --git a/be/view/buyer.py b/be/view/buyer.py
index 674ceb0..9d1498f 100644
--- a/be/view/buyer.py
+++ b/be/view/buyer.py
@@ -2,6 +2,7 @@ from flask import Blueprint
 from flask import request
 from flask import jsonify
 from be.model.buyer import Buyer
+import json
 
 bp_buyer = Blueprint("buyer", __name__, url_prefix="/buyer")
 
@@ -41,6 +42,7 @@ def add_funds():
     code, message = b.add_funds(user_id, password, add_value)
     return jsonify({"message": message}), code
 
+
 @bp_buyer.route("/received", methods=["POST"])
 def received():
     user_id: str = request.json.get("user_id")
@@ -48,3 +50,37 @@ def received():
     b = Buyer()
     code, message = b.received(user_id, order_id)
     return jsonify({"message": message}), code
+
+
+@bp_buyer.route("/cancel_order", methods=["POST"])
+def cancel_order():
+    user_id: str = request.json.get("user_id")
+    order_id: str = request.json.get("order_id")
+    b = Buyer()
+    code, message = b.cancel_order(user_id, order_id)
+    return jsonify({"message": message}), code
+
+
+@bp_buyer.route("/search_order", methods=["POST"])
+def search_order():
+    user_id: str = request.json.get("user_id")
+    b = Buyer()
+    code, message, rows = b.search_order(user_id)
+    if not rows:
+        print('be: no order content !')
+        return jsonify({"message": message, "order_list": rows}), code
+    else:
+        data = []
+        for item in rows:
+            a = list(item.values())
+            d = []
+            for i in a[-1]:
+                i = list(i.values())
+                d.append(i)
+            a[-1] = d
+            data.append(a)
+
+        print('be:', data)
+        return json.dumps({"order_list": data}), code
+
+
diff --git a/be/view/seller.py b/be/view/seller.py
index 5cdb86f..566d4a1 100644
--- a/be/view/seller.py
+++ b/be/view/seller.py
@@ -50,3 +50,26 @@ def delivered():
     code, message = s.delivered(user_id, order_id)
 
     return jsonify({"message": message}), code
+
+@bp_seller.route("/seller_search", methods=["POST"])
+def search_order():
+    user_id: str = request.json.get("user_id")
+    store_id: str = request.json.get("store_id")
+    s = seller.Seller()
+    code, message, rows = s.seller_search(user_id, store_id)
+    if not rows:
+        print('be: no order content !')
+        return jsonify({"message": message, "order_list": rows}), code
+    else:
+        data = []
+        for item in rows:
+            a = list(item.values())
+            d = []
+            for i in a[-1]:
+                i = list(i.values())
+                d.append(i)
+            a[-1] = d
+            data.append(a)
+
+        print('be:', data)
+        return json.dumps({"order_list": data}), code
diff --git a/fe/access/buyer.py b/fe/access/buyer.py
index b42da34..1b40cbd 100644
--- a/fe/access/buyer.py
+++ b/fe/access/buyer.py
@@ -47,3 +47,19 @@ class Buyer:
         headers = {"token": self.token}
         r = requests.post(url, headers=headers, json=json)
         return r.status_code
+
+    def cancel_order(self, order_id: str) -> int:
+        json = {"user_id": self.user_id, "order_id": order_id}
+        url = urljoin(self.url_prefix, "cancel_order")
+        headers = {"token": self.token}
+        r = requests.post(url, headers=headers, json=json)
+        return r.status_code
+
+    def search_order(self):
+        json = {"user_id": self.user_id}
+        url = urljoin(self.url_prefix, "search_order")
+        headers = {"token": self.token, "Content-Type": "application/json"}
+        r = requests.post(url, headers=headers, json=json)
+        response_json = r.json()
+        print('fe:', response_json.get('order_list'))
+        return r.status_code, response_json.get('order_list')
diff --git a/fe/access/seller.py b/fe/access/seller.py
index 6527c8f..4ee3a64 100644
--- a/fe/access/seller.py
+++ b/fe/access/seller.py
@@ -61,3 +61,14 @@ class Seller:
         r = requests.post(url, headers=headers, json=json)
         return r.status_code
 
+    def seller_search(self, store_id:str):
+        json = {
+            "user_id": self.seller_id,
+            "store_id": store_id
+        }
+        url = urljoin(self.url_prefix, "seller_search")
+        headers = {"token": self.token, "Content-Type": "application/json"}
+        r = requests.post(url, headers=headers, json=json)
+        response_json = r.json()
+        print('fe:', response_json.get('order_list'))
+        return r.status_code, response_json.get('order_list')
diff --git a/fe/test/test_cancel_order.py b/fe/test/test_cancel_order.py
new file mode 100644
index 0000000..0fbdd10
--- /dev/null
+++ b/fe/test/test_cancel_order.py
@@ -0,0 +1,91 @@
+import pytest
+
+from fe import conf
+from fe.access.buyer import Buyer
+from fe.access.book import Book
+from fe.test.gen_book_data import GenBook
+from fe.access.new_buyer import register_new_buyer
+import uuid
+
+class TestCancelOrder:
+
+    @pytest.fixture(autouse=True)
+    def pre_run_initialization(self):
+        self.seller_id = "test_payment_seller_id_{}".format(str(uuid.uuid1()))
+        self.store_id = "test_payment_store_id_{}".format(str(uuid.uuid1()))
+        self.buyer_id = "test_payment_buyer_id_{}".format(str(uuid.uuid1()))
+        self.password = self.seller_id
+
+        gen_book = GenBook(self.seller_id, self.store_id)
+        ok, buy_book_id_list = gen_book.gen(non_exist_book_id=False, low_stock_level=False, max_book_count=5)
+        self.buy_book_info_list = gen_book.buy_book_info_list
+        assert ok
+        b = register_new_buyer(self.buyer_id, self.password)
+        self.buyer = b
+        code, self.order_id = b.new_order(self.store_id, buy_book_id_list)
+        assert code == 200
+
+        self.total_price = 0
+        for item in self.buy_book_info_list:
+            book: Book = item[0]
+            num = item[1]
+            if book.price is None:
+                continue
+            else:
+                self.total_price = self.total_price + book.price * num
+
+        self.seller = gen_book.seller
+
+        yield
+
+    def test_unpaid_ok(self):
+        code = self.buyer.cancel_order(self.order_id)
+        assert code == 200
+
+    def test_paid_ok(self):
+        code = self.buyer.add_funds(self.total_price)
+        assert code == 200
+        code = self.buyer.payment(self.order_id)
+        assert code == 200
+        code = self.buyer.cancel_order(self.order_id)
+        assert code == 200
+
+    def test_error_delivered_received(self):
+        code = self.buyer.add_funds(self.total_price)
+        assert code == 200
+        code = self.buyer.payment(self.order_id)
+        assert code == 200
+        code = self.seller.delivered(self.order_id)
+        assert code == 200
+        code = self.buyer.cancel_order(self.order_id)
+        assert code != 200
+        code = self.buyer.received(self.order_id)
+        assert code == 200
+        code = self.buyer.cancel_order(self.order_id)
+        assert code != 200
+
+    def test_error_order(self):
+        code = self.buyer.cancel_order(self.order_id+'_x')
+        assert code != 200
+
+    def test_error_repeat(self):
+        code = self.buyer.cancel_order(self.order_id)
+        assert code == 200
+        code = self.buyer.cancel_order(self.order_id)
+        assert code != 200
+
+    def test_error_user_id(self):
+        self.buyer.user_id = self.buyer.user_id + '_x'
+        code = self.buyer.cancel_order(self.order_id)
+        assert code != 200
+
+    def test_error_seller_no_funds(self):
+        s = Buyer(conf.URL, user_id = self.seller_id, password = self.seller_id)
+        code = self.buyer.add_funds(self.total_price)
+        assert code == 200
+        code = self.buyer.payment(self.order_id)
+        assert code == 200
+        code = s.add_funds(-self.total_price-100000)
+        assert code == 200
+        code = self.buyer.cancel_order(self.order_id)
+        assert code != 200
diff --git a/fe/test/test_deliver.py b/fe/test/test_deliver.py
index d7cf8cf..e428c13 100644
--- a/fe/test/test_deliver.py
+++ b/fe/test/test_deliver.py
@@ -36,6 +36,10 @@ class TestDeliver:
 
         yield
 
+    def test_error_order_id(self):
+        code = self.seller.delivered(self.order_id+'_x')
+        assert code != 200
+
     def test_error_deliver_error(self):
         code = self.seller.delivered(self.order_id)
         assert code != 200
@@ -50,5 +54,22 @@ class TestDeliver:
         assert code == 200
 
     def test_error_repeat_deliver(self):
+        code = self.buyer.add_funds(self.total_price + 100000)
+        assert code == 200
+        # 订单状态为已支付
+        code = self.buyer.payment(self.order_id)
+        assert code == 200
+        code = self.seller.delivered(self.order_id)
+        assert code == 200
+        code = self.seller.delivered(self.order_id)
+        assert code != 200
+
+    def test_error_seller_id(self):
+        code = self.buyer.add_funds(self.total_price + 100000)
+        assert code == 200
+        # 订单状态为已支付
+        code = self.buyer.payment(self.order_id)
+        assert code == 200
+        self.seller.seller_id = self.seller.seller_id + '_x'
         code = self.seller.delivered(self.order_id)
         assert code != 200
diff --git a/fe/test/test_receive.py b/fe/test/test_receive.py
index 0c802ab..5ea5163 100644
--- a/fe/test/test_receive.py
+++ b/fe/test/test_receive.py
@@ -70,3 +70,11 @@ class TestReceive:
         code = self.buyer.received(self.order_id)
         assert code != 200
 
+    def test_error_user_id(self):
+        code = self.buyer.payment(self.order_id)
+        assert code == 200
+        code = self.seller.delivered(self.order_id)
+        assert code == 200
+        self.buyer.user_id = self.buyer.user_id + '_x'
+        code = self.buyer.received(self.order_id)
+        assert code != 200
diff --git a/fe/test/test_search_order.py b/fe/test/test_search_order.py
new file mode 100644
index 0000000..e9dd576
--- /dev/null
+++ b/fe/test/test_search_order.py
@@ -0,0 +1,45 @@
+import pytest
+
+from fe.test.gen_book_data import GenBook
+from fe.access.new_buyer import register_new_buyer
+import uuid
+
+class TestSearchOrder:
+
+    @pytest.fixture(autouse=True)
+    def pre_run_initialization(self):
+        self.seller_id = "test_payment_seller_id_{}".format(str(uuid.uuid1()))
+        self.store_id = "test_payment_store_id_{}".format(str(uuid.uuid1()))
+        self.buyer_id = "test_payment_buyer_id_{}".format(str(uuid.uuid1()))
+        self.password = self.seller_id
+
+        gen_book = GenBook(self.seller_id, self.store_id)
+        ok, buy_book_id_list = gen_book.gen(non_exist_book_id=False, low_stock_level=False, max_book_count=5)
+        self.buy_book_info_list = gen_book.buy_book_info_list
+        assert ok
+        b = register_new_buyer(self.buyer_id, self.password)
+        self.buyer = b
+        code, self.order_id = b.new_order(self.store_id, buy_book_id_list)
+        assert code == 200
+        self.seller = gen_book.seller
+
+        yield
+
+    def test_buyer_search(self):
+        code, _ = self.buyer.search_order()
+        assert code == 200
+        code = self.buyer.cancel_order(self.order_id)
+        assert code == 200
+
+    def test_error_no_order(self):
+        self.buyer.user_id = self.buyer.user_id + '_x'
+        code = self.buyer.search_order()
+        assert code != 200
+
+    def test_error_no_detail(self):
+        code, order_id = self.buyer.new_order(self.store_id, [])
+        assert code == 200
+        code = self.buyer.search_order()
+        assert code != 200
+
+
diff --git a/fe/test/test_seller_search.py b/fe/test/test_seller_search.py
new file mode 100644
index 0000000..bd92d2e
--- /dev/null
+++ b/fe/test/test_seller_search.py
@@ -0,0 +1,43 @@
+import pytest
+
+from fe.test.gen_book_data import GenBook
+from fe.access.new_buyer import register_new_buyer
+import uuid
+
+class TestSellerSearch:
+
+    @pytest.fixture(autouse=True)
+    def pre_run_initialization(self):
+        self.seller_id = "test_payment_seller_id_{}".format(str(uuid.uuid1()))
+        self.store_id = "test_payment_store_id_{}".format(str(uuid.uuid1()))
+        self.buyer_id = "test_payment_buyer_id_{}".format(str(uuid.uuid1()))
+        self.password = self.seller_id
+
+        gen_book = GenBook(self.seller_id, self.store_id)
+        ok, buy_book_id_list = gen_book.gen(non_exist_book_id=False, low_stock_level=False, max_book_count=5)
+        self.buy_book_info_list = gen_book.buy_book_info_list
+        assert ok
+        b = register_new_buyer(self.buyer_id, self.password)
+        self.buyer = b
+        code, self.order_id = b.new_order(self.store_id, buy_book_id_list)
+        assert code == 200
+        self.seller = gen_book.seller
+
+        yield
+
+    def test_seller_search(self):
+        code,_ = self.seller.seller_search(self.store_id)
+        assert code == 200
+
+    def test_error_no_order(self):
+        self.seller.seller_id = self.seller.seller_id + '_x'
+        code = self.seller.seller_search(self.store_id)
+        assert code != 200
+
+    def test_error_no_detail(self):
+        code, order_id = self.buyer.new_order(self.store_id, [])
+        assert code == 200
+        code = self.seller.seller_search(self.store_id)
+        assert code != 200
+
+

commit d6c33f053e5e176e6deeff431d44d083d262bbf1
Author: dirtyDan0 <ray3218@outlook.com>
Date:   Wed Dec 7 13:14:18 2022 +0800

    Docs: main.md

diff --git a/.gitignore b/.gitignore
index 9ac0cf3..1fd8b24 100644
--- a/.gitignore
+++ b/.gitignore
@@ -8,4 +8,6 @@ htmlcov
 __pycache__/
 not_upload/
 bookstore.db
-/data/bookstore.db
\ No newline at end of file
+/data/bookstore.db
+/data/bookstore_backup.db
+wlm_requirements.txt
\ No newline at end of file
diff --git a/markdown/main.md b/markdown/main.md
index e69de29..ab471e0 100644
--- a/markdown/main.md
+++ b/markdown/main.md
@@ -0,0 +1,277 @@
+# Bookstore
+
+## 成员以及分工
+
+| 学号        | 姓名   | 分工                                                     |
+| ----------- | ------ | -------------------------------------------------------- |
+| 10205501460 | 吴陆盟 | 实现并测试前60%功能；管理`Github`仓库；测试整个项目      |
+| 10205501407 | 李思涵 | 实现并测试搜索接口的图书功能                             |
+| 10205501420 | 许琪   | 实现并测试买家用户接口的收货功能和卖家用户接口的发货功能 |
+
+## 关系数据库设计
+
+### 概念设计
+
+
+
+### ER图
+
+
+
+### 关系模式
+
+
+
+## 功能实现
+
+### 数据库相关配置
+
+### 用户权限接口
+
+#### 登录
+
+**请求地址：**`POST` `/auth/login`
+
+**Request**
+
+Body:
+
+```
+{
+    "user_id":"$user name$",
+    "password":"$user password$",
+    "terminal":"$terminal code$"
+}
+```
+
+| 变量名   | 类型   | 描述     | 是否可为空 |
+| -------- | ------ | -------- | ---------- |
+| user_id  | string | 用户名   | N          |
+| password | string | 登陆密码 | N          |
+| terminal | string | 终端代码 | N          |
+
+**Response**
+
+Status Code:
+
+| 码   | 描述                       |
+| ---- | -------------------------- |
+| 200  | 登录成功                   |
+| 401  | 登录失败，用户名或密码错误 |
+
+Body:
+
+```
+{
+    "message":"$error message$",
+    "token":"$access token$"
+}
+```
+
+| 变量名  | 类型   | 描述                                                         | 是否可为空   |
+| ------- | ------ | ------------------------------------------------------------ | ------------ |
+| message | string | 返回错误消息，成功时为"ok"                                   | N            |
+| token   | string | 访问token，用户登录后每个需要授权的请求应在headers中传入这个token | 成功时不为空 |
+
+#### 登出
+
+**请求地址：**`POST` `/auth/logout`
+
+**Request**
+
+Headers:
+
+| key   | 类型   | 描述      |
+| ----- | ------ | --------- |
+| token | string | 访问token |
+
+Body:
+
+```
+{
+    "user_id":"$user name$"
+}
+```
+
+| 变量名  | 类型   | 描述   | 是否可为空 |
+| ------- | ------ | ------ | ---------- |
+| user_id | string | 用户名 | N          |
+
+#### Response
+
+Status Code:
+
+| 码   | 描述                        |
+| ---- | --------------------------- |
+| 200  | 登出成功                    |
+| 401  | 登出失败，用户名或token错误 |
+
+Body:
+
+```
+{
+    "message":"$error message$"
+}
+```
+
+| 变量名  | 类型   | 描述                       | 是否可为空 |
+| ------- | ------ | -------------------------- | ---------- |
+| message | string | 返回错误消息，成功时为"ok" | N          |
+
+#### 注册
+
+**请求地址：**`POST` `/auth/register`
+
+**Request**
+
+Body:
+
+```json
+{
+    "user_id":"$user name$",    
+    "password":"$user password$"
+}
+```
+
+| 变量名   | 类型   | 描述     | 是否可为空 |
+| -------- | ------ | -------- | ---------- |
+| user_id  | string | 用户名   | N          |
+| password | string | 登陆密码 | N          |
+
+**Response**
+
+Status Code:
+
+
+| 码   | 描述                 |
+| ---- | -------------------- |
+| 200  | 注册成功             |
+| 5XX  | 注册失败，用户名重复 |
+
+Body:
+
+```
+{
+    "message":"$error message$"
+}
+```
+
+| 变量名  | 类型   | 描述                       | 是否可为空 |
+| ------- | ------ | -------------------------- | ---------- |
+| message | string | 返回错误消息，成功时为"ok" | N          |
+
+#### 注销
+
+**请求地址：**`POST` `/auth/unregister`
+
+**Request**
+
+Body:
+
+```
+{
+    "user_id":"$user name$",
+    "password":"$user password$"
+}
+```
+
+| 变量名   | 类型   | 描述     | 是否可为空 |
+| -------- | ------ | -------- | ---------- |
+| user_id  | string | 用户名   | N          |
+| password | string | 登陆密码 | N          |
+
+**Response**
+
+Status Code:
+
+
+| 码   | 描述                               |
+| ---- | ---------------------------------- |
+| 200  | 注销成功                           |
+| 401  | 注销失败，用户名不存在或密码不正确 |
+
+
+Body:
+
+```
+{
+    "message":"$error message$"
+}
+```
+
+| 变量名  | 类型   | 描述                       | 是否可为空 |
+| ------- | ------ | -------------------------- | ---------- |
+| message | string | 返回错误消息，成功时为"ok" | N          |
+
+#### 修改密码
+
+**请求地址：**`POST` `/auth/password`
+
+**Request**
+
+Body:
+
+```
+{
+    "user_id":"$user name$",
+    "oldPassword":"$old password$",
+    "newPassword":"$new password$"
+}
+```
+
+| 变量名      | 类型   | 描述         | 是否可为空 |
+| ----------- | ------ | ------------ | ---------- |
+| user_id     | string | 用户名       | N          |
+| oldPassword | string | 旧的登陆密码 | N          |
+| newPassword | string | 新的登陆密码 | N          |
+
+**Response**
+
+Status Code:
+
+| 码   | 描述         |
+| ---- | ------------ |
+| 200  | 更改密码成功 |
+| 401  | 更改密码失败 |
+
+Body:
+
+```
+{
+    "message":"$error message$",
+}
+```
+
+| 变量名  | 类型   | 描述                       | 是否可为空 |
+| ------- | ------ | -------------------------- | ---------- |
+| message | string | 返回错误消息，成功时为"ok" | N          |
+
+### 买家用户接口
+
+#### 下单
+
+#### 付款
+
+#### 充值
+
+#### 收货（附加功能）
+
+### 卖家用户接口
+
+#### 创建店铺
+
+#### 添加书籍信息
+
+#### 添加书籍库存
+
+#### 发货（附加功能）
+
+### 搜索接口
+
+#### 搜索图书（附加功能）
+
+## 测试过程
+
+## 测试结果
+
+## 附录
\ No newline at end of file
diff --git a/markdown/wlm.md b/markdown/wlm.md
deleted file mode 100644
index e69de29..0000000
diff --git a/memo.md b/memo.md
deleted file mode 100644
index 05f8695..0000000
--- a/memo.md
+++ /dev/null
@@ -1,4 +0,0 @@
-> 这是一个负责记录开发过程中的一些注意事项的md
-
-改orm
-加字段 status time 在 neworder
\ No newline at end of file
diff --git a/setup.py b/setup.py
deleted file mode 100644
index 3910635..0000000
--- a/setup.py
+++ /dev/null
@@ -1,22 +0,0 @@
-import setuptools
-
-with open("README.md", "r") as fh:
-    long_description = fh.read()
-
-setuptools.setup(
-    name="bookstore",
-    version="0.0.1",
-    author="DaSE-DBMS",
-    author_email="DaSE-DBMS@DaSE-DBMS.com",
-    description="Buy Books Online",
-    long_description=long_description,
-    long_description_content_type="text/markdown",
-    url="https://github.com/DaSE-DBMS/bookstore.git",
-    packages=setuptools.find_packages(),
-    classifiers=[
-        "Programming Language :: Python :: 3",
-        "License :: OSI Approved :: MIT License",
-        "Operating System :: OS Independent",
-    ],
-    python_requires=">=3.6",
-)

commit 007a8830d222147546126bd72d5527e20820712d
Author: Li Sihan <10205501407@stu.ecnu.edu.cn>
Date:   Wed Dec 7 01:54:38 2022 +0800

    search1_ok

diff --git a/be/model/searcher.py b/be/model/searcher.py
index d58acf1..cf82da6 100644
--- a/be/model/searcher.py
+++ b/be/model/searcher.py
@@ -8,23 +8,21 @@ from sqlalchemy import and_, or_
 
 class Searcher(db_conn.CheckExist):
 
-    # 题目，作者，标签，简介，目录(title, author, tags, book_intro, content)
+    # 题目，作者，出版商，翻译，出版日期，页数，价格，标签，简介，目录
     def search(self, user_id: str, store_id: str, keyword: str):
         try:
             # 全站搜索
             if store_id == '':
-                #print("222")
-                #print(self.user_id_exist(user_id))
                 if not self.user_id_exist(user_id):
                     return error.error_non_exist_user_id(user_id)
-                #print("333")
+
                 with self.get_session() as session:
-                    #print("1111")
+
                     row = session.query(book_model.title, book_model.author, book_model.publisher,
                                         book_model.translator,
                                         book_model.pub_year, book_model.pages, book_model.price,
                                         book_model.author_intro,
-                                        book_model.book_intro, book_model.tags, book_model.picture) \
+                                        book_model.book_intro, book_model.tags) \
                         .join(Store_model, Store_model.book_id == book_model.id) \
                         .filter(and_(Store_model.stock_level > 0, or_(
                         book_model.title.like("%" + keyword + "%"), book_model.author.like("%" + keyword + "%"),
@@ -57,7 +55,7 @@ class Searcher(db_conn.CheckExist):
                                         book_model.translator,
                                         book_model.pub_year, book_model.pages, book_model.price,
                                         book_model.author_intro,
-                                        book_model.book_intro, book_model.tags, book_model.picture) \
+                                        book_model.book_intro, book_model.tags) \
                         .join(Store_model, Store_model.book_id == book_model.id) \
                         .filter(and_(Store_model.store_id == store_id, Store_model.stock_level > 0, or_(
                         book_model.title.like("%" + keyword + "%"), book_model.author.like("%" + keyword + "%"),
diff --git a/be/view/searcher.py b/be/view/searcher.py
index 309ec27..90b7092 100644
--- a/be/view/searcher.py
+++ b/be/view/searcher.py
@@ -1,30 +1,53 @@
+import json
+
 from flask import Blueprint
 from flask import request
 from flask import jsonify
 from be.model.searcher import Searcher
-import json
 
 bp_searcher = Blueprint("searcher", __name__, url_prefix="/searcher")
 
 
 @bp_searcher.route("/search", methods=["POST"])
 def search():
-    print("333333333")
     user_id: str = request.json.get("user_id")
     store_id: str = request.json.get("store_id")
     keyword: str = request.json.get("keyword")
-    se = Searcher()
-    print(se.search(user_id, store_id, keyword))
-    code, pagenum, row, show = se.search(user_id, store_id, keyword)
-    return jsonify({"pagenum": pagenum, "row": row, "show": show}), code
+    va: bool = request.json.get("variable")
 
+    se = Searcher()
+    #print(se.search(user_id, store_id, keyword))
+    if va:
+        code, message, pagenum, row, show = se.search(user_id, store_id, keyword)
+        #print(code)
+        data1 = []
+        for item in row:
+            data1.append(list(item))
+        data2 = []
+        for item in show:
+            data2.append(list(item))
+        return json.dumps({"pagenum": pagenum, "row": data1, "show": data2}), code
+    else:
+        code, message = se.search(user_id, store_id, keyword)
+        return jsonify({"message": message}), code
 
 @bp_searcher.route("/show_pages", methods=["POST"])
 def show_pages():
     user_id: str = request.json.get("user_id")
     page: int = request.json.get("page")
     content: str = request.json.get("content")
-
+    va: bool = request.json.get("variable")
+    print(va)
     se = Searcher()
-    code, show, row = se.show_pages(user_id, page, content)
-    return jsonify({"show": show, "row": row}), code
+    if va:
+        code, message, show, row = se.show_pages(user_id, page, content)
+        data1 = []
+        for item in row:
+            data1.append(list(item))
+        data2 = []
+        for item in show:
+            data2.append(list(item))
+        return jsonify({"show": data2, "row": data1}), code
+    else:
+        code, message = se.search(user_id, page, content)
+        return jsonify({"message": message}), code
diff --git a/fe/access/searcher.py b/fe/access/searcher.py
index 4b49260..cc5a417 100644
--- a/fe/access/searcher.py
+++ b/fe/access/searcher.py
@@ -14,33 +14,42 @@ class Searcher:
         code, self.token = self.auth.login(self.user_id, self.password, self.terminal)
         assert code == 200
 
-    def search(self, store_id: str, keyword: str):
+    def search(self, store_id: str, keyword: str, va: bool):
         json = {
             "user_id": self.user_id,
             "store_id": store_id,
-            "keyword": keyword
+            "keyword": keyword,
+            "variable": va
         }
         url = urljoin(self.url_prefix, "search")
         headers = {"token": self.token, "Content-Type": "application/json"}
 
         #json_str = json.dumps(json_)
         #print(json_str)
-        print(url)
+        #print(url)
         r = requests.post(url, headers=headers, json=json)
-        print(r)
         response_json = r.json()
-        return r.status_code, response_json.get("pagenum"), response_json.get("row"), response_json.get("show")
+        if va:
+            return r.status_code, response_json.get("pagenum"), response_json.get("row"), response_json.get("show")
         #print(r)
         #return r.status_code
+        else:
+            print(r)
+            return r.status_code
 
-    def show_pages(self, page, content):
+
+    def show_pages(self, page, content, va):
         json = {
             "user_id": self.user_id,
             "page": int(page),
-            "content": content
+            "content": content,
+            "variable": va
         }
         url = urljoin(self.url_prefix, "show_pages")
         headers = {"token": self.token}
         r = requests.post(url, headers=headers, json=json)
         response_json = r.json()
-        return r.status_code, response_json.get("pagenum"), response_json.get("row"), response_json.get("show")
+        if va:
+            return r.status_code, response_json.get("pagenum"), response_json.get("row"), response_json.get("show")
+        else:
+            return r.status_code
\ No newline at end of file
diff --git a/fe/test/test_search.py b/fe/test/test_search.py
index ff64dc3..b976339 100644
--- a/fe/test/test_search.py
+++ b/fe/test/test_search.py
@@ -13,61 +13,55 @@ class TestSearch:
         self.password = self.searcher_id
         self.searcher = register_new_searcher(self.searcher_id, self.password)
 
-        #self.store_id1 = "test_search_store_id_{}".format(str(uuid.uuid1())) #店铺内
-        self.store_id1 = "test_search_store_id_a6493f19-7565-11ed-a111-f8ac65b9cbec"
+        self.store_id1 = "test_search_store_id_{}".format(str(uuid.uuid1())) #店铺内
+        #self.store_id1 = "test_search_store_id_a6493f19-7565-11ed-a111-f8ac65b9cbec"
         self.store_id0 = "" #全站
-        #self.add1 = AddStoreBook(self.store_id1) #店铺内
-        #self.add0 = AddStoreBook(self.store_id0) #全站
+        self.add1 = AddStoreBook(self.store_id1) #店铺内
+        self.add0 = AddStoreBook(self.store_id0) #全站
 
-        self.keyword = "美丽"
+        self.keyword = "人"
         self.page = 0
 
         yield
 
     def test_store_ok(self):
-        """
         ok = self.add1.add()
         assert ok
-        """
-        code1,pagenum,row,_ = self.searcher.search(store_id=self.store_id1, keyword=self.keyword)
+        code1,pagenum,row,_ = self.searcher.search(self.store_id1, self.keyword, True)
         #code1 = self.searcher.search(store_id=self.store_id1, keyword=self.keyword)
         assert code1 == 200
 
         if pagenum > 1:
             self.page = random.randint(1,pagenum)
-            code2,_,_,_ = self.searcher.show_pages(self.page, row)
+            code2,_,_,_ = self.searcher.show_pages(self.page, row, True)
             assert code2 == 200
 
     def test_all_ok(self):
-        """
         ok = self.add0.add()
         assert ok
-        """
-        code1, pagenum, row, _ = self.searcher.search(self.store_id0, self.keyword)
+        code1, pagenum, row, _ = self.searcher.search(self.store_id0, self.keyword, True)
         assert code1 == 200
-        """
+
         if pagenum > 1:
             self.page = random.randint(1, pagenum)
-            code2, _, _, _ = self.searcher.show_pages(self.page, row)
+            code2, _, _, _ = self.searcher.show_pages(self.page, row, True)
             assert code2 == 200
-        """
+
     def test_error_non_exist_search(self):
-        """
         ok = self.add0.add()
         assert ok
-        """
-        code,_,_,_ = self.searcher.search(self.store_id1, self.keyword+"xx")
-        assert code == 200
+        code = self.searcher.search(self.store_id1, self.keyword+"xx", False)
+        assert code != 200
 
     def test_non_exist_user_id(self):
         ok = self.add0.add()
         assert ok
         self.searcher.user_id = self.searcher.user_id + "_x"
-        code, _, _, _ = self.searcher.search(self.store_id1, self.keyword)
-        assert code == 200
+        code = self.searcher.search(self.store_id1, self.keyword, False)
+        assert code != 200
 
     def test_non_exist_store_id(self):
         ok = self.add0.add()
         assert ok
-        code,_,_,_ = self.searcher.search(self.store_id1+"x", self.keyword)
+        code = self.searcher.search(self.store_id1+"x", self.keyword ,False)
         assert code != 200
\ No newline at end of file

commit d1b68eec59e6cdf801f745104bcfe4c52fc667ec
Author: Li Sihan <10205501407@stu.ecnu.edu.cn>
Date:   Tue Dec 6 21:44:00 2022 +0800

    500-v2

diff --git a/be/model/searcher.py b/be/model/searcher.py
index 6624f31..d58acf1 100644
--- a/be/model/searcher.py
+++ b/be/model/searcher.py
@@ -13,13 +13,13 @@ class Searcher(db_conn.CheckExist):
         try:
             # 全站搜索
             if store_id == '':
-                print("222")
-                print(self.user_id_exist(user_id))
+                #print("222")
+                #print(self.user_id_exist(user_id))
                 if not self.user_id_exist(user_id):
                     return error.error_non_exist_user_id(user_id)
-                print("333")
+                #print("333")
                 with self.get_session() as session:
-                    print("1111")
+                    #print("1111")
                     row = session.query(book_model.title, book_model.author, book_model.publisher,
                                         book_model.translator,
                                         book_model.pub_year, book_model.pages, book_model.price,
@@ -36,15 +36,14 @@ class Searcher(db_conn.CheckExist):
                         return error.error_non_exist_search()
                     else:
                         pagenum = len(row) // 5
-                        if pagenum == 0:
+                        if pagenum == 0 :
+                            pagenum = 1
                             show = row
                         else:
                             page = len(row) % 5
-                            if page == 0:
-                                pagenum = pagenum
-                            else:
+                            if page != 0:
                                 pagenum += 1
-                            show = row.limit(5)
+                            show = row[:5]
                         # return 200, "ok", pagenum, row, show
             # 店铺搜索
             else:
@@ -71,14 +70,13 @@ class Searcher(db_conn.CheckExist):
                     else:
                         pagenum = len(row) // 5
                         if pagenum == 0:
+                            pagenum = 1
                             show = row
                         else:
                             page = len(row) % 5
-                            if page == 0:
-                                pagenum = pagenum
-                            else:
+                            if page != 0:
                                 pagenum += 1
-                            show = row.limit(5)
+                            show = row[:5]
                         #print(pagenum, row, show)
                         # return 200, "ok", pagenum, row, show
 
@@ -93,12 +91,12 @@ class Searcher(db_conn.CheckExist):
             if not self.user_id_exist(user_id):
                 return error.error_non_exist_user_id(user_id)
 
-            off = page * 5
-            remain = content - off
+            off = (page-1) * 5
+            remain = len(content) - off
             if remain > 5:
-                show = content.offset(off).limit(5)
+                show = content[off:(off+5)]
             else:
-                show = content.offset(off)
+                show = content[off:]
             # return 200, "ok", show, content
 
         except SQLAlchemyError as e:
diff --git a/be/view/searcher.py b/be/view/searcher.py
index 8ce22d8..309ec27 100644
--- a/be/view/searcher.py
+++ b/be/view/searcher.py
@@ -14,8 +14,9 @@ def search():
     store_id: str = request.json.get("store_id")
     keyword: str = request.json.get("keyword")
     se = Searcher()
+    print(se.search(user_id, store_id, keyword))
     code, pagenum, row, show = se.search(user_id, store_id, keyword)
-    return jsonify({"pagenum": pagenum, "row": row, "show": show}), code, "success"
+    return jsonify({"pagenum": pagenum, "row": row, "show": show}), code
 
 
 @bp_searcher.route("/show_pages", methods=["POST"])
@@ -25,5 +26,5 @@ def show_pages():
     content: str = request.json.get("content")
 
     se = Searcher()
-    code, show, content1 = se.show_pages(user_id, page, content)
-    return jsonify({"show": show, "content": content1}), code
+    code, show, row = se.show_pages(user_id, page, content)
+    return jsonify({"show": show, "row": row}), code
diff --git a/fe/access/searcher.py b/fe/access/searcher.py
index 705a68e..4b49260 100644
--- a/fe/access/searcher.py
+++ b/fe/access/searcher.py
@@ -21,13 +21,17 @@ class Searcher:
             "keyword": keyword
         }
         url = urljoin(self.url_prefix, "search")
-        headers = {"token": self.token}
+        headers = {"token": self.token, "Content-Type": "application/json"}
+
+        #json_str = json.dumps(json_)
+        #print(json_str)
         print(url)
         r = requests.post(url, headers=headers, json=json)
-
-        # response_json = r.json()
-        # return r.status_code, response_json.get("pagenum"), response_json.get("row"), response_json.get("show")
-        return r.status_code
+        print(r)
+        response_json = r.json()
+        return r.status_code, response_json.get("pagenum"), response_json.get("row"), response_json.get("show")
+        #print(r)
+        #return r.status_code
 
     def show_pages(self, page, content):
         json = {
diff --git a/fe/test/add_store_book.py b/fe/test/add_store_book.py
index ec79899..0935211 100644
--- a/fe/test/add_store_book.py
+++ b/fe/test/add_store_book.py
@@ -12,11 +12,11 @@ class AddStoreBook:
         self.user_id = "test_seller_id_{}".format(str(uuid.uuid1()))
         self.password = self.user_id
         self.seller = register_new_seller(self.user_id, self.password)
-        if store_id != None:
+        if store_id != "": #店铺内
             self.store_id = store_id
             code = self.seller.create_store(store_id)
             assert code == 200
-        else:
+        else: #全站
             self.store_id_num = random.randint(5, 20)
             for i in range(self.store_id_num):
                 self.store_id_list.append(str(uuid.uuid1()))
@@ -28,7 +28,7 @@ class AddStoreBook:
         book_db = book.BookDB()
         rows = book_db.get_book_count()
 
-        if  self.store_id_list == []:
+        if  self.store_id_list == []: #店铺内
             start = 0
             if rows > max_book_count:
                 start = random.randint(0, rows - max_book_count)
@@ -38,7 +38,7 @@ class AddStoreBook:
                 stock_level = random.randint(0, 100)
                 code = self.seller.add_book(self.store_id, stock_level, bk)
                 assert code == 200
-        else:
+        else: #全站
             for i in range(self.store_id_num):
                 start = 0
                 if rows > max_book_count:
@@ -47,7 +47,7 @@ class AddStoreBook:
                 books = book_db.get_book_info(start, size)
                 for bk in books:
                     stock_level = random.randint(0, 100)
-                    code = self.seller.add_book(self.store_id[i], stock_level, bk)
+                    code = self.seller.add_book(self.store_id_list[i], stock_level, bk)
                     assert code == 200
 
         return ok
diff --git a/fe/test/test_search.py b/fe/test/test_search.py
index daefe95..ff64dc3 100644
--- a/fe/test/test_search.py
+++ b/fe/test/test_search.py
@@ -13,53 +13,61 @@ class TestSearch:
         self.password = self.searcher_id
         self.searcher = register_new_searcher(self.searcher_id, self.password)
 
-        self.store_id1 = "test_search_store_id_{}".format(str(uuid.uuid1())) #店铺内
-        self.store_id0 = None #全站
-        self.add1 = AddStoreBook(self.store_id1) #店铺内
-        self.add0 = AddStoreBook(self.store_id0) #全站
+        #self.store_id1 = "test_search_store_id_{}".format(str(uuid.uuid1())) #店铺内
+        self.store_id1 = "test_search_store_id_a6493f19-7565-11ed-a111-f8ac65b9cbec"
+        self.store_id0 = "" #全站
+        #self.add1 = AddStoreBook(self.store_id1) #店铺内
+        #self.add0 = AddStoreBook(self.store_id0) #全站
 
-        self.keyword = '人'
+        self.keyword = "美丽"
         self.page = 0
 
         yield
 
     def test_store_ok(self):
-        ok = self.add1
+        """
+        ok = self.add1.add()
         assert ok
-        #code1,pagenum,row,_ = self.searcher.search(self.store_id1, self.keyword)
-        code1 = self.searcher.search(store_id=self.store_id1, keyword=self.keyword)
-        assert code1 == 200
         """
-        if pagenum != 0:
-            self.page = random.randint(0,pagenum)
+        code1,pagenum,row,_ = self.searcher.search(store_id=self.store_id1, keyword=self.keyword)
+        #code1 = self.searcher.search(store_id=self.store_id1, keyword=self.keyword)
+        assert code1 == 200
+
+        if pagenum > 1:
+            self.page = random.randint(1,pagenum)
             code2,_,_,_ = self.searcher.show_pages(self.page, row)
             assert code2 == 200
-        """
+
     def test_all_ok(self):
-        ok = self.add0
+        """
+        ok = self.add0.add()
         assert ok
+        """
         code1, pagenum, row, _ = self.searcher.search(self.store_id0, self.keyword)
         assert code1 == 200
-        if pagenum != 0:
-            self.page = random.randint(0, pagenum)
+        """
+        if pagenum > 1:
+            self.page = random.randint(1, pagenum)
             code2, _, _, _ = self.searcher.show_pages(self.page, row)
             assert code2 == 200
-
+        """
     def test_error_non_exist_search(self):
-        ok = self.add0
+        """
+        ok = self.add0.add()
         assert ok
+        """
         code,_,_,_ = self.searcher.search(self.store_id1, self.keyword+"xx")
         assert code == 200
 
     def test_non_exist_user_id(self):
-        ok = self.add0
+        ok = self.add0.add()
         assert ok
         self.searcher.user_id = self.searcher.user_id + "_x"
         code, _, _, _ = self.searcher.search(self.store_id1, self.keyword)
         assert code == 200
 
     def test_non_exist_store_id(self):
-        ok = self.add0
+        ok = self.add0.add()
         assert ok
         code,_,_,_ = self.searcher.search(self.store_id1+"x", self.keyword)
         assert code != 200
\ No newline at end of file

commit af63ea21da5055b1ff91a4985687106a5bfb36ce
Author: dirtyDan0 <ray3218@outlook.com>
Date:   Tue Dec 6 21:25:08 2022 +0800

    ignore data/bookstore.db

diff --git a/.gitignore b/.gitignore
index d1a6b0e..9ac0cf3 100644
--- a/.gitignore
+++ b/.gitignore
@@ -7,4 +7,5 @@ htmlcov
 *.pyc
 __pycache__/
 not_upload/
-bookstore.db
\ No newline at end of file
+bookstore.db
+/data/bookstore.db
\ No newline at end of file

commit 3b0375330541ba8bf2f645025767b254870656ee
Author: xuqi <xuqi18268712006@163.com>
Date:   Tue Dec 6 21:05:58 2022 +0800

    xuqi-receive-deliver

diff --git a/be/model/buyer.py b/be/model/buyer.py
index 2bac445..f8ae9dc 100644
--- a/be/model/buyer.py
+++ b/be/model/buyer.py
@@ -7,7 +7,7 @@ from be.model.orm_models import Store as Store_model, NewOrderDetail as NewOrder
 from be.model.orm_models import UserStore as UserStore_model
 from sqlalchemy.exc import SQLAlchemyError
 from sqlalchemy import and_,or_
-
+from datetime import datetime
 
 class Buyer(db_conn.CheckExist):
 
@@ -61,8 +61,9 @@ class Buyer(db_conn.CheckExist):
                         
                     session.add(new_order_detail)
 
-            
-                new_order = NewOrder_model(order_id = uid, store_id = store_id, user_id = user_id)
+                # 订单创建时间，状态初始为未支付
+                time_now = datetime.now()
+                new_order = NewOrder_model(order_id = uid, store_id = store_id, user_id = user_id, status = "未支付", time = time_now)
                 session.add(new_order)
                              
                         
@@ -153,18 +154,26 @@ class Buyer(db_conn.CheckExist):
                 seller = seller[0]
                 seller.balance = seller.balance+total_price
                 session.add(seller)
-            
-            
-                new_order = session.query(NewOrder_model).filter(NewOrder_model.order_id==order_id).all()
-                if len(new_order) !=1:
-                    return error.error_invalid_order_id(order_id)
-                session.query(NewOrder_model).filter(NewOrder_model.order_id==order_id).delete()
 
-            
-                new_order = session.query(NewOrderDetail_model).filter(NewOrderDetail_model.order_id==order_id).all()
-                if len(new_order) ==0:
+                # 支付以后订单不删除，修改状态已支付为未支付
+                order = session.query(NewOrder_model).filter(NewOrder_model.order_id == order_id).all()
+                if len(order) != 1:
                     return error.error_invalid_order_id(order_id)
-                session.query(NewOrderDetail_model).filter(NewOrderDetail_model.order_id==order_id).delete()
+
+                order = order[0]
+                order.status = "已支付"
+                session.add(order)
+
+                # new_order = session.query(NewOrder_model).filter(NewOrder_model.order_id==order_id).all()
+                # if len(new_order) !=1:
+                #     return error.error_invalid_order_id(order_id)
+                # session.query(NewOrder_model).filter(NewOrder_model.order_id==order_id).delete()
+                #
+                #
+                # new_order = session.query(NewOrderDetail_model).filter(NewOrderDetail_model.order_id==order_id).all()
+                # if len(new_order) ==0:
+                #     return error.error_invalid_order_id(order_id)
+                # session.query(NewOrderDetail_model).filter(NewOrderDetail_model.order_id==order_id).delete()
             
 
         except SQLAlchemyError as e:
@@ -202,3 +211,41 @@ class Buyer(db_conn.CheckExist):
             return 530, "{}".format(str(e))
 
         return 200, "ok"
+
+    def received(self, user_id: str, order_id: str) -> (int, str):
+        try:
+            row = None
+            with self.get_session() as session:
+                row = session.query(NewOrder_model.order_id, NewOrder_model.user_id,
+                                    NewOrder_model.status).filter(NewOrder_model.order_id == order_id).all()
+
+                if len(row) != 1:
+                    return error.error_invalid_order_id(order_id)
+
+            row = row[0]
+            order_id = row.order_id
+            buyer_id = row.user_id
+            status = row.status
+
+            if user_id != buyer_id:
+                return error.error_authorization_fail()
+
+            # 只有状态为已发货的订单才能收货
+            if status == "已发货":
+                with self.get_session() as session:
+                    row = session.query(NewOrder_model).filter(NewOrder_model.order_id == order_id).all()
+                    if len(row) != 1:
+                        return error.error_invalid_order_id(order_id)
+                    row = row[0]
+                    row.status = "已收货"
+                    session.add(row)
+            else:
+                return error.error_status_not_allowed(order_id)
+
+        except SQLAlchemyError as e:
+            return 528, "{}".format(str(e))
+
+        except BaseException as e:
+            return 530, "{}".format(str(e))
+
+        return 200, "ok"
diff --git a/be/model/error.py b/be/model/error.py
index d0d9ea1..97c1b0a 100644
--- a/be/model/error.py
+++ b/be/model/error.py
@@ -10,7 +10,7 @@ error_code = {
     517: "stock level low, book id {}",
     518: "invalid order id {}",
     519: "not sufficient funds, order id {}",
-    520: "",
+    520: "status not allowed, order id {}",
     521: "",
     522: "non exist query result",
     523: "",
@@ -67,3 +67,7 @@ def error_and_message(code, message):
 
 def error_non_exist_search():
     return 522, error_code[522]
+
+def error_status_not_allowed(order_id):
+    return 520, error_code[520].format(order_id)
+
diff --git a/be/model/seller.py b/be/model/seller.py
index 1e7076c..69f3119 100644
--- a/be/model/seller.py
+++ b/be/model/seller.py
@@ -1,6 +1,6 @@
 from be.model import error
 from be.model import db_conn
-from be.model.orm_models import Store as Store_model,UserStore as UserStore_model
+from be.model.orm_models import Store as Store_model,UserStore as UserStore_model,NewOrder as NewOrder_model, NewOrderDetail as NewOrderDetail_model
 from sqlalchemy.exc import SQLAlchemyError
 from sqlalchemy import and_,or_
 
@@ -63,3 +63,42 @@ class Seller(db_conn.CheckExist):
         except BaseException as e:
             return 530, "{}".format(str(e))
         return 200, "ok"
+
+    def delivered(self, user_id: str, order_id: str) -> (int, str):
+        try:
+            row = None
+            with self.get_session() as session:
+                row = session.query(NewOrder_model.order_id,
+                                    NewOrder_model.store_id, NewOrder_model.status).filter(
+                    NewOrder_model.order_id == order_id).all()
+
+                if len(row) != 1:
+                    return error.error_invalid_order_id(order_id)
+
+            row = row[0]
+            store_id = row.store_id
+            status = row.status
+
+            # 判断订单的store_id是否是属于该user_id的
+            seller = session.query(UserStore_model.user_id).filter(UserStore_model.store_id == store_id).all()
+            seller_id = seller[0].user_id
+            if user_id != seller_id:
+                return error.error_authorization_fail()
+
+            # 检查订单状态为已支付，其他状态不允许收货
+            if status == "已支付":
+                with self.get_session() as session:
+                    row = session.query(NewOrder_model).filter(NewOrder_model.order_id == order_id).all()
+                    if len(row) != 1:
+                        return error.error_invalid_order_id(order_id)
+                    row = row[0]
+                    row.status = "已发货"
+                    session.add(row)
+            else:
+                return error.error_status_not_allowed(order_id)
+
+        except SQLAlchemyError as e:
+            return 528, "{}".format(str(e))
+        except BaseException as e:
+            return 530, "{}".format(str(e))
+        return 200, "ok"
\ No newline at end of file
diff --git a/be/view/buyer.py b/be/view/buyer.py
index 799b4dd..674ceb0 100644
--- a/be/view/buyer.py
+++ b/be/view/buyer.py
@@ -40,3 +40,11 @@ def add_funds():
     b = Buyer()
     code, message = b.add_funds(user_id, password, add_value)
     return jsonify({"message": message}), code
+
+@bp_buyer.route("/received", methods=["POST"])
+def received():
+    user_id: str = request.json.get("user_id")
+    order_id: str = request.json.get("order_id")
+    b = Buyer()
+    code, message = b.received(user_id, order_id)
+    return jsonify({"message": message}), code
diff --git a/be/view/seller.py b/be/view/seller.py
index f8a9092..5cdb86f 100644
--- a/be/view/seller.py
+++ b/be/view/seller.py
@@ -40,3 +40,13 @@ def add_stock_level():
     code, message = s.add_stock_level(user_id, store_id, book_id, add_num)
 
     return jsonify({"message": message}), code
+
+@bp_seller.route("/delivered", methods=["POST"])
+def delivered():
+    user_id: str = request.json.get("user_id")
+    order_id: str = request.json.get("order_id")
+
+    s = seller.Seller()
+    code, message = s.delivered(user_id, order_id)
+
+    return jsonify({"message": message}), code
diff --git a/data/bookstore.db b/data/bookstore.db
deleted file mode 100644
index 13d60d1..0000000
Binary files a/data/bookstore.db and /dev/null differ
diff --git a/fe/access/buyer.py b/fe/access/buyer.py
index 2f9eaca..b42da34 100644
--- a/fe/access/buyer.py
+++ b/fe/access/buyer.py
@@ -40,3 +40,10 @@ class Buyer:
         headers = {"token": self.token}
         r = requests.post(url, headers=headers, json=json)
         return r.status_code
+
+    def received(self, order_id: str) -> int:
+        json = {"user_id": self.user_id, "order_id": order_id}
+        url = urljoin(self.url_prefix, "received")
+        headers = {"token": self.token}
+        r = requests.post(url, headers=headers, json=json)
+        return r.status_code
diff --git a/fe/access/seller.py b/fe/access/seller.py
index 6e20ae8..6527c8f 100644
--- a/fe/access/seller.py
+++ b/fe/access/seller.py
@@ -50,3 +50,14 @@ class Seller:
         headers = {"token": self.token}
         r = requests.post(url, headers=headers, json=json)
         return r.status_code
+
+    def delivered(self, order_id: str) -> int:
+        json = {
+            "user_id": self.seller_id,
+            "order_id": order_id,
+        }
+        url = urljoin(self.url_prefix, "delivered")
+        headers = {"token": self.token}
+        r = requests.post(url, headers=headers, json=json)
+        return r.status_code
+
diff --git a/fe/test/test_deliver.py b/fe/test/test_deliver.py
new file mode 100644
index 0000000..d7cf8cf
--- /dev/null
+++ b/fe/test/test_deliver.py
@@ -0,0 +1,54 @@
+import pytest
+
+from fe.access.book import Book
+from fe.test.gen_book_data import GenBook
+from fe.access.new_buyer import register_new_buyer
+import uuid
+
+class TestDeliver:
+
+    @pytest.fixture(autouse=True)
+    def pre_run_initialization(self):
+        self.seller_id = "test_new_order_seller_id_{}".format(str(uuid.uuid1()))
+        self.store_id = "test_new_order_store_id_{}".format(str(uuid.uuid1()))
+        self.buyer_id = "test_new_order_buyer_id_{}".format(str(uuid.uuid1()))
+        self.password = self.seller_id
+
+        gen_book = GenBook(self.seller_id, self.store_id)
+        ok, buy_book_id_list = gen_book.gen(non_exist_book_id=False, low_stock_level=False, max_book_count=5)
+        self.buy_book_info_list = gen_book.buy_book_info_list
+        assert ok
+        b = register_new_buyer(self.buyer_id, self.password)
+        self.buyer = b
+        code, self.order_id = b.new_order(self.store_id, buy_book_id_list)
+        assert code == 200
+
+        self.total_price = 0
+        for item in self.buy_book_info_list:
+            book: Book = item[0]
+            num = item[1]
+            if book.price is None:
+                continue
+            else:
+                self.total_price = self.total_price + book.price * num
+
+        self.seller = gen_book.seller
+
+        yield
+
+    def test_error_deliver_error(self):
+        code = self.seller.delivered(self.order_id)
+        assert code != 200
+
+    def test_ok(self):
+        code = self.buyer.add_funds(self.total_price+100000)
+        assert code == 200
+        # 订单状态为已支付
+        code = self.buyer.payment(self.order_id)
+        assert code == 200
+        code = self.seller.delivered(self.order_id)
+        assert code == 200
+
+    def test_error_repeat_deliver(self):
+        code = self.seller.delivered(self.order_id)
+        assert code != 200
diff --git a/fe/test/test_receive.py b/fe/test/test_receive.py
new file mode 100644
index 0000000..0c802ab
--- /dev/null
+++ b/fe/test/test_receive.py
@@ -0,0 +1,72 @@
+import pytest
+
+from fe.access.book import Book
+from fe.test.gen_book_data import GenBook
+from fe.access.new_buyer import register_new_buyer
+import uuid
+
+class TestReceive:
+
+    @pytest.fixture(autouse=True)
+    def pre_run_initialization(self):
+        self.seller_id = "test_new_order_seller_id_{}".format(str(uuid.uuid1()))
+        self.store_id = "test_new_order_store_id_{}".format(str(uuid.uuid1()))
+        self.buyer_id = "test_new_order_buyer_id_{}".format(str(uuid.uuid1()))
+        self.password = self.seller_id
+
+        gen_book = GenBook(self.seller_id, self.store_id)
+        ok, buy_book_id_list = gen_book.gen(non_exist_book_id=False, low_stock_level=False, max_book_count=5)
+        self.buy_book_info_list = gen_book.buy_book_info_list
+        assert ok
+        b = register_new_buyer(self.buyer_id, self.password)
+        self.buyer = b
+        code, self.order_id = b.new_order(self.store_id, buy_book_id_list)
+        assert code == 200
+
+        self.total_price = 0
+        for item in self.buy_book_info_list:
+            book: Book = item[0]
+            num = item[1]
+            if book.price is None:
+                continue
+            else:
+                self.total_price = self.total_price + book.price * num
+
+        self.seller = gen_book.seller
+        code = self.buyer.add_funds(self.total_price)
+        assert code == 200
+
+        yield
+
+    def test_error_status_unpaid(self):
+        code = self.buyer.received(self.order_id)
+        assert code != 200
+
+    def test_error_status_undelivered(self):
+        code = self.buyer.payment(self.order_id)
+        assert code == 200
+        code = self.buyer.received(self.order_id)
+        assert code != 200
+
+    def test_ok(self):
+        code = self.buyer.payment(self.order_id)
+        assert code == 200
+        code = self.seller.delivered(self.order_id)
+        assert code == 200
+        code = self.buyer.received(self.order_id)
+        assert code == 200
+
+    def test_error_no_order(self):
+        code = self.buyer.received(self.order_id + '_x')
+        assert code != 200
+
+    def test_error_repeat_receive(self):
+        code = self.buyer.payment(self.order_id)
+        assert code == 200
+        code = self.seller.delivered(self.order_id)
+        assert code == 200
+        code = self.buyer.received(self.order_id)
+        assert code == 200
+        code = self.buyer.received(self.order_id)
+        assert code != 200
+
diff --git a/markdown/yq.md b/markdown/xq.md
similarity index 100%
rename from markdown/yq.md
rename to markdown/xq.md

commit f8dd52e8d80021b8d2e86037765fb2258d6d84c1
Author: Li Sihan <10205501407@stu.ecnu.edu.cn>
Date:   Tue Dec 6 20:08:13 2022 +0800

    500

diff --git a/be/model/db_conn.py b/be/model/db_conn.py
index f160f72..8b63039 100644
--- a/be/model/db_conn.py
+++ b/be/model/db_conn.py
@@ -14,7 +14,7 @@ class CheckExist:
         with self.get_session() as session:
             row = session.query(User_model.password).filter(User_model.user_id==user_id).all()
 
-            print()
+
             if len(row) == 0:
                 return False
             else:
diff --git a/be/model/searcher.py b/be/model/searcher.py
index aec9d43..6624f31 100644
--- a/be/model/searcher.py
+++ b/be/model/searcher.py
@@ -12,24 +12,27 @@ class Searcher(db_conn.CheckExist):
     def search(self, user_id: str, store_id: str, keyword: str):
         try:
             # 全站搜索
-            if store_id == None:
+            if store_id == '':
+                print("222")
+                print(self.user_id_exist(user_id))
                 if not self.user_id_exist(user_id):
                     return error.error_non_exist_user_id(user_id)
-
+                print("333")
                 with self.get_session() as session:
+                    print("1111")
                     row = session.query(book_model.title, book_model.author, book_model.publisher,
                                         book_model.translator,
                                         book_model.pub_year, book_model.pages, book_model.price,
                                         book_model.author_intro,
                                         book_model.book_intro, book_model.tags, book_model.picture) \
                         .join(Store_model, Store_model.book_id == book_model.id) \
-                        .filter(Store_model.stock_level > 0, or_(
-                        (book_model.title__icontains, keyword), (book_model.author__icontains, keyword),
-                        (book_model.tags__icontains, keyword),
-                        (book_model.book_intro__icontains, keyword), (book_model.content__icontains, keyword)
-                    )).all()
+                        .filter(and_(Store_model.stock_level > 0, or_(
+                        book_model.title.like("%" + keyword + "%"), book_model.author.like("%" + keyword + "%"),
+                        book_model.tags.like("%" + keyword + "%"), book_model.book_intro.like("%" + keyword + "%"),
+                        book_model.content.like("%" + keyword + "%")
+                    ))).all()
 
-                    if row == None:
+                    if len(row) == 0:
                         return error.error_non_exist_search()
                     else:
                         pagenum = len(row) // 5
@@ -57,13 +60,13 @@ class Searcher(db_conn.CheckExist):
                                         book_model.author_intro,
                                         book_model.book_intro, book_model.tags, book_model.picture) \
                         .join(Store_model, Store_model.book_id == book_model.id) \
-                        .filter(Store_model.store_id == store_id, Store_model.stock_level > 0, or_(
-                        (book_model.title__icontains, keyword), (book_model.author__icontains, keyword),
-                        (book_model.tags__icontains, keyword),
-                        (book_model.book_intro__icontains, keyword), (book_model.content__icontains, keyword)
-                    )).all()
+                        .filter(and_(Store_model.store_id == store_id, Store_model.stock_level > 0, or_(
+                        book_model.title.like("%" + keyword + "%"), book_model.author.like("%" + keyword + "%"),
+                        book_model.tags.like("%" + keyword + "%"), book_model.book_intro.like("%" + keyword + "%"),
+                        book_model.content.like("%" + keyword + "%")
+                    ))).all()
 
-                    if row == None:
+                    if len(row) == 0:
                         return error.error_non_exist_search()
                     else:
                         pagenum = len(row) // 5
diff --git a/be/view/searcher.py b/be/view/searcher.py
index 508128c..8ce22d8 100644
--- a/be/view/searcher.py
+++ b/be/view/searcher.py
@@ -2,19 +2,20 @@ from flask import Blueprint
 from flask import request
 from flask import jsonify
 from be.model.searcher import Searcher
+import json
 
 bp_searcher = Blueprint("searcher", __name__, url_prefix="/searcher")
 
 
 @bp_searcher.route("/search", methods=["POST"])
 def search():
-    print("333333333333")
+    print("333333333")
     user_id: str = request.json.get("user_id")
     store_id: str = request.json.get("store_id")
     keyword: str = request.json.get("keyword")
     se = Searcher()
     code, pagenum, row, show = se.search(user_id, store_id, keyword)
-    return jsonify({"pagenum": pagenum, "row": row, "show": show}), code
+    return jsonify({"pagenum": pagenum, "row": row, "show": show}), code, "success"
 
 
 @bp_searcher.route("/show_pages", methods=["POST"])
diff --git a/fe/access/searcher.py b/fe/access/searcher.py
index e53a33a..705a68e 100644
--- a/fe/access/searcher.py
+++ b/fe/access/searcher.py
@@ -1,7 +1,7 @@
 import requests
 from urllib.parse import urljoin
 from fe.access.auth import Auth
-#import simplejson
+import json
 
 
 class Searcher:
@@ -20,15 +20,11 @@ class Searcher:
             "store_id": store_id,
             "keyword": keyword
         }
-        #print(simplejson.dumps(json))
         url = urljoin(self.url_prefix, "search")
-
         headers = {"token": self.token}
         print(url)
-        try:
-            r = requests.post(url, headers=headers, json=json)
-        except:
-            raise
+        r = requests.post(url, headers=headers, json=json)
+
         # response_json = r.json()
         # return r.status_code, response_json.get("pagenum"), response_json.get("row"), response_json.get("show")
         return r.status_code

commit 8ea797c1c51abedbc76829f446560daaf3c2835f
Author: dirtyDan0 <ray3218@outlook.com>
Date:   Mon Dec 5 18:50:38 2022 +0800

    deleted unneeded import

diff --git a/be/model/store.py b/be/model/store.py
index db90b78..cec7d98 100644
--- a/be/model/store.py
+++ b/be/model/store.py
@@ -7,7 +7,7 @@ from be.model.orm_models import createTable
 from sqlalchemy import create_engine
 from sqlalchemy.orm import sessionmaker,scoped_session
 from contextlib import contextmanager
-import psycopg2
+#import psycopg2
 
 
 class Store:
diff --git a/fe/access/book.py b/fe/access/book.py
index 32c871c..6b1a248 100644
--- a/fe/access/book.py
+++ b/fe/access/book.py
@@ -1,7 +1,7 @@
 import os
 import random
 import base64
-import simplejson as json
+#import simplejson as json
 from be.model import db_conn
 from be.model.orm_models import Book as Book_model
 from sqlalchemy import func
diff --git a/fe/access/buyer.py b/fe/access/buyer.py
index 507c62a..2f9eaca 100644
--- a/fe/access/buyer.py
+++ b/fe/access/buyer.py
@@ -1,5 +1,5 @@
 import requests
-import simplejson
+#import simplejson
 from urllib.parse import urljoin
 from fe.access.auth import Auth
 
diff --git a/fe/access/searcher.py b/fe/access/searcher.py
index bc62ad7..e53a33a 100644
--- a/fe/access/searcher.py
+++ b/fe/access/searcher.py
@@ -1,7 +1,7 @@
 import requests
 from urllib.parse import urljoin
 from fe.access.auth import Auth
-import simplejson
+#import simplejson
 
 
 class Searcher:

commit b0cb0caaf723b0bf93331971dcd38a5dc127b4bb
Author: Li Sihan <10205501407@stu.ecnu.edu.cn>
Date:   Mon Dec 5 15:35:25 2022 +0800

    bug

diff --git a/be/model/error.py b/be/model/error.py
index d78ab55..d0d9ea1 100644
--- a/be/model/error.py
+++ b/be/model/error.py
@@ -12,7 +12,7 @@ error_code = {
     519: "not sufficient funds, order id {}",
     520: "",
     521: "",
-    522: "",
+    522: "non exist query result",
     523: "",
     524: "",
     525: "",
@@ -64,3 +64,6 @@ def error_authorization_fail():
 
 def error_and_message(code, message):
     return code, message
+
+def error_non_exist_search():
+    return 522, error_code[522]
diff --git a/be/model/orm_models.py b/be/model/orm_models.py
index 8a6f6fb..80a2aad 100644
--- a/be/model/orm_models.py
+++ b/be/model/orm_models.py
@@ -1,8 +1,13 @@
-from sqlalchemy import Column, Integer, Text, LargeBinary, DateTime
+from sqlalchemy import text, Index, Column, Integer, Text, LargeBinary, DateTime
 from sqlalchemy.orm import declarative_base
+from sqlalchemy.sql import func
 
 Base = declarative_base()
-
+"""
+def to_tsvector_ix(*columns):
+    s = " || ' ' || ".join(columns)
+    return func.to_tsvector('english', text(s))
+"""
 class Book(Base):
     __tablename__ = 'bookstore_book'
 
@@ -23,8 +28,15 @@ class Book(Base):
     content = Column(Text)
     tags = Column(Text)
     picture = Column(LargeBinary)
-
-
+"""
+    __table_args__ = (
+        Index(
+            'ix_book_tsv',
+            to_tsvector_ix('title', 'author', 'tags', 'book_intro', 'content'),
+            postgresql_using='gin'
+        ),
+    )
+"""
 class NewOrder(Base):
     __tablename__ = 'bookstore_new_order'
 
diff --git a/be/model/searcher.py b/be/model/searcher.py
new file mode 100644
index 0000000..aec9d43
--- /dev/null
+++ b/be/model/searcher.py
@@ -0,0 +1,105 @@
+from be.model import error
+from be.model import db_conn
+from be.model.orm_models import Store as Store_model
+from be.model.orm_models import Book as book_model
+from sqlalchemy.exc import SQLAlchemyError
+from sqlalchemy import and_, or_
+
+
+class Searcher(db_conn.CheckExist):
+
+    # 题目，作者，标签，简介，目录(title, author, tags, book_intro, content)
+    def search(self, user_id: str, store_id: str, keyword: str):
+        try:
+            # 全站搜索
+            if store_id == None:
+                if not self.user_id_exist(user_id):
+                    return error.error_non_exist_user_id(user_id)
+
+                with self.get_session() as session:
+                    row = session.query(book_model.title, book_model.author, book_model.publisher,
+                                        book_model.translator,
+                                        book_model.pub_year, book_model.pages, book_model.price,
+                                        book_model.author_intro,
+                                        book_model.book_intro, book_model.tags, book_model.picture) \
+                        .join(Store_model, Store_model.book_id == book_model.id) \
+                        .filter(Store_model.stock_level > 0, or_(
+                        (book_model.title__icontains, keyword), (book_model.author__icontains, keyword),
+                        (book_model.tags__icontains, keyword),
+                        (book_model.book_intro__icontains, keyword), (book_model.content__icontains, keyword)
+                    )).all()
+
+                    if row == None:
+                        return error.error_non_exist_search()
+                    else:
+                        pagenum = len(row) // 5
+                        if pagenum == 0:
+                            show = row
+                        else:
+                            page = len(row) % 5
+                            if page == 0:
+                                pagenum = pagenum
+                            else:
+                                pagenum += 1
+                            show = row.limit(5)
+                        # return 200, "ok", pagenum, row, show
+            # 店铺搜索
+            else:
+                if not self.user_id_exist(user_id):
+                    return error.error_non_exist_user_id(user_id)
+                if not self.store_id_exist(store_id):
+                    return error.error_non_exist_store_id(store_id)
+
+                with self.get_session() as session:
+                    row = session.query(book_model.title, book_model.author, book_model.publisher,
+                                        book_model.translator,
+                                        book_model.pub_year, book_model.pages, book_model.price,
+                                        book_model.author_intro,
+                                        book_model.book_intro, book_model.tags, book_model.picture) \
+                        .join(Store_model, Store_model.book_id == book_model.id) \
+                        .filter(Store_model.store_id == store_id, Store_model.stock_level > 0, or_(
+                        (book_model.title__icontains, keyword), (book_model.author__icontains, keyword),
+                        (book_model.tags__icontains, keyword),
+                        (book_model.book_intro__icontains, keyword), (book_model.content__icontains, keyword)
+                    )).all()
+
+                    if row == None:
+                        return error.error_non_exist_search()
+                    else:
+                        pagenum = len(row) // 5
+                        if pagenum == 0:
+                            show = row
+                        else:
+                            page = len(row) % 5
+                            if page == 0:
+                                pagenum = pagenum
+                            else:
+                                pagenum += 1
+                            show = row.limit(5)
+                        #print(pagenum, row, show)
+                        # return 200, "ok", pagenum, row, show
+
+        except SQLAlchemyError as e:
+            return 528, "{}".format(str(e))
+        except BaseException as e:
+            return 530, "{}".format(str(e))
+        return 200, "ok", pagenum, row, show
+
+    def show_pages(self, user_id, page, content):
+        try:
+            if not self.user_id_exist(user_id):
+                return error.error_non_exist_user_id(user_id)
+
+            off = page * 5
+            remain = content - off
+            if remain > 5:
+                show = content.offset(off).limit(5)
+            else:
+                show = content.offset(off)
+            # return 200, "ok", show, content
+
+        except SQLAlchemyError as e:
+            return 528, "{}".format(str(e))
+        except BaseException as e:
+            return 530, "{}".format(str(e))
+        return 200, "ok", show, content
diff --git a/be/serve.py b/be/serve.py
index bace2fc..3eb2325 100644
--- a/be/serve.py
+++ b/be/serve.py
@@ -6,6 +6,7 @@ from flask import request
 from be.view import auth
 from be.view import seller
 from be.view import buyer
+from be.view import searcher
 from be.model.store import init_database
 
 bp_shutdown = Blueprint("shutdown", __name__)
@@ -43,4 +44,5 @@ def be_run():
     app.register_blueprint(auth.bp_auth)
     app.register_blueprint(seller.bp_seller)
     app.register_blueprint(buyer.bp_buyer)
+    app.register_blueprint(searcher.bp_searcher)
     app.run()
diff --git a/be/view/searcher.py b/be/view/searcher.py
new file mode 100644
index 0000000..508128c
--- /dev/null
+++ b/be/view/searcher.py
@@ -0,0 +1,28 @@
+from flask import Blueprint
+from flask import request
+from flask import jsonify
+from be.model.searcher import Searcher
+
+bp_searcher = Blueprint("searcher", __name__, url_prefix="/searcher")
+
+
+@bp_searcher.route("/search", methods=["POST"])
+def search():
+    print("333333333333")
+    user_id: str = request.json.get("user_id")
+    store_id: str = request.json.get("store_id")
+    keyword: str = request.json.get("keyword")
+    se = Searcher()
+    code, pagenum, row, show = se.search(user_id, store_id, keyword)
+    return jsonify({"pagenum": pagenum, "row": row, "show": show}), code
+
+
+@bp_searcher.route("/show_pages", methods=["POST"])
+def show_pages():
+    user_id: str = request.json.get("user_id")
+    page: int = request.json.get("page")
+    content: str = request.json.get("content")
+
+    se = Searcher()
+    code, show, content1 = se.show_pages(user_id, page, content)
+    return jsonify({"show": show, "content": content1}), code
diff --git a/fe/access/new_searcher.py b/fe/access/new_searcher.py
new file mode 100644
index 0000000..05ec9aa
--- /dev/null
+++ b/fe/access/new_searcher.py
@@ -0,0 +1,9 @@
+from fe import conf
+from fe.access import searcher, auth
+
+def register_new_searcher(user_id, password) -> searcher.Searcher:
+    a = auth.Auth(conf.URL)
+    code = a.register(user_id, password)
+    assert code == 200
+    s = searcher.Searcher(conf.URL, user_id, password)
+    return s
\ No newline at end of file
diff --git a/fe/access/searcher.py b/fe/access/searcher.py
new file mode 100644
index 0000000..bc62ad7
--- /dev/null
+++ b/fe/access/searcher.py
@@ -0,0 +1,46 @@
+import requests
+from urllib.parse import urljoin
+from fe.access.auth import Auth
+import simplejson
+
+
+class Searcher:
+    def __init__(self, url_prefix, user_id, password):
+        self.url_prefix = urljoin(url_prefix, "searcher/")
+        self.user_id = user_id
+        self.password = password
+        self.terminal = "my terminal"
+        self.auth = Auth(url_prefix)
+        code, self.token = self.auth.login(self.user_id, self.password, self.terminal)
+        assert code == 200
+
+    def search(self, store_id: str, keyword: str):
+        json = {
+            "user_id": self.user_id,
+            "store_id": store_id,
+            "keyword": keyword
+        }
+        #print(simplejson.dumps(json))
+        url = urljoin(self.url_prefix, "search")
+
+        headers = {"token": self.token}
+        print(url)
+        try:
+            r = requests.post(url, headers=headers, json=json)
+        except:
+            raise
+        # response_json = r.json()
+        # return r.status_code, response_json.get("pagenum"), response_json.get("row"), response_json.get("show")
+        return r.status_code
+
+    def show_pages(self, page, content):
+        json = {
+            "user_id": self.user_id,
+            "page": int(page),
+            "content": content
+        }
+        url = urljoin(self.url_prefix, "show_pages")
+        headers = {"token": self.token}
+        r = requests.post(url, headers=headers, json=json)
+        response_json = r.json()
+        return r.status_code, response_json.get("pagenum"), response_json.get("row"), response_json.get("show")
diff --git a/fe/test/add_store_book.py b/fe/test/add_store_book.py
new file mode 100644
index 0000000..ec79899
--- /dev/null
+++ b/fe/test/add_store_book.py
@@ -0,0 +1,54 @@
+import random
+from fe.access import book
+from fe.access.new_seller import register_new_seller
+import uuid
+
+class AddStoreBook:
+    def __init_store_list__(self):
+        self.store_id_list = []
+
+    def __init__(self, store_id):
+        self.__init_store_list__()
+        self.user_id = "test_seller_id_{}".format(str(uuid.uuid1()))
+        self.password = self.user_id
+        self.seller = register_new_seller(self.user_id, self.password)
+        if store_id != None:
+            self.store_id = store_id
+            code = self.seller.create_store(store_id)
+            assert code == 200
+        else:
+            self.store_id_num = random.randint(5, 20)
+            for i in range(self.store_id_num):
+                self.store_id_list.append(str(uuid.uuid1()))
+                code = self.seller.create_store(self.store_id_list[i])
+                assert code == 200
+
+    def add(self, max_book_count: int = 100):
+        ok = True
+        book_db = book.BookDB()
+        rows = book_db.get_book_count()
+
+        if  self.store_id_list == []:
+            start = 0
+            if rows > max_book_count:
+                start = random.randint(0, rows - max_book_count)
+            size = random.randint(1, max_book_count)
+            books = book_db.get_book_info(start, size)
+            for bk in books:
+                stock_level = random.randint(0, 100)
+                code = self.seller.add_book(self.store_id, stock_level, bk)
+                assert code == 200
+        else:
+            for i in range(self.store_id_num):
+                start = 0
+                if rows > max_book_count:
+                    start = random.randint(0, rows - max_book_count)
+                size = random.randint(1, max_book_count)
+                books = book_db.get_book_info(start, size)
+                for bk in books:
+                    stock_level = random.randint(0, 100)
+                    code = self.seller.add_book(self.store_id[i], stock_level, bk)
+                    assert code == 200
+
+        return ok
+
diff --git a/fe/test/test_search.py b/fe/test/test_search.py
new file mode 100644
index 0000000..daefe95
--- /dev/null
+++ b/fe/test/test_search.py
@@ -0,0 +1,65 @@
+import pytest
+
+from fe.access.new_searcher import register_new_searcher
+from fe.test.add_store_book import AddStoreBook
+import uuid
+import random
+
+class TestSearch:
+    @pytest.fixture(autouse=True)
+    def pre_run_initialization(self):
+        # do before test
+        self.searcher_id = "test_search_searcher_id_{}".format(str(uuid.uuid1()))
+        self.password = self.searcher_id
+        self.searcher = register_new_searcher(self.searcher_id, self.password)
+
+        self.store_id1 = "test_search_store_id_{}".format(str(uuid.uuid1())) #店铺内
+        self.store_id0 = None #全站
+        self.add1 = AddStoreBook(self.store_id1) #店铺内
+        self.add0 = AddStoreBook(self.store_id0) #全站
+
+        self.keyword = '人'
+        self.page = 0
+
+        yield
+
+    def test_store_ok(self):
+        ok = self.add1
+        assert ok
+        #code1,pagenum,row,_ = self.searcher.search(self.store_id1, self.keyword)
+        code1 = self.searcher.search(store_id=self.store_id1, keyword=self.keyword)
+        assert code1 == 200
+        """
+        if pagenum != 0:
+            self.page = random.randint(0,pagenum)
+            code2,_,_,_ = self.searcher.show_pages(self.page, row)
+            assert code2 == 200
+        """
+    def test_all_ok(self):
+        ok = self.add0
+        assert ok
+        code1, pagenum, row, _ = self.searcher.search(self.store_id0, self.keyword)
+        assert code1 == 200
+        if pagenum != 0:
+            self.page = random.randint(0, pagenum)
+            code2, _, _, _ = self.searcher.show_pages(self.page, row)
+            assert code2 == 200
+
+    def test_error_non_exist_search(self):
+        ok = self.add0
+        assert ok
+        code,_,_,_ = self.searcher.search(self.store_id1, self.keyword+"xx")
+        assert code == 200
+
+    def test_non_exist_user_id(self):
+        ok = self.add0
+        assert ok
+        self.searcher.user_id = self.searcher.user_id + "_x"
+        code, _, _, _ = self.searcher.search(self.store_id1, self.keyword)
+        assert code == 200
+
+    def test_non_exist_store_id(self):
+        ok = self.add0
+        assert ok
+        code,_,_,_ = self.searcher.search(self.store_id1+"x", self.keyword)
+        assert code != 200
\ No newline at end of file

commit 144ec9cdbe46a0eb62ba90228c3ad4147ecf9e1c
Author: dirtyDan0 <ray3218@outlook.com>
Date:   Thu Dec 1 19:23:07 2022 +0800

    防脏数据

diff --git a/be/model/buyer.py b/be/model/buyer.py
index eab24ff..2bac445 100644
--- a/be/model/buyer.py
+++ b/be/model/buyer.py
@@ -20,37 +20,35 @@ class Buyer(db_conn.CheckExist):
                 return error.error_non_exist_store_id(store_id) + (order_id, )
             uid = "{}_{}_{}".format(user_id, store_id, str(uuid.uuid1()))
 
-            for book_id, count in id_and_count:
+            #new_order 和 new_order_detail 应该在一个session内，这样出错了就能一起rollback
+            with self.get_session() as session:
 
-                row = None
-                with self.get_session() as session:
-                    
+                for book_id, count in id_and_count:                    
+                        
                     row = session.query(Store_model.book_id,
-                                        Store_model.stock_level,
-                                        Store_model.book_info
-                                    ).filter(and_(Store_model.store_id == store_id, Store_model.book_id == book_id)).all()
+                                            Store_model.stock_level,
+                                            Store_model.book_info
+                                        ).filter(and_(Store_model.store_id == store_id, Store_model.book_id == book_id)).all()
 
                     if len(row) != 1 :
                         return error.error_non_exist_book_id(book_id) + (order_id, )
-                    
-                row = row[0]
-
-                stock_level = row.stock_level
-                book_info = row.book_info
-                book_info_json = json.loads(book_info)
-                price = book_info_json.get("price")
+                        
+                    row = row[0]
 
-                if stock_level < count:
-                    return error.error_stock_level_low(book_id) + (order_id,)
-                    
-                with self.get_session() as session:
+                    stock_level = row.stock_level
+                    book_info = row.book_info
+                    book_info_json = json.loads(book_info)
+                    price = book_info_json.get("price")
 
+                    if stock_level < count:
+                        return error.error_stock_level_low(book_id) + (order_id,)
+                        
                     row = session.query(Store_model).filter(and_(
                         Store_model.store_id==store_id,
                         Store_model.book_id==book_id,
                         Store_model.stock_level>=count)).all()
 
-                    
+                        
                     if len(row) != 1:
                         return error.error_stock_level_low(book_id) + (order_id, )
 
@@ -59,13 +57,11 @@ class Buyer(db_conn.CheckExist):
 
                     session.add(row)
 
-                with self.get_session() as session:
-
                     new_order_detail = NewOrderDetail_model(order_id=uid, book_id=book_id, count=count, price=price)
-                    
+                        
                     session.add(new_order_detail)
 
-            with self.get_session() as session:
+            
                 new_order = NewOrder_model(order_id = uid, store_id = store_id, user_id = user_id)
                 session.add(new_order)
                              
@@ -140,6 +136,7 @@ class Buyer(db_conn.CheckExist):
             if balance < total_price:
                 return error.error_not_sufficient_funds(order_id)
 
+            #卖家买家的余额变动、删除new_order(detail)必须在一个session里，这样可以出错了rollback
             with self.get_session() as session:
                 buyer = session.query(User_model).filter(and_(User_model.user_id==buyer_id,User_model.balance>=total_price)).all()
                 if len(buyer) !=1:
@@ -149,7 +146,6 @@ class Buyer(db_conn.CheckExist):
                 buyer.balance = buyer.balance-total_price
                 session.add(buyer)
 
-            with self.get_session() as session:
                 seller = session.query(User_model).filter(User_model.user_id == seller_id).all()
                 if len(seller) !=1:
                     return error.error_non_exist_user_id(seller_id)
@@ -158,13 +154,13 @@ class Buyer(db_conn.CheckExist):
                 seller.balance = seller.balance+total_price
                 session.add(seller)
             
-            with self.get_session() as session:
+            
                 new_order = session.query(NewOrder_model).filter(NewOrder_model.order_id==order_id).all()
                 if len(new_order) !=1:
                     return error.error_invalid_order_id(order_id)
                 session.query(NewOrder_model).filter(NewOrder_model.order_id==order_id).delete()
 
-            with self.get_session() as session:
+            
                 new_order = session.query(NewOrderDetail_model).filter(NewOrderDetail_model.order_id==order_id).all()
                 if len(new_order) ==0:
                     return error.error_invalid_order_id(order_id)
@@ -183,16 +179,14 @@ class Buyer(db_conn.CheckExist):
         try:
             row = None
             with self.get_session() as session:
-                row = session.query(User_model.password).filter(User_model.user_id == user_id).all()
+                row = session.query(User_model).filter(User_model.user_id == user_id).all()
                 
-            if len(row) != 1:
-                return error.error_authorization_fail()
-            row = row[0]
-            if row.password != password:
-                return error.error_authorization_fail()
+                if len(row) ==0:
+                    return error.error_authorization_fail()
+                user = row[0]
+                if user.password != password:
+                    return error.error_authorization_fail()
 
-            with self.get_session() as session:
-                row = session.query(User_model).filter(User_model.user_id == user_id).all()
                 
                 if len(row) != 1:
                     return error.error_non_exist_user_id(user_id) 

commit 8e6cb74714dc6ce714bc165bf574023d6722e14d
Author: dirtyDan0 <ray3218@outlook.com>
Date:   Thu Dec 1 16:50:10 2022 +0800

    60% finish!

diff --git a/.gitignore b/.gitignore
index 4f0062a..d1a6b0e 100644
--- a/.gitignore
+++ b/.gitignore
@@ -6,4 +6,5 @@
 htmlcov
 *.pyc
 __pycache__/
-not_upload/
\ No newline at end of file
+not_upload/
+bookstore.db
\ No newline at end of file
diff --git a/be/model/buyer.py b/be/model/buyer.py
index d50fbec..eab24ff 100644
--- a/be/model/buyer.py
+++ b/be/model/buyer.py
@@ -1,14 +1,15 @@
-import sqlite3 as sqlite
 import uuid
 import json
 import logging
 from be.model import db_conn
 from be.model import error
+from be.model.orm_models import Store as Store_model, NewOrderDetail as NewOrderDetail_model, NewOrder as NewOrder_model,User as User_model
+from be.model.orm_models import UserStore as UserStore_model
+from sqlalchemy.exc import SQLAlchemyError
+from sqlalchemy import and_,or_
 
 
-class Buyer(db_conn.DBConn):
-    def __init__(self):
-        db_conn.DBConn.__init__(self)
+class Buyer(db_conn.CheckExist):
 
     def new_order(self, user_id: str, store_id: str, id_and_count: [(str, int)]) -> (int, str, str):
         order_id = ""
@@ -20,41 +21,57 @@ class Buyer(db_conn.DBConn):
             uid = "{}_{}_{}".format(user_id, store_id, str(uuid.uuid1()))
 
             for book_id, count in id_and_count:
-                cursor = self.conn.execute(
-                    "SELECT book_id, stock_level, book_info FROM store "
-                    "WHERE store_id = ? AND book_id = ?;",
-                    (store_id, book_id))
-                row = cursor.fetchone()
-                if row is None:
-                    return error.error_non_exist_book_id(book_id) + (order_id, )
-
-                stock_level = row[1]
-                book_info = row[2]
+
+                row = None
+                with self.get_session() as session:
+                    
+                    row = session.query(Store_model.book_id,
+                                        Store_model.stock_level,
+                                        Store_model.book_info
+                                    ).filter(and_(Store_model.store_id == store_id, Store_model.book_id == book_id)).all()
+
+                    if len(row) != 1 :
+                        return error.error_non_exist_book_id(book_id) + (order_id, )
+                    
+                row = row[0]
+
+                stock_level = row.stock_level
+                book_info = row.book_info
                 book_info_json = json.loads(book_info)
                 price = book_info_json.get("price")
 
                 if stock_level < count:
                     return error.error_stock_level_low(book_id) + (order_id,)
+                    
+                with self.get_session() as session:
+
+                    row = session.query(Store_model).filter(and_(
+                        Store_model.store_id==store_id,
+                        Store_model.book_id==book_id,
+                        Store_model.stock_level>=count)).all()
+
+                    
+                    if len(row) != 1:
+                        return error.error_stock_level_low(book_id) + (order_id, )
+
+                    row = row[0]
+                    row.stock_level = row.stock_level - count
+
+                    session.add(row)
+
+                with self.get_session() as session:
 
-                cursor = self.conn.execute(
-                    "UPDATE store set stock_level = stock_level - ? "
-                    "WHERE store_id = ? and book_id = ? and stock_level >= ?; ",
-                    (count, store_id, book_id, count))
-                if cursor.rowcount == 0:
-                    return error.error_stock_level_low(book_id) + (order_id, )
-
-                self.conn.execute(
-                        "INSERT INTO new_order_detail(order_id, book_id, count, price) "
-                        "VALUES(?, ?, ?, ?);",
-                        (uid, book_id, count, price))
-
-            self.conn.execute(
-                "INSERT INTO new_order(order_id, store_id, user_id) "
-                "VALUES(?, ?, ?);",
-                (uid, store_id, user_id))
-            self.conn.commit()
+                    new_order_detail = NewOrderDetail_model(order_id=uid, book_id=book_id, count=count, price=price)
+                    
+                    session.add(new_order_detail)
+
+            with self.get_session() as session:
+                new_order = NewOrder_model(order_id = uid, store_id = store_id, user_id = user_id)
+                session.add(new_order)
+                             
+                        
             order_id = uid
-        except sqlite.Error as e:
+        except SQLAlchemyError as e:
             logging.info("528, {}".format(str(e)))
             return 528, "{}".format(str(e)), ""
         except BaseException as e:
@@ -64,72 +81,97 @@ class Buyer(db_conn.DBConn):
         return 200, "ok", order_id
 
     def payment(self, user_id: str, password: str, order_id: str) -> (int, str):
-        conn = self.conn
-        try:
-            cursor = conn.execute("SELECT order_id, user_id, store_id FROM new_order WHERE order_id = ?", (order_id,))
-            row = cursor.fetchone()
-            if row is None:
-                return error.error_invalid_order_id(order_id)
-
-            order_id = row[0]
-            buyer_id = row[1]
-            store_id = row[2]
 
+        try:
+            row = None
+            with self.get_session() as session:
+                row = session.query(NewOrder_model.order_id,NewOrder_model.user_id,
+                NewOrder_model.store_id).filter(NewOrder_model.order_id==order_id).all()
+                
+                if len(row) != 1:
+                    return error.error_invalid_order_id(order_id)  
+                
+            row = row[0]
+            order_id = row.order_id
+            buyer_id = row.user_id
+            store_id = row.store_id
+            
             if buyer_id != user_id:
                 return error.error_authorization_fail()
+                
 
-            cursor = conn.execute("SELECT balance, password FROM user WHERE user_id = ?;", (buyer_id,))
-            row = cursor.fetchone()
-            if row is None:
-                return error.error_non_exist_user_id(buyer_id)
-            balance = row[0]
-            if password != row[1]:
-                return error.error_authorization_fail()
-
-            cursor = conn.execute("SELECT store_id, user_id FROM user_store WHERE store_id = ?;", (store_id,))
-            row = cursor.fetchone()
-            if row is None:
-                return error.error_non_exist_store_id(store_id)
+            with self.get_session() as session:
+                row = session.query(User_model.balance,User_model.password).filter(User_model.user_id == buyer_id).all()
+                if len(row) != 1:
+                    return error.error_non_exist_user_id(buyer_id)
+            
 
-            seller_id = row[1]
+            row = row[0]
+            balance = row.balance
+            
 
+            if password != row.password:
+                return error.error_authorization_fail()
+            
+            
+            with self.get_session() as session:
+                row = session.query(UserStore_model.store_id,UserStore_model.user_id).filter(UserStore_model.store_id==store_id).all()
+
+                if len(row) !=1:
+                    return error.error_non_exist_store_id(store_id)
+            
+            row = row[0]
+            seller_id = row.user_id
+            
             if not self.user_id_exist(seller_id):
                 return error.error_non_exist_user_id(seller_id)
 
-            cursor = conn.execute("SELECT book_id, count, price FROM new_order_detail WHERE order_id = ?;", (order_id,))
+            
+            rows = None
+            with self.get_session() as session:
+                rows = session.query(NewOrderDetail_model.book_id,NewOrderDetail_model.count,NewOrderDetail_model.price).filter(NewOrderDetail_model.order_id==order_id).all()
+
             total_price = 0
-            for row in cursor:
-                count = row[1]
-                price = row[2]
+            for row in rows:
+                count = row.count
+                price = row.price
                 total_price = total_price + price * count
 
             if balance < total_price:
                 return error.error_not_sufficient_funds(order_id)
 
-            cursor = conn.execute("UPDATE user set balance = balance - ?"
-                                  "WHERE user_id = ? AND balance >= ?",
-                                  (total_price, buyer_id, total_price))
-            if cursor.rowcount == 0:
-                return error.error_not_sufficient_funds(order_id)
-
-            cursor = conn.execute("UPDATE user set balance = balance + ?"
-                                  "WHERE user_id = ?",
-                                  (total_price, buyer_id))
-
-            if cursor.rowcount == 0:
-                return error.error_non_exist_user_id(buyer_id)
-
-            cursor = conn.execute("DELETE FROM new_order WHERE order_id = ?", (order_id, ))
-            if cursor.rowcount == 0:
-                return error.error_invalid_order_id(order_id)
-
-            cursor = conn.execute("DELETE FROM new_order_detail where order_id = ?", (order_id, ))
-            if cursor.rowcount == 0:
-                return error.error_invalid_order_id(order_id)
-
-            conn.commit()
-
-        except sqlite.Error as e:
+            with self.get_session() as session:
+                buyer = session.query(User_model).filter(and_(User_model.user_id==buyer_id,User_model.balance>=total_price)).all()
+                if len(buyer) !=1:
+                    return error.error_not_sufficient_funds(order_id)
+            
+                buyer = buyer[0]
+                buyer.balance = buyer.balance-total_price
+                session.add(buyer)
+
+            with self.get_session() as session:
+                seller = session.query(User_model).filter(User_model.user_id == seller_id).all()
+                if len(seller) !=1:
+                    return error.error_non_exist_user_id(seller_id)
+                
+                seller = seller[0]
+                seller.balance = seller.balance+total_price
+                session.add(seller)
+            
+            with self.get_session() as session:
+                new_order = session.query(NewOrder_model).filter(NewOrder_model.order_id==order_id).all()
+                if len(new_order) !=1:
+                    return error.error_invalid_order_id(order_id)
+                session.query(NewOrder_model).filter(NewOrder_model.order_id==order_id).delete()
+
+            with self.get_session() as session:
+                new_order = session.query(NewOrderDetail_model).filter(NewOrderDetail_model.order_id==order_id).all()
+                if len(new_order) ==0:
+                    return error.error_invalid_order_id(order_id)
+                session.query(NewOrderDetail_model).filter(NewOrderDetail_model.order_id==order_id).delete()
+            
+
+        except SQLAlchemyError as e:
             return 528, "{}".format(str(e))
 
         except BaseException as e:
@@ -139,22 +181,28 @@ class Buyer(db_conn.DBConn):
 
     def add_funds(self, user_id, password, add_value) -> (int, str):
         try:
-            cursor = self.conn.execute("SELECT password  from user where user_id=?", (user_id,))
-            row = cursor.fetchone()
-            if row is None:
+            row = None
+            with self.get_session() as session:
+                row = session.query(User_model.password).filter(User_model.user_id == user_id).all()
+                
+            if len(row) != 1:
                 return error.error_authorization_fail()
-
-            if row[0] != password:
+            row = row[0]
+            if row.password != password:
                 return error.error_authorization_fail()
 
-            cursor = self.conn.execute(
-                "UPDATE user SET balance = balance + ? WHERE user_id = ?",
-                (add_value, user_id))
-            if cursor.rowcount == 0:
-                return error.error_non_exist_user_id(user_id)
-
-            self.conn.commit()
-        except sqlite.Error as e:
+            with self.get_session() as session:
+                row = session.query(User_model).filter(User_model.user_id == user_id).all()
+                
+                if len(row) != 1:
+                    return error.error_non_exist_user_id(user_id) 
+                
+                row = row[0]
+                row.balance = row.balance + add_value
+                
+                session.add(row)
+
+        except SQLAlchemyError as e:
             return 528, "{}".format(str(e))
         except BaseException as e:
             return 530, "{}".format(str(e))
diff --git a/be/model/db_conn.py b/be/model/db_conn.py
index 3b0fbaf..f160f72 100644
--- a/be/model/db_conn.py
+++ b/be/model/db_conn.py
@@ -1,30 +1,43 @@
 from be.model import store
+from be.model.orm_models import User as User_model, Store as Store_model, UserStore as UserStore_model
+from sqlalchemy import and_,or_
 
+class CheckExist:
 
-class DBConn:
-    def __init__(self):
-        self.conn = store.get_db_conn()
 
+    def get_session(self):
+        return store.get_db_conn()
+
+    
     def user_id_exist(self, user_id):
-        cursor = self.conn.execute("SELECT user_id FROM user WHERE user_id = ?;", (user_id,))
-        row = cursor.fetchone()
-        if row is None:
-            return False
-        else:
-            return True
+
+        with self.get_session() as session:
+            row = session.query(User_model.password).filter(User_model.user_id==user_id).all()
+
+            print()
+            if len(row) == 0:
+                return False
+            else:
+                return True
+
 
     def book_id_exist(self, store_id, book_id):
-        cursor = self.conn.execute("SELECT book_id FROM store WHERE store_id = ? AND book_id = ?;", (store_id, book_id))
-        row = cursor.fetchone()
-        if row is None:
-            return False
-        else:
-            return True
+
+        with self.get_session() as session:
+            row = session.query(Store_model.book_id).filter(and_(Store_model.store_id==store_id ,Store_model.book_id==book_id)).all()
+
+            if len(row) == 0:
+                return False
+            else:
+                return True
+        
 
     def store_id_exist(self, store_id):
-        cursor = self.conn.execute("SELECT store_id FROM user_store WHERE store_id = ?;", (store_id,))
-        row = cursor.fetchone()
-        if row is None:
-            return False
-        else:
-            return True
+
+        with self.get_session() as session:
+            row = session.query(UserStore_model.store_id).filter(UserStore_model.store_id==store_id).all()
+
+            if len(row) == 0:
+                return False
+            else:
+                return True
diff --git a/be/model/orm_models.py b/be/model/orm_models.py
new file mode 100644
index 0000000..8a6f6fb
--- /dev/null
+++ b/be/model/orm_models.py
@@ -0,0 +1,76 @@
+from sqlalchemy import Column, Integer, Text, LargeBinary, DateTime
+from sqlalchemy.orm import declarative_base
+
+Base = declarative_base()
+
+class Book(Base):
+    __tablename__ = 'bookstore_book'
+
+    id = Column(Text, primary_key=True)
+    title = Column(Text)
+    author = Column(Text)
+    publisher = Column(Text)
+    original_title = Column(Text)
+    translator = Column(Text)
+    pub_year = Column(Text)
+    pages = Column(Integer)
+    price = Column(Integer)
+    currency_unit = Column(Text)
+    binding = Column(Text)
+    isbn = Column(Text)
+    author_intro = Column(Text)
+    book_intro = Column(Text)
+    content = Column(Text)
+    tags = Column(Text)
+    picture = Column(LargeBinary)
+
+
+class NewOrder(Base):
+    __tablename__ = 'bookstore_new_order'
+
+    order_id = Column(Text, primary_key=True)
+    user_id = Column(Text)
+    store_id = Column(Text)
+    status = Column(Text)
+    time = Column(DateTime)
+
+
+class NewOrderDetail(Base):
+    __tablename__ = 'bookstore_new_order_detail'
+
+    order_id = Column(Text, primary_key=True)
+    book_id = Column(Text, primary_key=True)
+    count = Column(Integer)
+    price = Column(Integer)
+
+
+class Store(Base):
+    __tablename__ = 'bookstore_store'
+
+    store_id = Column(Text, primary_key=True)
+    book_id = Column(Text, primary_key=True)
+    book_info = Column(Text)
+    stock_level = Column(Integer)
+
+
+class User(Base):
+    __tablename__ = 'bookstore_user'
+
+    password = Column(Text, nullable=False)
+    balance = Column(Integer, nullable=False)
+    user_id = Column(Text, primary_key=True)
+    token = Column(Text)
+    terminal = Column(Text)
+
+
+class UserStore(Base):
+    __tablename__ = 'bookstore_user_store'
+
+    user_id = Column(Text, primary_key=True)
+    store_id = Column(Text, primary_key=True)
+
+def createTable(engine):
+    Base.metadata.create_all(engine)
+
+
+
diff --git a/be/model/seller.py b/be/model/seller.py
index 2cf47aa..1e7076c 100644
--- a/be/model/seller.py
+++ b/be/model/seller.py
@@ -1,12 +1,10 @@
-import sqlite3 as sqlite
 from be.model import error
 from be.model import db_conn
+from be.model.orm_models import Store as Store_model,UserStore as UserStore_model
+from sqlalchemy.exc import SQLAlchemyError
+from sqlalchemy import and_,or_
 
-
-class Seller(db_conn.DBConn):
-
-    def __init__(self):
-        db_conn.DBConn.__init__(self)
+class Seller(db_conn.CheckExist):
 
     def add_book(self, user_id: str, store_id: str, book_id: str, book_json_str: str, stock_level: int):
         try:
@@ -17,10 +15,12 @@ class Seller(db_conn.DBConn):
             if self.book_id_exist(store_id, book_id):
                 return error.error_exist_book_id(book_id)
 
-            self.conn.execute("INSERT into store(store_id, book_id, book_info, stock_level)"
-                              "VALUES (?, ?, ?, ?)", (store_id, book_id, book_json_str, stock_level))
-            self.conn.commit()
-        except sqlite.Error as e:
+            with self.get_session() as session:
+
+                new_store = Store_model(store_id = store_id, book_id=book_id,book_info=book_json_str,stock_level=stock_level)
+                session.add(new_store)
+
+        except SQLAlchemyError as e:
             return 528, "{}".format(str(e))
         except BaseException as e:
             return 530, "{}".format(str(e))
@@ -35,10 +35,13 @@ class Seller(db_conn.DBConn):
             if not self.book_id_exist(store_id, book_id):
                 return error.error_non_exist_book_id(book_id)
 
-            self.conn.execute("UPDATE store SET stock_level = stock_level + ? "
-                              "WHERE store_id = ? AND book_id = ?", (add_stock_level, store_id, book_id))
-            self.conn.commit()
-        except sqlite.Error as e:
+            
+
+            with self.get_session() as session:
+                store = session.query(Store_model).filter(and_(Store_model.store_id==store_id ,Store_model.book_id == book_id)).one()
+                store.stock_level = store.stock_level+add_stock_level
+            
+        except SQLAlchemyError as e:
             return 528, "{}".format(str(e))
         except BaseException as e:
             return 530, "{}".format(str(e))
@@ -50,10 +53,12 @@ class Seller(db_conn.DBConn):
                 return error.error_non_exist_user_id(user_id)
             if self.store_id_exist(store_id):
                 return error.error_exist_store_id(store_id)
-            self.conn.execute("INSERT into user_store(store_id, user_id)"
-                              "VALUES (?, ?)", (store_id, user_id))
-            self.conn.commit()
-        except sqlite.Error as e:
+            
+            with self.get_session() as session:
+                new_userstore = UserStore_model(store_id=store_id,user_id=user_id)
+                session.add(new_userstore)
+                
+        except SQLAlchemyError as e:
             return 528, "{}".format(str(e))
         except BaseException as e:
             return 530, "{}".format(str(e))
diff --git a/be/model/store.py b/be/model/store.py
index d4c825c..db90b78 100644
--- a/be/model/store.py
+++ b/be/model/store.py
@@ -1,73 +1,70 @@
 import logging
 import os
 import sqlite3 as sqlite
+from be.model.orm_models import createTable
+#from orm_models import createTable
+
+from sqlalchemy import create_engine
+from sqlalchemy.orm import sessionmaker,scoped_session
+from contextlib import contextmanager
+import psycopg2
 
 
 class Store:
-    database: str
+    #database: str
 
-    def __init__(self, db_path):
-        pwd = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
-        db_address = os.path.join(pwd, "data/bookstore.db")
+    def __init__(self):
+        self.database = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "data/bookstore.db")
         # 最后我们只要换掉这个db_address就可以换成psql
-        self.database = db_address
-
+        self.engine = create_engine("sqlite:///"+self.database)
+        '''
+        self.engine = create_engine("postgresql+psycopg2://stu10205501460:Stu10205501460@dase-cdms-2022-pub.pg.rds.aliyuncs.com:5432/stu10205501460",
+        max_overflow=0,
+        # 链接池大小
+        pool_size=10,
+        # 链接池中没有可用链接则最多等待的秒数，超过该秒数后报错
+        pool_timeout=5,
+        # 多久之后对链接池中的链接进行一次回收
+        pool_recycle=5,
+        # 查看原生语句（未格式化）
+        echo=True
+        )
+        '''
+        
+        #self.engine = create_engine("postgresql+psycopg2://postgres:123456@localhost:5432/postgres",echo=True)
+        self.DBSession = sessionmaker(bind=self.engine)
         self.init_tables()
 
-    def init_tables(self):
-        try:
-            conn = self.get_db_conn()
-            conn.execute(
-                "CREATE TABLE IF NOT EXISTS user ("
-                "user_id TEXT PRIMARY KEY, password TEXT NOT NULL, "
-                "balance INTEGER NOT NULL, token TEXT, terminal TEXT);"
-            )
-
-            conn.execute(
-                "CREATE TABLE IF NOT EXISTS user_store("
-                "user_id TEXT, store_id TEXT, PRIMARY KEY(user_id, store_id));"
-            )
-        
-            conn.execute(
-                "CREATE TABLE IF NOT EXISTS store( "
-                "store_id TEXT, book_id TEXT, book_info TEXT, stock_level INTEGER,"
-                " PRIMARY KEY(store_id, book_id))"
-            )
 
-            conn.execute(
-                "CREATE TABLE IF NOT EXISTS new_order( "
-                "order_id TEXT PRIMARY KEY, user_id TEXT, store_id TEXT)"
-            )
+    def init_tables(self):
 
-            conn.execute(
-                "CREATE TABLE IF NOT EXISTS new_order_detail( "
-                "order_id TEXT, book_id TEXT, count INTEGER, price INTEGER,  "
-                "PRIMARY KEY(order_id, book_id))"
-            )
+        createTable(self.engine)
 
-            conn.commit()
-        except sqlite.Error as e:
-            logging.error(e)
-            conn.rollback()
 
-    def get_db_conn(self) -> sqlite.Connection:
-        return sqlite.connect(self.database)
+    @contextmanager
+    def get_db_session(self):
+        try:
+            session = scoped_session(self.DBSession)
+            yield session
+            session.commit()
+        except:
+            session.rollback()
+            raise
+        finally:
+            session.remove()
 
 
 database_instance: Store = None
 
 
-def init_database(db_path):
+def init_database():
     global database_instance
-    database_instance = Store(db_path)
+    database_instance = Store()
 
 
 def get_db_conn():
     global database_instance
-    return database_instance.get_db_conn()
+    return database_instance.get_db_session()
 
 if __name__ == "__main__":
-    pwd = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
-    
-    print(pwd)
-    init_database(pwd)
\ No newline at end of file
+    init_database()
\ No newline at end of file
diff --git a/be/model/user.py b/be/model/user.py
index acd58c2..7bad5e0 100644
--- a/be/model/user.py
+++ b/be/model/user.py
@@ -1,9 +1,10 @@
 import jwt
 import time
 import logging
-import sqlite3 as sqlite
 from be.model import error
 from be.model import db_conn
+from be.model.orm_models import User as User_model
+from sqlalchemy.exc import SQLAlchemyError
 
 # encode a json string like:
 #   {
@@ -33,11 +34,9 @@ def jwt_decode(encoded_token, user_id: str) -> str:
     return decoded
 
 
-class User(db_conn.DBConn):
+class User(db_conn.CheckExist):
     token_lifetime: int = 3600  # 3600 second
 
-    def __init__(self):
-        db_conn.DBConn.__init__(self)
 
     def __check_token(self, user_id, db_token, token) -> bool:
         try:
@@ -53,40 +52,53 @@ class User(db_conn.DBConn):
             logging.error(str(e))
             return False
 
+
     def register(self, user_id: str, password: str):
+
         try:
             terminal = "terminal_{}".format(str(time.time()))
             token = jwt_encode(user_id, terminal)
-            self.conn.execute(
-                "INSERT into user(user_id, password, balance, token, terminal) "
-                "VALUES (?, ?, ?, ?, ?);",
-                (user_id, password, 0, token, terminal), )
-            self.conn.commit()
-        except sqlite.Error:
+            with self.get_session() as session:
+
+                new_user = User_model(user_id=user_id, password=password, balance=0, token=token, terminal=terminal)
+                session.add(new_user)
+
+        except Exception as e:
             return error.error_exist_user_id(user_id)
         return 200, "ok"
 
+
     def check_token(self, user_id: str, token: str) -> (int, str):
-        cursor = self.conn.execute("SELECT token from user where user_id=?", (user_id,))
-        row = cursor.fetchone()
-        if row is None:
+
+        with self.get_session() as session:
+
+            row = session.query(User_model.token).filter(User_model.user_id==user_id).all()
+
+        if len(row) !=1 :
             return error.error_authorization_fail()
-        db_token = row[0]
+
+        db_token = row[0].token
+
         if not self.__check_token(user_id, db_token, token):
             return error.error_authorization_fail()
         return 200, "ok"
 
+
     def check_password(self, user_id: str, password: str) -> (int, str):
-        cursor = self.conn.execute("SELECT password from user where user_id=?", (user_id,))
-        row = cursor.fetchone()
-        if row is None:
+
+        with self.get_session() as session:
+
+            row = session.query(User_model.password).filter(User_model.user_id==user_id).all()
+
+        if len(row) !=1:
             return error.error_authorization_fail()
 
-        if password != row[0]:
+        if password != row[0].password:
             return error.error_authorization_fail()
 
         return 200, "ok"
 
+
     def login(self, user_id: str, password: str, terminal: str) -> (int, str, str):
         token = ""
         try:
@@ -95,18 +107,29 @@ class User(db_conn.DBConn):
                 return code, message, ""
 
             token = jwt_encode(user_id, terminal)
-            cursor = self.conn.execute(
-                "UPDATE user set token= ? , terminal = ? where user_id = ?",
-                (token, terminal, user_id), )
-            if cursor.rowcount == 0:
-                return error.error_authorization_fail() + ("", )
-            self.conn.commit()
-        except sqlite.Error as e:
+
+            with self.get_session() as session:
+
+                row = session.query(User_model).filter(User_model.user_id==user_id).all()
+
+                if len(row) != 1:
+                    return error.error_authorization_fail() + ("", )
+            
+
+                user = row[0]
+
+                user.token = token
+                user.terminal = terminal
+                            
+                session.add(user)
+
+        except SQLAlchemyError as e:
             return 528, "{}".format(str(e)), ""
         except BaseException as e:
             return 530, "{}".format(str(e)), ""
         return 200, "ok", token
 
+
     def logout(self, user_id: str, token: str) -> bool:
         try:
             code, message = self.check_token(user_id, token)
@@ -116,14 +139,21 @@ class User(db_conn.DBConn):
             terminal = "terminal_{}".format(str(time.time()))
             dummy_token = jwt_encode(user_id, terminal)
 
-            cursor = self.conn.execute(
-                "UPDATE user SET token = ?, terminal = ? WHERE user_id=?",
-                (dummy_token, terminal, user_id), )
-            if cursor.rowcount == 0:
-                return error.error_authorization_fail()
+            with self.get_session() as session:
+
+                row = session.query(User_model).filter(User_model.user_id==user_id).all()
+                
+                if len(row) !=1 :
+                    return error.error_authorization_fail() + ("", )
+                
+                user = row[0]
 
-            self.conn.commit()
-        except sqlite.Error as e:
+                user.token = dummy_token
+                user.terminal = terminal
+                
+                session.add(user)
+
+        except SQLAlchemyError as e:
             return 528, "{}".format(str(e))
         except BaseException as e:
             return 530, "{}".format(str(e))
@@ -135,12 +165,15 @@ class User(db_conn.DBConn):
             if code != 200:
                 return code, message
 
-            cursor = self.conn.execute("DELETE from user where user_id=?", (user_id,))
-            if cursor.rowcount == 1:
-                self.conn.commit()
-            else:
-                return error.error_authorization_fail()
-        except sqlite.Error as e:
+            with self.get_session() as session:
+                row = session.query(User_model).filter(User_model.user_id==user_id).all()
+
+                if len(row) ==1:
+                    user = row[0]
+                    session.delete(user)
+                else:
+                    return error.error_authorization_fail()
+        except SQLAlchemyError as e:
             return 528, "{}".format(str(e))
         except BaseException as e:
             return 530, "{}".format(str(e))
@@ -154,14 +187,22 @@ class User(db_conn.DBConn):
 
             terminal = "terminal_{}".format(str(time.time()))
             token = jwt_encode(user_id, terminal)
-            cursor = self.conn.execute(
-                "UPDATE user set password = ?, token= ? , terminal = ? where user_id = ?",
-                (new_password, token, terminal, user_id), )
-            if cursor.rowcount == 0:
-                return error.error_authorization_fail()
-
-            self.conn.commit()
-        except sqlite.Error as e:
+
+            with self.get_session() as session:
+               
+                row = session.query(User_model).filter(User_model.user_id==user_id).all()
+                
+                if len(row)!=1:
+                    return error.error_authorization_fail()
+
+                user = row[0]
+
+                user.password = new_password
+                user.token = token
+                user.terminal = terminal
+                session.add(user)
+                
+        except SQLAlchemyError as e:
             return 528, "{}".format(str(e))
         except BaseException as e:
             return 530, "{}".format(str(e))
diff --git a/be/serve.py b/be/serve.py
index 6499a7c..bace2fc 100644
--- a/be/serve.py
+++ b/be/serve.py
@@ -28,7 +28,7 @@ def be_run():
     this_path = os.path.dirname(__file__)
     parent_path = os.path.dirname(this_path)
     log_file = os.path.join(parent_path, "app.log")
-    init_database(parent_path)
+    init_database()
 
     logging.basicConfig(filename=log_file, level=logging.ERROR)
     handler = logging.StreamHandler()
diff --git a/data/bookstore.db b/data/bookstore.db
new file mode 100644
index 0000000..13d60d1
Binary files /dev/null and b/data/bookstore.db differ
diff --git a/data/bookstore_backup.db b/data/bookstore_backup.db
new file mode 100644
index 0000000..13d60d1
Binary files /dev/null and b/data/bookstore_backup.db differ
diff --git a/fe/access/book.py b/fe/access/book.py
index 5401619..32c871c 100644
--- a/fe/access/book.py
+++ b/fe/access/book.py
@@ -1,8 +1,10 @@
 import os
-import sqlite3 as sqlite
 import random
 import base64
 import simplejson as json
+from be.model import db_conn
+from be.model.orm_models import Book as Book_model
+from sqlalchemy import func
 
 
 class Book:
@@ -28,73 +30,63 @@ class Book:
         self.pictures = []
 
 
-class BookDB:
-    def __init__(self, large: bool = False):
-        pwd = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
-        db_address = os.path.join(pwd, "data/bookstore.db")
-        #self.db_s = os.path.join(parent_path, "data/book.db")
-        #self.db_l = os.path.join(parent_path, "data/book_lx.db")
-        '''
-        if large:
-            self.book_db = self.db_l
-        else:
-            self.book_db = self.db_s
-        ''' 
-        self.book_db = db_address
+class BookDB(db_conn.CheckExist):
 
     def get_book_count(self):
-        conn = sqlite.connect(self.book_db)
-        cursor = conn.execute(
-            "SELECT count(id) FROM book")
-        row = cursor.fetchone()
-        return row[0]
+
+        with self.get_session() as session:
+            row = session.query(func.count(Book_model.id).label("count")).one()
+
+            return row.count
 
     def get_book_info(self, start, size) -> [Book]:
         books = []
-        conn = sqlite.connect(self.book_db)
-        cursor = conn.execute(
-            "SELECT id, title, author, "
-            "publisher, original_title, "
-            "translator, pub_year, pages, "
-            "price, currency_unit, binding, "
-            "isbn, author_intro, book_intro, "
-            "content, tags, picture FROM book ORDER BY id "
-            "LIMIT ? OFFSET ?", (size, start))
-        for row in cursor:
-            book = Book()
-            book.id = row[0]
-            book.title = row[1]
-            book.author = row[2]
-            book.publisher = row[3]
-            book.original_title = row[4]
-            book.translator = row[5]
-            book.pub_year = row[6]
-            book.pages = row[7]
-            book.price = row[8]
-
-            book.currency_unit = row[9]
-            book.binding = row[10]
-            book.isbn = row[11]
-            book.author_intro = row[12]
-            book.book_intro = row[13]
-            book.content = row[14]
-            tags = row[15]
-
-            picture = row[16]
-
-            for tag in tags.split("\n"):
-                if tag.strip() != "":
-                    book.tags.append(tag)
-            for i in range(0, random.randint(0, 9)):
-                if picture is not None:
-                    encode_str = base64.b64encode(picture).decode('utf-8')
-                    book.pictures.append(encode_str)
-            books.append(book)
-            # print(tags.decode('utf-8'))
-
-            # print(book.tags, len(book.picture))
-            # print(book)
-            # print(tags)
+        with self.get_session() as session:
+            rows = session.query(Book_model.id,
+            Book_model.title,Book_model.author,Book_model.publisher,
+            Book_model.original_title,Book_model.translator,
+            Book_model.pub_year,Book_model.pages,
+            Book_model.price,Book_model.currency_unit,Book_model.binding,
+            Book_model.isbn,Book_model.author_intro,
+            Book_model.book_intro,Book_model.content,
+            Book_model.tags,Book_model.picture
+            ).order_by(Book_model.id.asc()).offset(start).limit(size)
+
+            for row in rows:
+                book = Book()
+                book.id = row.id
+                book.title = row.title
+                book.author = row.author
+                book.publisher = row.publisher
+                book.original_title = row.original_title
+                book.translator = row.translator
+                book.pub_year = row.pub_year
+                book.pages = row.pages
+                book.price = row.price
+
+                book.currency_unit = row.currency_unit
+                book.binding = row.binding 
+                book.isbn = row.isbn
+                book.author_intro = row.author_intro
+                book.book_intro = row.book_intro
+                book.content = row.content
+                tags = row.tags
+
+                picture = row[16]
+
+                for tag in tags.split("\n"):
+                    if tag.strip() != "":
+                        book.tags.append(tag)
+                for i in range(0, random.randint(0, 9)):
+                    if picture is not None:
+                        encode_str = base64.b64encode(picture).decode('utf-8')
+                        book.pictures.append(encode_str)
+                books.append(book)
+                # print(tags.decode('utf-8'))
+
+                # print(book.tags, len(book.picture))
+                # print(book)
+                # print(tags)
 
         return books
 
diff --git a/fe/bench/workload.py b/fe/bench/workload.py
index 2ee377f..7429041 100644
--- a/fe/bench/workload.py
+++ b/fe/bench/workload.py
@@ -36,7 +36,8 @@ class Workload:
         self.book_ids = []
         self.buyer_ids = []
         self.store_ids = []
-        self.book_db = book.BookDB(conf.Use_Large_DB)
+        #self.book_db = book.BookDB(conf.Use_Large_DB)
+        self.book_db = book.BookDB()
         self.row_count = self.book_db.get_book_count()
 
         self.book_num_per_store = conf.Book_Num_Per_Store
diff --git a/fe/data/book.db b/fe/data/book.db
deleted file mode 100644
index 5ee601c..0000000
Binary files a/fe/data/book.db and /dev/null differ
diff --git a/fe/data/scraper.py b/fe/data/scraper.py
deleted file mode 100644
index c85e3d1..0000000
--- a/fe/data/scraper.py
+++ /dev/null
@@ -1,425 +0,0 @@
-# coding=utf-8
-
-from lxml import etree
-import sqlite3
-import re
-import requests
-import random
-import time
-import logging
-
-user_agent = [
-    "Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 "
-    "Safari/534.50",
-    "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 "
-    "Safari/534.50",
-    "Mozilla/5.0 (Windows NT 10.0; WOW64; rv:38.0) Gecko/20100101 Firefox/38.0",
-    "Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR "
-    "3.0.30729; .NET CLR 3.5.30729; InfoPath.3; rv:11.0) like Gecko",
-    "Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)",
-    "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)",
-    "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)",
-    "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)",
-    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0.1) Gecko/20100101 Firefox/4.0.1",
-    "Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/4.0.1",
-    "Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; en) Presto/2.8.131 Version/11.11",
-    "Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11",
-    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 "
-    "Safari/535.11",
-    "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Maxthon 2.0)",
-    "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; TencentTraveler 4.0)",
-    "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)",
-    "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; The World)",
-    "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SE 2.X MetaSr 1.0; SE 2.X MetaSr 1.0; .NET "
-    "CLR 2.0.50727; SE 2.X MetaSr 1.0)",
-    "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; 360SE)",
-    "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Avant Browser)",
-    "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)",
-    "Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) "
-    "Version/5.0.2 Mobile/8J2 Safari/6533.18.5",
-    "Mozilla/5.0 (iPod; U; CPU iPhone OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) "
-    "Version/5.0.2 Mobile/8J2 Safari/6533.18.5",
-    "Mozilla/5.0 (iPad; U; CPU OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) "
-    "Version/5.0.2 Mobile/8J2 Safari/6533.18.5",
-    "Mozilla/5.0 (Linux; U; Android 2.3.7; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) "
-    "Version/4.0 Mobile Safari/533.1",
-    "MQQBrowser/26 Mozilla/5.0 (Linux; U; Android 2.3.7; zh-cn; MB200 Build/GRJ22; CyanogenMod-7) "
-    "AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1",
-    "Opera/9.80 (Android 2.3.4; Linux; Opera Mobi/build-1107180945; U; en-GB) Presto/2.8.149 Version/11.10",
-    "Mozilla/5.0 (Linux; U; Android 3.0; en-us; Xoom Build/HRI39) AppleWebKit/534.13 (KHTML, like Gecko) "
-    "Version/4.0 Safari/534.13",
-    "Mozilla/5.0 (BlackBerry; U; BlackBerry 9800; en) AppleWebKit/534.1+ (KHTML, like Gecko) Version/6.0.0.337 "
-    "Mobile Safari/534.1+",
-    "Mozilla/5.0 (hp-tablet; Linux; hpwOS/3.0.0; U; en-US) AppleWebKit/534.6 (KHTML, like Gecko) "
-    "wOSBrowser/233.70 Safari/534.6 TouchPad/1.0",
-    "Mozilla/5.0 (SymbianOS/9.4; Series60/5.0 NokiaN97-1/20.0.019; Profile/MIDP-2.1 Configuration/CLDC-1.1) "
-    "AppleWebKit/525 (KHTML, like Gecko) BrowserNG/7.1.18124",
-    "Mozilla/5.0 (compatible; MSIE 9.0; Windows Phone OS 7.5; Trident/5.0; IEMobile/9.0; HTC; Titan)",
-    "UCWEB7.0.2.37/28/999",
-    "NOKIA5700/ UCWEB7.0.2.37/28/999",
-    "Openwave/ UCWEB7.0.2.37/28/999",
-    "Mozilla/4.0 (compatible; MSIE 6.0; ) Opera/UCWEB7.0.2.37/28/999",
-    # iPhone 6：
-    "Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 "
-    "Mobile/10A5376e Safari/8536.25",
-]
-
-
-def get_user_agent():
-    headers = {"User-Agent": random.choice(user_agent)}
-    return headers
-
-
-class Scraper:
-    database: str
-    tag: str
-    page: int
-
-    def __init__(self):
-        self.database = "book.db"
-        self.tag = ""
-        self.page = 0
-        self.pattern_number = re.compile(r"\d+\.?\d*")
-        logging.basicConfig(filename="scraper.log", level=logging.ERROR)
-
-    def get_current_progress(self) -> ():
-        conn = sqlite3.connect(self.database)
-        results = conn.execute("SELECT tag, page from progress where id = '0'")
-        for row in results:
-            return row[0], row[1]
-        return "", 0
-
-    def save_current_progress(self, current_tag, current_page):
-        conn = sqlite3.connect(self.database)
-        conn.execute(
-            "UPDATE progress set tag = '{}', page = {} where id = '0'".format(
-                current_tag, current_page
-            )
-        )
-        conn.commit()
-        conn.close()
-
-    def start_grab(self) -> bool:
-        self.create_tables()
-        scraper.grab_tag()
-        current_tag, current_page = self.get_current_progress()
-        tags = self.get_tag_list()
-        for i in range(0, len(tags)):
-            no = 0
-            if i == 0 and current_tag == tags[i]:
-                no = current_page
-            while self.grab_book_list(tags[i], no):
-                no = no + 20
-        return True
-
-    def create_tables(self):
-        conn = sqlite3.connect(self.database)
-        try:
-            conn.execute("CREATE TABLE tags (tag TEXT PRIMARY KEY)")
-            conn.commit()
-        except sqlite3.Error as e:
-            logging.error(str(e))
-            conn.rollback()
-
-        try:
-            conn.execute(
-                "CREATE TABLE book ("
-                "id TEXT PRIMARY KEY, title TEXT, author TEXT, "
-                "publisher TEXT, original_title TEXT, "
-                "translator TEXT, pub_year TEXT, pages INTEGER, "
-                "price INTEGER, currency_unit TEXT, binding TEXT, "
-                "isbn TEXT, author_intro TEXT, book_intro text, "
-                "content TEXT, tags TEXT, picture BLOB)"
-            )
-            conn.commit()
-        except sqlite3.Error as e:
-            logging.error(str(e))
-            conn.rollback()
-
-        try:
-            conn.execute(
-                "CREATE TABLE progress (id TEXT PRIMARY KEY, tag TEXT, page integer )"
-            )
-            conn.execute("INSERT INTO progress values('0', '', 0)")
-            conn.commit()
-        except sqlite3.Error as e:
-            logging.error(str(e))
-            conn.rollback()
-
-    def grab_tag(self):
-        url = "https://book.douban.com/tag/?view=cloud"
-        r = requests.get(url, headers=get_user_agent())
-        r.encoding = "utf-8"
-        h: etree.ElementBase = etree.HTML(r.text)
-        tags: [] = h.xpath(
-            '/html/body/div[@id="wrapper"]/div[@id="content"]'
-            '/div[@class="grid-16-8 clearfix"]/div[@class="article"]'
-            '/div[@class=""]/div[@class="indent tag_cloud"]'
-            "/table/tbody/tr/td/a/@href"
-        )
-        conn = sqlite3.connect(self.database)
-        c = conn.cursor()
-        try:
-            for tag in tags:
-                t: str = tag.strip("/tag")
-                c.execute("INSERT INTO tags VALUES ('{}')".format(t))
-            c.close()
-            conn.commit()
-            conn.close()
-        except sqlite3.Error as e:
-            logging.error(str(e))
-            conn.rollback()
-            return False
-        return True
-
-    def grab_book_list(self, tag="小说", pageno=1) -> bool:
-        logging.info("start to grab tag {} page {}...".format(tag, pageno))
-        self.save_current_progress(tag, pageno)
-        url = "https://book.douban.com/tag/{}?start={}&type=T".format(tag, pageno)
-        r = requests.get(url, headers=get_user_agent())
-        r.encoding = "utf-8"
-        h: etree.Element = etree.HTML(r.text)
-
-        li_list: [] = h.xpath(
-            '/html/body/div[@id="wrapper"]/div[@id="content"]'
-            '/div[@class="grid-16-8 clearfix"]'
-            '/div[@class="article"]/div[@id="subject_list"]'
-            '/ul/li/div[@class="info"]/h2/a/@href'
-        )
-        next_page = h.xpath(
-            '/html/body/div[@id="wrapper"]/div[@id="content"]'
-            '/div[@class="grid-16-8 clearfix"]'
-            '/div[@class="article"]/div[@id="subject_list"]'
-            '/div[@class="paginator"]/span[@class="next"]/a[@href]'
-        )
-        has_next = True
-        if len(next_page) == 0:
-            has_next = False
-        if len(li_list) == 0:
-            return False
-
-        for li in li_list:
-            li.strip("")
-            book_id = li.strip("/").split("/")[-1]
-            try:
-                delay = float(random.randint(0, 200)) / 100.0
-                time.sleep(delay)
-                self.crow_book_info(book_id)
-            except BaseException as e:
-                logging.error(
-                    logging.error("error when scrape {}, {}".format(book_id, str(e)))
-                )
-        return has_next
-
-    def get_tag_list(self) -> [str]:
-        ret = []
-        conn = sqlite3.connect(self.database)
-        results = conn.execute(
-            "SELECT tags.tag from tags join progress where tags.tag >= progress.tag"
-        )
-        for row in results:
-            ret.append(row[0])
-        return ret
-
-    def crow_book_info(self, book_id) -> bool:
-        conn = sqlite3.connect(self.database)
-        for _ in conn.execute("SELECT id from book where id = ('{}')".format(book_id)):
-            return
-
-        url = "https://book.douban.com/subject/{}/".format(book_id)
-        r = requests.get(url, headers=get_user_agent())
-        r.encoding = "utf-8"
-        h: etree.Element = etree.HTML(r.text)
-        e_text = h.xpath('/html/body/div[@id="wrapper"]/h1/span/text()')
-        if len(e_text) == 0:
-            return False
-
-        title = e_text[0]
-
-        elements = h.xpath(
-            '/html/body/div[@id="wrapper"]'
-            '/div[@id="content"]/div[@class="grid-16-8 clearfix"]'
-            '/div[@class="article"]'
-        )
-        if len(elements) == 0:
-            return False
-
-        e_article = elements[0]
-
-        book_intro = ""
-        author_intro = ""
-        content = ""
-        tags = ""
-
-        e_book_intro = e_article.xpath(
-            'div[@class="related_info"]'
-            '/div[@class="indent"][@id="link-report"]/*'
-            '/div[@class="intro"]/*/text()'
-        )
-        for line in e_book_intro:
-            line = line.strip()
-            if line != "":
-                book_intro = book_intro + line + "\n"
-
-        e_author_intro = e_article.xpath(
-            'div[@class="related_info"]'
-            '/div[@class="indent "]/*'
-            '/div[@class="intro"]/*/text()'
-        )
-        for line in e_author_intro:
-            line = line.strip()
-            if line != "":
-                author_intro = author_intro + line + "\n"
-
-        e_content = e_article.xpath(
-            'div[@class="related_info"]'
-            '/div[@class="indent"][@id="dir_' + book_id + '_full"]/text()'
-        )
-        for line in e_content:
-            line = line.strip()
-            if line != "":
-                content = content + line + "\n"
-
-        e_tags = e_article.xpath(
-            'div[@class="related_info"]/'
-            'div[@id="db-tags-section"]/'
-            'div[@class="indent"]/span/a/text()'
-        )
-        for line in e_tags:
-            line = line.strip()
-            if line != "":
-                tags = tags + line + "\n"
-
-        e_subject = e_article.xpath(
-            'div[@class="indent"]'
-            '/div[@class="subjectwrap clearfix"]'
-            '/div[@class="subject clearfix"]'
-        )
-        pic_href = e_subject[0].xpath('div[@id="mainpic"]/a/@href')
-        picture = None
-        if len(pic_href) > 0:
-            res = requests.get(pic_href[0], headers=get_user_agent())
-            picture = res.content
-
-        info_children = e_subject[0].xpath('div[@id="info"]/child::node()')
-
-        e_array = []
-        e_dict = dict()
-
-        for e in info_children:
-            if isinstance(e, etree._ElementUnicodeResult):
-                e_dict["text"] = e
-            elif isinstance(e, etree._Element):
-                if e.tag == "br":
-                    e_array.append(e_dict)
-                    e_dict = dict()
-                else:
-                    e_dict[e.tag] = e
-
-        book_info = dict()
-        for d in e_array:
-            label = ""
-            span = d.get("span")
-            a_label = span.xpath("span/text()")
-            if len(a_label) > 0 and label == "":
-                label = a_label[0].strip()
-            a_label = span.xpath("text()")
-            if len(a_label) > 0 and label == "":
-                label = a_label[0].strip()
-            label = label.strip(":")
-            text = d.get("text").strip()
-            e_a = d.get("a")
-            text.strip()
-            text.strip(":")
-            if label == "作者" or label == "译者":
-                a = span.xpath("a/text()")
-                if text == "" and len(a) == 1:
-                    text = a[0].strip()
-                if text == "" and e_a is not None:
-                    text_a = e_a.xpath("text()")
-                    if len(text_a) > 0:
-                        text = text_a[0].strip()
-                        text = re.sub(r"\s+", " ", text)
-            if text != "":
-                book_info[label] = text
-
-        sql = (
-            "INSERT INTO book("
-            "id, title, author, "
-            "publisher, original_title, translator, "
-            "pub_year, pages, price, "
-            "currency_unit, binding, isbn, "
-            "author_intro, book_intro, content, "
-            "tags, picture)"
-            "VALUES("
-            "?, ?, ?, "
-            "?, ?, ?, "
-            "?, ?, ?, "
-            "?, ?, ?, "
-            "?, ?, ?, "
-            "?, ?)"
-        )
-
-        unit = None
-        price = None
-        pages = None
-        conn = sqlite3.connect(self.database)
-        try:
-            s_price = book_info.get("定价")
-            if s_price is None:
-                # price cannot be NULL
-                logging.error(
-                    "error when scrape book_id {}, cannot retrieve price...", book_id
-                )
-                return None
-            else:
-                e = re.findall(self.pattern_number, s_price)
-                if len(e) != 0:
-                    number = e[0]
-                    unit = s_price.replace(number, "").strip()
-                    price = int(float(number) * 100)
-
-            s_pages = book_info.get("页数")
-            if s_pages is not None:
-                # pages can be NULL
-                e = re.findall(self.pattern_number, s_pages)
-                if len(e) != 0:
-                    pages = int(e[0])
-
-            conn.execute(
-                sql,
-                (
-                    book_id,
-                    title,
-                    book_info.get("作者"),
-                    book_info.get("出版社"),
-                    book_info.get("原作名"),
-                    book_info.get("译者"),
-                    book_info.get("出版年"),
-                    pages,
-                    price,
-                    unit,
-                    book_info.get("装帧"),
-                    book_info.get("ISBN"),
-                    author_intro,
-                    book_intro,
-                    content,
-                    tags,
-                    picture,
-                ),
-            )
-            conn.commit()
-        except sqlite3.Error as e:
-            logging(str(e))
-            conn.rollback()
-        except TypeError as e:
-            logging.error("error when scrape {}, {}".format(book_id, str(e)))
-            conn.rollback()
-            return False
-        conn.close()
-        return True
-
-
-if __name__ == "__main__":
-    scraper = Scraper()
-    scraper.start_grab()
diff --git a/script/test.sh b/script/test.sh
index ae7bfb0..9fd39a4 100644
--- a/script/test.sh
+++ b/script/test.sh
@@ -1,6 +1,8 @@
 #!/bin/sh
 export PATHONPATH=`pwd`
-coverage run --timid --branch --source fe,be --concurrency=thread -m pytest -v --ignore=fe/data
-coverage combine
-coverage report
-coverage html
+coverage run --timid --branch --source fe,be --concurrency=thread -m pytest -v --ignore=fe/data > not_upload/res.txt
+coverage combine >> not_upload/res.txt
+coverage report >> not_upload/res.txt
+coverage html >> not_upload/res.txt
+mv htmlcov not_upload
+mv .coverage not_upload

commit 066aa6a5ac0aff3b2c37984e69ea8bb73e6d45d1
Author: dirtyDan0 <ray3218@outlook.com>
Date:   Tue Nov 29 13:23:21 2022 +0800

    change db_path

diff --git a/.gitignore b/.gitignore
index 751c391..4f0062a 100644
--- a/.gitignore
+++ b/.gitignore
@@ -5,4 +5,5 @@
 *.log
 htmlcov
 *.pyc
-__pycache__/
\ No newline at end of file
+__pycache__/
+not_upload/
\ No newline at end of file
diff --git a/be/model/store.py b/be/model/store.py
index eff8bb7..d4c825c 100644
--- a/be/model/store.py
+++ b/be/model/store.py
@@ -7,7 +7,11 @@ class Store:
     database: str
 
     def __init__(self, db_path):
-        self.database = os.path.join(db_path, "be.db")
+        pwd = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
+        db_address = os.path.join(pwd, "data/bookstore.db")
+        # 最后我们只要换掉这个db_address就可以换成psql
+        self.database = db_address
+
         self.init_tables()
 
     def init_tables(self):
@@ -61,3 +65,9 @@ def init_database(db_path):
 def get_db_conn():
     global database_instance
     return database_instance.get_db_conn()
+
+if __name__ == "__main__":
+    pwd = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
+    
+    print(pwd)
+    init_database(pwd)
\ No newline at end of file
diff --git a/fe/access/book.py b/fe/access/book.py
index 5dc6347..5401619 100644
--- a/fe/access/book.py
+++ b/fe/access/book.py
@@ -30,13 +30,17 @@ class Book:
 
 class BookDB:
     def __init__(self, large: bool = False):
-        parent_path = os.path.dirname(os.path.dirname(__file__))
-        self.db_s = os.path.join(parent_path, "data/book.db")
-        self.db_l = os.path.join(parent_path, "data/book_lx.db")
+        pwd = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
+        db_address = os.path.join(pwd, "data/bookstore.db")
+        #self.db_s = os.path.join(parent_path, "data/book.db")
+        #self.db_l = os.path.join(parent_path, "data/book_lx.db")
+        '''
         if large:
             self.book_db = self.db_l
         else:
             self.book_db = self.db_s
+        ''' 
+        self.book_db = db_address
 
     def get_book_count(self):
         conn = sqlite.connect(self.book_db)

commit 58b58de4e46aa80d2bac18f7894a0c763e06136c
Author: dirtyDan0 <ray3218@outlook.com>
Date:   Mon Nov 28 23:07:24 2022 +0800

    edit .gitignore

diff --git a/.gitignore b/.gitignore
index fb4f390..751c391 100644
--- a/.gitignore
+++ b/.gitignore
@@ -3,4 +3,6 @@
 .idea
 .pytest_cache
 *.log
-htmlcov
\ No newline at end of file
+htmlcov
+*.pyc
+__pycache__/
\ No newline at end of file

commit 327a0baf28980f8c4b15bc787ada9e62074b1381
Author: dirtyDan0 <ray3218@outlook.com>
Date:   Mon Nov 28 15:57:44 2022 +0800

    memo

diff --git a/be/model/store.py b/be/model/store.py
index 869eb91..eff8bb7 100644
--- a/be/model/store.py
+++ b/be/model/store.py
@@ -41,16 +41,6 @@ class Store:
                 "PRIMARY KEY(order_id, book_id))"
             )
 
-            conn.execute(
-                "CREATE TABLE IF NOT EXISTS book ("
-                "id TEXT PRIMARY KEY, title TEXT, author TEXT, "
-                "publisher TEXT, original_title TEXT, "
-                "translator TEXT, pub_year TEXT, pages INTEGER, "
-                "price INTEGER, currency_unit TEXT, binding TEXT, "
-                "isbn TEXT, author_intro TEXT, book_intro text, "
-                "content TEXT, tags TEXT, picture BLOB)"
-            )
-
             conn.commit()
         except sqlite.Error as e:
             logging.error(e)
diff --git a/memo.md b/memo.md
index 511cab2..05f8695 100644
--- a/memo.md
+++ b/memo.md
@@ -1 +1,4 @@
-> 这是一个负责记录开发过程中的一些注意事项的md
\ No newline at end of file
+> 这是一个负责记录开发过程中的一些注意事项的md
+
+改orm
+加字段 status time 在 neworder
\ No newline at end of file

commit 6599bb3befc55efbeb3d76e451e20c871b29c615
Author: dirtyDan0 <ray3218@outlook.com>
Date:   Mon Nov 28 12:50:46 2022 +0800

    add the ddl of book to store.py

diff --git a/be/model/store.py b/be/model/store.py
index eff8bb7..869eb91 100644
--- a/be/model/store.py
+++ b/be/model/store.py
@@ -41,6 +41,16 @@ class Store:
                 "PRIMARY KEY(order_id, book_id))"
             )
 
+            conn.execute(
+                "CREATE TABLE IF NOT EXISTS book ("
+                "id TEXT PRIMARY KEY, title TEXT, author TEXT, "
+                "publisher TEXT, original_title TEXT, "
+                "translator TEXT, pub_year TEXT, pages INTEGER, "
+                "price INTEGER, currency_unit TEXT, binding TEXT, "
+                "isbn TEXT, author_intro TEXT, book_intro text, "
+                "content TEXT, tags TEXT, picture BLOB)"
+            )
+
             conn.commit()
         except sqlite.Error as e:
             logging.error(e)

commit f82cceecf5967ff09c651a26ffac6bcdb39892f3
Author: dirtyDan0 <ray3218@outlook.com>
Date:   Mon Nov 28 12:16:21 2022 +0800

    add markdown

diff --git a/markdown/lsh.md b/markdown/lsh.md
new file mode 100644
index 0000000..e69de29
diff --git a/markdown/main.md b/markdown/main.md
new file mode 100644
index 0000000..e69de29
diff --git a/markdown/wlm.md b/markdown/wlm.md
new file mode 100644
index 0000000..e69de29
diff --git a/markdown/yq.md b/markdown/yq.md
new file mode 100644
index 0000000..e69de29

commit 3f1a6966c9124fa3e8ede60c39263aa1917da79e
Author: dirtyDan0 <ray3218@outlook.com>
Date:   Mon Nov 28 08:51:06 2022 +0800

    fix some bugs

diff --git a/.gitignore b/.gitignore
index 7627284..fb4f390 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,2 +1,6 @@
 /.idea/
-/杂/
\ No newline at end of file
+.coverage
+.idea
+.pytest_cache
+*.log
+htmlcov
\ No newline at end of file
diff --git a/be/model/store.py b/be/model/store.py
index d82aeeb..eff8bb7 100644
--- a/be/model/store.py
+++ b/be/model/store.py
@@ -21,9 +21,9 @@ class Store:
 
             conn.execute(
                 "CREATE TABLE IF NOT EXISTS user_store("
-                "user_id TEXT, store_id, PRIMARY KEY(user_id, store_id));"
+                "user_id TEXT, store_id TEXT, PRIMARY KEY(user_id, store_id));"
             )
-
+        
             conn.execute(
                 "CREATE TABLE IF NOT EXISTS store( "
                 "store_id TEXT, book_id TEXT, book_info TEXT, stock_level INTEGER,"
diff --git a/fe/bench/workload.py b/fe/bench/workload.py
index d7c9e6e..2ee377f 100644
--- a/fe/bench/workload.py
+++ b/fe/bench/workload.py
@@ -129,7 +129,7 @@ class Workload:
                     time_new_order, time_payment):
         # 获取当前并发数
         thread_num = len(threading.enumerate())
-        # 加索
+        # 加锁
         self.lock.acquire()
         self.n_new_order = self.n_new_order + n_new_order
         self.n_payment = self.n_payment + n_payment

commit d20516f404cc078d97752bb61aa4d44a326c0eec
Author: dirtyDan0 <ray3218@outlook.com>
Date:   Sat Nov 26 23:56:43 2022 +0800

    add memo.md

diff --git a/.gitignore b/.gitignore
index 57f1cb2..7627284 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1 +1,2 @@
-/.idea/
\ No newline at end of file
+/.idea/
+/杂/
\ No newline at end of file
diff --git a/memo.md b/memo.md
new file mode 100644
index 0000000..511cab2
--- /dev/null
+++ b/memo.md
@@ -0,0 +1 @@
+> 这是一个负责记录开发过程中的一些注意事项的md
\ No newline at end of file

commit 71c69963a17da6beb8e06e07223c1302a9e37b09
Author: dirtyDan0 <ray3218@outlook.com>
Date:   Sat Nov 26 23:30:23 2022 +0800

    first commit

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..57f1cb2
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1 @@
+/.idea/
\ No newline at end of file
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..d36b7f0
--- /dev/null
+++ b/README.md
@@ -0,0 +1,161 @@
+# bookstore
+[![Build Status](https://travis-ci.com/DaSE-DBMS/bookstore.svg?branch=master)](https://travis-ci.com/DaSE-DBMS/bookstore)
+[![codecov](https://codecov.io/gh/DaSE-DBMS/bookstore/branch/master/graph/badge.svg)](https://codecov.io/gh/DaSE-DBMS/bookstore)
+
+
+## 功能
+
+实现一个提供网上购书功能的网站后端。<br>
+网站支持书商在上面开商店，购买者可以通过网站购买。<br>
+买家和卖家都可以注册自己的账号。<br>
+一个卖家可以开一个或多个网上商店，
+买家可以为自已的账户充值，在任意商店购买图书。<br>
+支持 下单->付款->发货->收货 流程。<br>
+
+1.实现对应接口的功能，见项目的doc文件夹下面的.md文件描述 （60%）<br>
+
+其中包括：
+
+1)用户权限接口，如注册、登录、登出、注销<br>
+
+2)买家用户接口，如充值、下单、付款<br>
+
+3)卖家用户接口，如创建店铺、填加书籍信息及描述、增加库存<br>
+
+通过对应的功能测试，所有test case都pass <br>
+
+
+2.为项目添加其它功能 ：（40%）<br>
+
+1)实现后续的流程 <br>
+发货 -> 收货
+
+2)搜索图书 <br>
+用户可以通过关键字搜索，参数化的搜索方式；
+如搜索范围包括，题目，标签，目录，内容；全站搜索或是当前店铺搜索。
+如果显示结果较大，需要分页
+(使用全文索引优化查找)
+
+3)订单状态，订单查询和取消定单<br>
+用户可以查自已的历史订单，用户也可以取消订单。<br>
+取消定单可由买家主动地取消定单，或者买家下单后，经过一段时间超时仍未付款，定单也会自动取消。 <br>
+
+
+## bookstore目录结构
+```
+bookstore
+  |-- be                            后端
+        |-- model                     后端逻辑代码
+        |-- view                      访问后端接口
+        |-- ....
+  |-- doc                           JSON API规范说明
+  |-- fe                            前端访问与测试代码
+        |-- access
+        |-- bench                     效率测试
+        |-- data                    
+            |-- book.db                 sqlite 数据库(book.db，较少量的测试数据)
+            |-- book_lx.db              sqlite 数据库(book_lx.db， 较大量的测试数据，要从网盘下载)
+            |-- scraper.py              从豆瓣爬取的图书信息数据的代码
+        |-- test                      功能性测试（包含对前60%功能的测试，不要修改已有的文件，可以提pull request或bug）
+        |-- conf.py                   测试参数，修改这个文件以适应自己的需要
+        |-- conftest.py               pytest初始化配置，修改这个文件以适应自己的需要
+        |-- ....
+  |-- ....
+```
+
+
+## 安装配置
+安装python (需要python3.6以上) 
+
+进入bookstore文件夹下：
+
+安装依赖
+
+    pip install -r requirements.txt
+
+执行测试
+    
+    bash script/test.sh
+
+bookstore/fe/data/book.db中包含测试的数据，从豆瓣网抓取的图书信息，其DDL为：
+ 
+    create table book
+    (
+        id TEXT primary key,
+        title TEXT,
+        author TEXT,
+        publisher TEXT,
+        original_title TEXT,
+        translator TEXT,
+        pub_year TEXT,
+        pages INTEGER,
+        price INTEGER,
+        currency_unit TEXT,
+        binding TEXT,
+        isbn TEXT,
+        author_intro TEXT,
+        book_intro text,
+        content TEXT,
+        tags TEXT,
+        picture BLOB
+    );
+
+
+## 要求
+
+3人一组，做好分工，完成下述内容：
+
+1.bookstore文件夹是该项目的demo，采用flask后端框架与sqlite数据库，实现了前60%功能以及对应的测试用例代码。要求利用ORM使用postgreSQL数据库实现前60%功能，可以在demo的基础上进行修改，也可以采用其他后端框架重新实现。需要通过fe/test/下已有的全部测试用例。
+
+2.在完成前60%功能的基础上，继续实现后40%功能，要有接口、后端逻辑实现、数据库操作、代码测试。对所有接口都要写test case，通过测试并计算测试覆盖率（尽量提高测试覆盖率）。
+
+3.尽量使用索引、事务处理等关系数据库特性，对程序与数据库执行的性能有考量
+
+4.尽量使用git等版本管理工具
+
+5.不需要实现界面，通过代码测试体现功能与正确性
+
+
+## 报告内容
+
+1.每位组员的学号、姓名，以及分工
+
+2.关系数据库设计：概念设计、ER图、关系模式等
+
+3.对60%基础功能和40%附加功能的接口、后端逻辑、数据库操作、测试用例进行介绍，展示测试结果与测试覆盖率。
+
+4.如果完成，可以展示本次大作业的亮点，比如要求中的“3 4”两点。
+
+注：验收依据为报告，本次大作业所作的工作要完整展示在报告中。
+
+
+## 验收与考核准测
+
+- 提交 **代码+报告** 压缩包到 **第二次大作业提交** 入口，命名规则：2022_CDMS_PJ2_第几组
+- 提交截止日期：**2022.12.10 22:00**
+
+本次大作业不需要提交演示视频，验收的依据是报告：
+
+1. 没有提交或没有实质的工作，得D
+2. 完成"要求"中的第1点，可得C
+3. 完成前2点，通过全部测试用例且有较高的测试覆盖率，可得B
+4. 完成前2点的基础上，体现出第3 4点，可得A
+
+
+## 附加任务
+
+本次考核不做要求 
+
+学有余力的同学可以尝试下述内容，可以写在报告里：
+
+更多的数据 book_lx.db 可以从网盘下载，下载地址为：
+
+    https://pan.baidu.com/s/1bjCOW8Z5N_ClcqU54Pdt8g
+
+提取码：
+
+    hj6q
+    
+这份数据同bookstore/fe/data/book.db的schema相同，但是有更多的数据(约3.5GB, 40000+行)
+
+可以将book_lx.db导入到数据库中，测试下单及付款两个接口的性能（最好分离负载生成和后端），测出支持的每分钟交易数，延迟等。
diff --git a/be/__init__.py b/be/__init__.py
new file mode 100644
index 0000000..e5a0d9b
--- /dev/null
+++ b/be/__init__.py
@@ -0,0 +1 @@
+#!/usr/bin/env python3
diff --git a/be/app.py b/be/app.py
new file mode 100644
index 0000000..e0a6207
--- /dev/null
+++ b/be/app.py
@@ -0,0 +1,4 @@
+from be import serve
+
+if __name__ == "__main__":
+    serve.be_run()
diff --git a/be/model/__init__.py b/be/model/__init__.py
new file mode 100644
index 0000000..e5a0d9b
--- /dev/null
+++ b/be/model/__init__.py
@@ -0,0 +1 @@
+#!/usr/bin/env python3
diff --git a/be/model/buyer.py b/be/model/buyer.py
new file mode 100644
index 0000000..d50fbec
--- /dev/null
+++ b/be/model/buyer.py
@@ -0,0 +1,162 @@
+import sqlite3 as sqlite
+import uuid
+import json
+import logging
+from be.model import db_conn
+from be.model import error
+
+
+class Buyer(db_conn.DBConn):
+    def __init__(self):
+        db_conn.DBConn.__init__(self)
+
+    def new_order(self, user_id: str, store_id: str, id_and_count: [(str, int)]) -> (int, str, str):
+        order_id = ""
+        try:
+            if not self.user_id_exist(user_id):
+                return error.error_non_exist_user_id(user_id) + (order_id, )
+            if not self.store_id_exist(store_id):
+                return error.error_non_exist_store_id(store_id) + (order_id, )
+            uid = "{}_{}_{}".format(user_id, store_id, str(uuid.uuid1()))
+
+            for book_id, count in id_and_count:
+                cursor = self.conn.execute(
+                    "SELECT book_id, stock_level, book_info FROM store "
+                    "WHERE store_id = ? AND book_id = ?;",
+                    (store_id, book_id))
+                row = cursor.fetchone()
+                if row is None:
+                    return error.error_non_exist_book_id(book_id) + (order_id, )
+
+                stock_level = row[1]
+                book_info = row[2]
+                book_info_json = json.loads(book_info)
+                price = book_info_json.get("price")
+
+                if stock_level < count:
+                    return error.error_stock_level_low(book_id) + (order_id,)
+
+                cursor = self.conn.execute(
+                    "UPDATE store set stock_level = stock_level - ? "
+                    "WHERE store_id = ? and book_id = ? and stock_level >= ?; ",
+                    (count, store_id, book_id, count))
+                if cursor.rowcount == 0:
+                    return error.error_stock_level_low(book_id) + (order_id, )
+
+                self.conn.execute(
+                        "INSERT INTO new_order_detail(order_id, book_id, count, price) "
+                        "VALUES(?, ?, ?, ?);",
+                        (uid, book_id, count, price))
+
+            self.conn.execute(
+                "INSERT INTO new_order(order_id, store_id, user_id) "
+                "VALUES(?, ?, ?);",
+                (uid, store_id, user_id))
+            self.conn.commit()
+            order_id = uid
+        except sqlite.Error as e:
+            logging.info("528, {}".format(str(e)))
+            return 528, "{}".format(str(e)), ""
+        except BaseException as e:
+            logging.info("530, {}".format(str(e)))
+            return 530, "{}".format(str(e)), ""
+
+        return 200, "ok", order_id
+
+    def payment(self, user_id: str, password: str, order_id: str) -> (int, str):
+        conn = self.conn
+        try:
+            cursor = conn.execute("SELECT order_id, user_id, store_id FROM new_order WHERE order_id = ?", (order_id,))
+            row = cursor.fetchone()
+            if row is None:
+                return error.error_invalid_order_id(order_id)
+
+            order_id = row[0]
+            buyer_id = row[1]
+            store_id = row[2]
+
+            if buyer_id != user_id:
+                return error.error_authorization_fail()
+
+            cursor = conn.execute("SELECT balance, password FROM user WHERE user_id = ?;", (buyer_id,))
+            row = cursor.fetchone()
+            if row is None:
+                return error.error_non_exist_user_id(buyer_id)
+            balance = row[0]
+            if password != row[1]:
+                return error.error_authorization_fail()
+
+            cursor = conn.execute("SELECT store_id, user_id FROM user_store WHERE store_id = ?;", (store_id,))
+            row = cursor.fetchone()
+            if row is None:
+                return error.error_non_exist_store_id(store_id)
+
+            seller_id = row[1]
+
+            if not self.user_id_exist(seller_id):
+                return error.error_non_exist_user_id(seller_id)
+
+            cursor = conn.execute("SELECT book_id, count, price FROM new_order_detail WHERE order_id = ?;", (order_id,))
+            total_price = 0
+            for row in cursor:
+                count = row[1]
+                price = row[2]
+                total_price = total_price + price * count
+
+            if balance < total_price:
+                return error.error_not_sufficient_funds(order_id)
+
+            cursor = conn.execute("UPDATE user set balance = balance - ?"
+                                  "WHERE user_id = ? AND balance >= ?",
+                                  (total_price, buyer_id, total_price))
+            if cursor.rowcount == 0:
+                return error.error_not_sufficient_funds(order_id)
+
+            cursor = conn.execute("UPDATE user set balance = balance + ?"
+                                  "WHERE user_id = ?",
+                                  (total_price, buyer_id))
+
+            if cursor.rowcount == 0:
+                return error.error_non_exist_user_id(buyer_id)
+
+            cursor = conn.execute("DELETE FROM new_order WHERE order_id = ?", (order_id, ))
+            if cursor.rowcount == 0:
+                return error.error_invalid_order_id(order_id)
+
+            cursor = conn.execute("DELETE FROM new_order_detail where order_id = ?", (order_id, ))
+            if cursor.rowcount == 0:
+                return error.error_invalid_order_id(order_id)
+
+            conn.commit()
+
+        except sqlite.Error as e:
+            return 528, "{}".format(str(e))
+
+        except BaseException as e:
+            return 530, "{}".format(str(e))
+
+        return 200, "ok"
+
+    def add_funds(self, user_id, password, add_value) -> (int, str):
+        try:
+            cursor = self.conn.execute("SELECT password  from user where user_id=?", (user_id,))
+            row = cursor.fetchone()
+            if row is None:
+                return error.error_authorization_fail()
+
+            if row[0] != password:
+                return error.error_authorization_fail()
+
+            cursor = self.conn.execute(
+                "UPDATE user SET balance = balance + ? WHERE user_id = ?",
+                (add_value, user_id))
+            if cursor.rowcount == 0:
+                return error.error_non_exist_user_id(user_id)
+
+            self.conn.commit()
+        except sqlite.Error as e:
+            return 528, "{}".format(str(e))
+        except BaseException as e:
+            return 530, "{}".format(str(e))
+
+        return 200, "ok"
diff --git a/be/model/db_conn.py b/be/model/db_conn.py
new file mode 100644
index 0000000..3b0fbaf
--- /dev/null
+++ b/be/model/db_conn.py
@@ -0,0 +1,30 @@
+from be.model import store
+
+
+class DBConn:
+    def __init__(self):
+        self.conn = store.get_db_conn()
+
+    def user_id_exist(self, user_id):
+        cursor = self.conn.execute("SELECT user_id FROM user WHERE user_id = ?;", (user_id,))
+        row = cursor.fetchone()
+        if row is None:
+            return False
+        else:
+            return True
+
+    def book_id_exist(self, store_id, book_id):
+        cursor = self.conn.execute("SELECT book_id FROM store WHERE store_id = ? AND book_id = ?;", (store_id, book_id))
+        row = cursor.fetchone()
+        if row is None:
+            return False
+        else:
+            return True
+
+    def store_id_exist(self, store_id):
+        cursor = self.conn.execute("SELECT store_id FROM user_store WHERE store_id = ?;", (store_id,))
+        row = cursor.fetchone()
+        if row is None:
+            return False
+        else:
+            return True
diff --git a/be/model/error.py b/be/model/error.py
new file mode 100644
index 0000000..d78ab55
--- /dev/null
+++ b/be/model/error.py
@@ -0,0 +1,66 @@
+
+error_code = {
+    401: "authorization fail.",
+    511: "non exist user id {}",
+    512: "exist user id {}",
+    513: "non exist store id {}",
+    514: "exist store id {}",
+    515: "non exist book id {}",
+    516: "exist book id {}",
+    517: "stock level low, book id {}",
+    518: "invalid order id {}",
+    519: "not sufficient funds, order id {}",
+    520: "",
+    521: "",
+    522: "",
+    523: "",
+    524: "",
+    525: "",
+    526: "",
+    527: "",
+    528: "",
+}
+
+
+def error_non_exist_user_id(user_id):
+    return 511, error_code[511].format(user_id)
+
+
+def error_exist_user_id(user_id):
+    return 512, error_code[512].format(user_id)
+
+
+def error_non_exist_store_id(store_id):
+    return 513, error_code[513].format(store_id)
+
+
+def error_exist_store_id(store_id):
+    return 514, error_code[514].format(store_id)
+
+
+def error_non_exist_book_id(book_id):
+    return 515,  error_code[515].format(book_id)
+
+
+def error_exist_book_id(book_id):
+    return 516,  error_code[516].format(book_id)
+
+
+def error_stock_level_low(book_id):
+    return 517, error_code[517].format(book_id)
+
+
+def error_invalid_order_id(order_id):
+    return 518, error_code[518].format(order_id)
+
+
+def error_not_sufficient_funds(order_id):
+    return 519, error_code[518].format(order_id)
+
+
+def error_authorization_fail():
+    return 401, error_code[401]
+
+
+def error_and_message(code, message):
+    return code, message
diff --git a/be/model/seller.py b/be/model/seller.py
new file mode 100644
index 0000000..2cf47aa
--- /dev/null
+++ b/be/model/seller.py
@@ -0,0 +1,60 @@
+import sqlite3 as sqlite
+from be.model import error
+from be.model import db_conn
+
+
+class Seller(db_conn.DBConn):
+
+    def __init__(self):
+        db_conn.DBConn.__init__(self)
+
+    def add_book(self, user_id: str, store_id: str, book_id: str, book_json_str: str, stock_level: int):
+        try:
+            if not self.user_id_exist(user_id):
+                return error.error_non_exist_user_id(user_id)
+            if not self.store_id_exist(store_id):
+                return error.error_non_exist_store_id(store_id)
+            if self.book_id_exist(store_id, book_id):
+                return error.error_exist_book_id(book_id)
+
+            self.conn.execute("INSERT into store(store_id, book_id, book_info, stock_level)"
+                              "VALUES (?, ?, ?, ?)", (store_id, book_id, book_json_str, stock_level))
+            self.conn.commit()
+        except sqlite.Error as e:
+            return 528, "{}".format(str(e))
+        except BaseException as e:
+            return 530, "{}".format(str(e))
+        return 200, "ok"
+
+    def add_stock_level(self, user_id: str, store_id: str, book_id: str, add_stock_level: int):
+        try:
+            if not self.user_id_exist(user_id):
+                return error.error_non_exist_user_id(user_id)
+            if not self.store_id_exist(store_id):
+                return error.error_non_exist_store_id(store_id)
+            if not self.book_id_exist(store_id, book_id):
+                return error.error_non_exist_book_id(book_id)
+
+            self.conn.execute("UPDATE store SET stock_level = stock_level + ? "
+                              "WHERE store_id = ? AND book_id = ?", (add_stock_level, store_id, book_id))
+            self.conn.commit()
+        except sqlite.Error as e:
+            return 528, "{}".format(str(e))
+        except BaseException as e:
+            return 530, "{}".format(str(e))
+        return 200, "ok"
+
+    def create_store(self, user_id: str, store_id: str) -> (int, str):
+        try:
+            if not self.user_id_exist(user_id):
+                return error.error_non_exist_user_id(user_id)
+            if self.store_id_exist(store_id):
+                return error.error_exist_store_id(store_id)
+            self.conn.execute("INSERT into user_store(store_id, user_id)"
+                              "VALUES (?, ?)", (store_id, user_id))
+            self.conn.commit()
+        except sqlite.Error as e:
+            return 528, "{}".format(str(e))
+        except BaseException as e:
+            return 530, "{}".format(str(e))
+        return 200, "ok"
diff --git a/be/model/store.py b/be/model/store.py
new file mode 100644
index 0000000..d82aeeb
--- /dev/null
+++ b/be/model/store.py
@@ -0,0 +1,63 @@
+import logging
+import os
+import sqlite3 as sqlite
+
+
+class Store:
+    database: str
+
+    def __init__(self, db_path):
+        self.database = os.path.join(db_path, "be.db")
+        self.init_tables()
+
+    def init_tables(self):
+        try:
+            conn = self.get_db_conn()
+            conn.execute(
+                "CREATE TABLE IF NOT EXISTS user ("
+                "user_id TEXT PRIMARY KEY, password TEXT NOT NULL, "
+                "balance INTEGER NOT NULL, token TEXT, terminal TEXT);"
+            )
+
+            conn.execute(
+                "CREATE TABLE IF NOT EXISTS user_store("
+                "user_id TEXT, store_id, PRIMARY KEY(user_id, store_id));"
+            )
+
+            conn.execute(
+                "CREATE TABLE IF NOT EXISTS store( "
+                "store_id TEXT, book_id TEXT, book_info TEXT, stock_level INTEGER,"
+                " PRIMARY KEY(store_id, book_id))"
+            )
+
+            conn.execute(
+                "CREATE TABLE IF NOT EXISTS new_order( "
+                "order_id TEXT PRIMARY KEY, user_id TEXT, store_id TEXT)"
+            )
+
+            conn.execute(
+                "CREATE TABLE IF NOT EXISTS new_order_detail( "
+                "order_id TEXT, book_id TEXT, count INTEGER, price INTEGER,  "
+                "PRIMARY KEY(order_id, book_id))"
+            )
+
+            conn.commit()
+        except sqlite.Error as e:
+            logging.error(e)
+            conn.rollback()
+
+    def get_db_conn(self) -> sqlite.Connection:
+        return sqlite.connect(self.database)
+
+
+database_instance: Store = None
+
+
+def init_database(db_path):
+    global database_instance
+    database_instance = Store(db_path)
+
+
+def get_db_conn():
+    global database_instance
+    return database_instance.get_db_conn()
diff --git a/be/model/user.py b/be/model/user.py
new file mode 100644
index 0000000..acd58c2
--- /dev/null
+++ b/be/model/user.py
@@ -0,0 +1,169 @@
+import jwt
+import time
+import logging
+import sqlite3 as sqlite
+from be.model import error
+from be.model import db_conn
+
+# encode a json string like:
+#   {
+#       "user_id": [user name],
+#       "terminal": [terminal code],
+#       "timestamp": [ts]} to a JWT
+#   }
+
+
+def jwt_encode(user_id: str, terminal: str) -> str:
+    encoded = jwt.encode(
+        {"user_id": user_id, "terminal": terminal, "timestamp": time.time()},
+        key=user_id,
+        algorithm="HS256",
+    )
+    return encoded.encode("utf-8").decode("utf-8")
+
+
+# decode a JWT to a json string like:
+#   {
+#       "user_id": [user name],
+#       "terminal": [terminal code],
+#       "timestamp": [ts]} to a JWT
+#   }
+def jwt_decode(encoded_token, user_id: str) -> str:
+    decoded = jwt.decode(encoded_token, key=user_id, algorithms="HS256")
+    return decoded
+
+
+class User(db_conn.DBConn):
+    token_lifetime: int = 3600  # 3600 second
+
+    def __init__(self):
+        db_conn.DBConn.__init__(self)
+
+    def __check_token(self, user_id, db_token, token) -> bool:
+        try:
+            if db_token != token:
+                return False
+            jwt_text = jwt_decode(encoded_token=token, user_id=user_id)
+            ts = jwt_text["timestamp"]
+            if ts is not None:
+                now = time.time()
+                if self.token_lifetime > now - ts >= 0:
+                    return True
+        except jwt.exceptions.InvalidSignatureError as e:
+            logging.error(str(e))
+            return False
+
+    def register(self, user_id: str, password: str):
+        try:
+            terminal = "terminal_{}".format(str(time.time()))
+            token = jwt_encode(user_id, terminal)
+            self.conn.execute(
+                "INSERT into user(user_id, password, balance, token, terminal) "
+                "VALUES (?, ?, ?, ?, ?);",
+                (user_id, password, 0, token, terminal), )
+            self.conn.commit()
+        except sqlite.Error:
+            return error.error_exist_user_id(user_id)
+        return 200, "ok"
+
+    def check_token(self, user_id: str, token: str) -> (int, str):
+        cursor = self.conn.execute("SELECT token from user where user_id=?", (user_id,))
+        row = cursor.fetchone()
+        if row is None:
+            return error.error_authorization_fail()
+        db_token = row[0]
+        if not self.__check_token(user_id, db_token, token):
+            return error.error_authorization_fail()
+        return 200, "ok"
+
+    def check_password(self, user_id: str, password: str) -> (int, str):
+        cursor = self.conn.execute("SELECT password from user where user_id=?", (user_id,))
+        row = cursor.fetchone()
+        if row is None:
+            return error.error_authorization_fail()
+
+        if password != row[0]:
+            return error.error_authorization_fail()
+
+        return 200, "ok"
+
+    def login(self, user_id: str, password: str, terminal: str) -> (int, str, str):
+        token = ""
+        try:
+            code, message = self.check_password(user_id, password)
+            if code != 200:
+                return code, message, ""
+
+            token = jwt_encode(user_id, terminal)
+            cursor = self.conn.execute(
+                "UPDATE user set token= ? , terminal = ? where user_id = ?",
+                (token, terminal, user_id), )
+            if cursor.rowcount == 0:
+                return error.error_authorization_fail() + ("", )
+            self.conn.commit()
+        except sqlite.Error as e:
+            return 528, "{}".format(str(e)), ""
+        except BaseException as e:
+            return 530, "{}".format(str(e)), ""
+        return 200, "ok", token
+
+    def logout(self, user_id: str, token: str) -> bool:
+        try:
+            code, message = self.check_token(user_id, token)
+            if code != 200:
+                return code, message
+
+            terminal = "terminal_{}".format(str(time.time()))
+            dummy_token = jwt_encode(user_id, terminal)
+
+            cursor = self.conn.execute(
+                "UPDATE user SET token = ?, terminal = ? WHERE user_id=?",
+                (dummy_token, terminal, user_id), )
+            if cursor.rowcount == 0:
+                return error.error_authorization_fail()
+
+            self.conn.commit()
+        except sqlite.Error as e:
+            return 528, "{}".format(str(e))
+        except BaseException as e:
+            return 530, "{}".format(str(e))
+        return 200, "ok"
+
+    def unregister(self, user_id: str, password: str) -> (int, str):
+        try:
+            code, message = self.check_password(user_id, password)
+            if code != 200:
+                return code, message
+
+            cursor = self.conn.execute("DELETE from user where user_id=?", (user_id,))
+            if cursor.rowcount == 1:
+                self.conn.commit()
+            else:
+                return error.error_authorization_fail()
+        except sqlite.Error as e:
+            return 528, "{}".format(str(e))
+        except BaseException as e:
+            return 530, "{}".format(str(e))
+        return 200, "ok"
+
+    def change_password(self, user_id: str, old_password: str, new_password: str) -> bool:
+        try:
+            code, message = self.check_password(user_id, old_password)
+            if code != 200:
+                return code, message
+
+            terminal = "terminal_{}".format(str(time.time()))
+            token = jwt_encode(user_id, terminal)
+            cursor = self.conn.execute(
+                "UPDATE user set password = ?, token= ? , terminal = ? where user_id = ?",
+                (new_password, token, terminal, user_id), )
+            if cursor.rowcount == 0:
+                return error.error_authorization_fail()
+
+            self.conn.commit()
+        except sqlite.Error as e:
+            return 528, "{}".format(str(e))
+        except BaseException as e:
+            return 530, "{}".format(str(e))
+        return 200, "ok"
+
diff --git a/be/serve.py b/be/serve.py
new file mode 100644
index 0000000..6499a7c
--- /dev/null
+++ b/be/serve.py
@@ -0,0 +1,46 @@
+import logging
+import os
+from flask import Flask
+from flask import Blueprint
+from flask import request
+from be.view import auth
+from be.view import seller
+from be.view import buyer
+from be.model.store import init_database
+
+bp_shutdown = Blueprint("shutdown", __name__)
+
+
+def shutdown_server():
+    func = request.environ.get("werkzeug.server.shutdown")
+    if func is None:
+        raise RuntimeError("Not running with the Werkzeug Server")
+    func()
+
+
+@bp_shutdown.route("/shutdown")
+def be_shutdown():
+    shutdown_server()
+    return "Server shutting down..."
+
+
+def be_run():
+    this_path = os.path.dirname(__file__)
+    parent_path = os.path.dirname(this_path)
+    log_file = os.path.join(parent_path, "app.log")
+    init_database(parent_path)
+
+    logging.basicConfig(filename=log_file, level=logging.ERROR)
+    handler = logging.StreamHandler()
+    formatter = logging.Formatter(
+        "%(asctime)s [%(threadName)-12.12s] [%(levelname)-5.5s]  %(message)s"
+    )
+    handler.setFormatter(formatter)
+    logging.getLogger().addHandler(handler)
+
+    app = Flask(__name__)
+    app.register_blueprint(bp_shutdown)
+    app.register_blueprint(auth.bp_auth)
+    app.register_blueprint(seller.bp_seller)
+    app.register_blueprint(buyer.bp_buyer)
+    app.run()
diff --git a/be/view/__init__.py b/be/view/__init__.py
new file mode 100644
index 0000000..e5a0d9b
--- /dev/null
+++ b/be/view/__init__.py
@@ -0,0 +1 @@
+#!/usr/bin/env python3
diff --git a/be/view/auth.py b/be/view/auth.py
new file mode 100644
index 0000000..8d9528a
--- /dev/null
+++ b/be/view/auth.py
@@ -0,0 +1,53 @@
+from flask import Blueprint
+from flask import request
+from flask import jsonify
+from be.model import user
+
+bp_auth = Blueprint("auth", __name__, url_prefix="/auth")
+
+
+@bp_auth.route("/login", methods=["POST"])
+def login():
+    user_id = request.json.get("user_id", "")
+    password = request.json.get("password", "")
+    terminal = request.json.get("terminal", "")
+    u = user.User()
+    code, message, token = u.login(user_id=user_id, password=password, terminal=terminal)
+    return jsonify({"message": message, "token": token}), code
+
+
+@bp_auth.route("/logout", methods=["POST"])
+def logout():
+    user_id: str = request.json.get("user_id")
+    token: str = request.headers.get("token")
+    u = user.User()
+    code, message = u.logout(user_id=user_id, token=token)
+    return jsonify({"message": message}), code
+
+
+@bp_auth.route("/register", methods=["POST"])
+def register():
+    user_id = request.json.get("user_id", "")
+    password = request.json.get("password", "")
+    u = user.User()
+    code, message = u.register(user_id=user_id, password=password)
+    return jsonify({"message": message}), code
+
+
+@bp_auth.route("/unregister", methods=["POST"])
+def unregister():
+    user_id = request.json.get("user_id", "")
+    password = request.json.get("password", "")
+    u = user.User()
+    code, message = u.unregister(user_id=user_id, password=password)
+    return jsonify({"message": message}), code
+
+
+@bp_auth.route("/password", methods=["POST"])
+def change_password():
+    user_id = request.json.get("user_id", "")
+    old_password = request.json.get("oldPassword", "")
+    new_password = request.json.get("newPassword", "")
+    u = user.User()
+    code, message = u.change_password(user_id=user_id, old_password=old_password, new_password=new_password)
+    return jsonify({"message": message}), code
diff --git a/be/view/buyer.py b/be/view/buyer.py
new file mode 100644
index 0000000..799b4dd
--- /dev/null
+++ b/be/view/buyer.py
@@ -0,0 +1,42 @@
+from flask import Blueprint
+from flask import request
+from flask import jsonify
+from be.model.buyer import Buyer
+
+bp_buyer = Blueprint("buyer", __name__, url_prefix="/buyer")
+
+
+@bp_buyer.route("/new_order", methods=["POST"])
+def new_order():
+    user_id: str = request.json.get("user_id")
+    store_id: str = request.json.get("store_id")
+    books: [] = request.json.get("books")
+    id_and_count = []
+    for book in books:
+        book_id = book.get("id")
+        count = book.get("count")
+        id_and_count.append((book_id, count))
+
+    b = Buyer()
+    code, message, order_id = b.new_order(user_id, store_id, id_and_count)
+    return jsonify({"message": message, "order_id": order_id}), code
+
+
+@bp_buyer.route("/payment", methods=["POST"])
+def payment():
+    user_id: str = request.json.get("user_id")
+    order_id: str = request.json.get("order_id")
+    password: str = request.json.get("password")
+    b = Buyer()
+    code, message = b.payment(user_id, password, order_id)
+    return jsonify({"message": message}), code
+
+
+@bp_buyer.route("/add_funds", methods=["POST"])
+def add_funds():
+    user_id = request.json.get("user_id")
+    password = request.json.get("password")
+    add_value = request.json.get("add_value")
+    b = Buyer()
+    code, message = b.add_funds(user_id, password, add_value)
+    return jsonify({"message": message}), code
diff --git a/be/view/seller.py b/be/view/seller.py
new file mode 100644
index 0000000..f8a9092
--- /dev/null
+++ b/be/view/seller.py
@@ -0,0 +1,42 @@
+from flask import Blueprint
+from flask import request
+from flask import jsonify
+from be.model import seller
+import json
+
+bp_seller = Blueprint("seller", __name__, url_prefix="/seller")
+
+
+@bp_seller.route("/create_store", methods=["POST"])
+def seller_create_store():
+    user_id: str = request.json.get("user_id")
+    store_id: str = request.json.get("store_id")
+    s = seller.Seller()
+    code, message = s.create_store(user_id, store_id)
+    return jsonify({"message": message}), code
+
+
+@bp_seller.route("/add_book", methods=["POST"])
+def seller_add_book():
+    user_id: str = request.json.get("user_id")
+    store_id: str = request.json.get("store_id")
+    book_info: str = request.json.get("book_info")
+    stock_level: str = request.json.get("stock_level", 0)
+
+    s = seller.Seller()
+    code, message = s.add_book(user_id, store_id, book_info.get("id"), json.dumps(book_info), stock_level)
+
+    return jsonify({"message": message}), code
+
+
+@bp_seller.route("/add_stock_level", methods=["POST"])
+def add_stock_level():
+    user_id: str = request.json.get("user_id")
+    store_id: str = request.json.get("store_id")
+    book_id: str = request.json.get("book_id")
+    add_num: str = request.json.get("add_stock_level", 0)
+
+    s = seller.Seller()
+    code, message = s.add_stock_level(user_id, store_id, book_id, add_num)
+
+    return jsonify({"message": message}), code
diff --git a/doc/auth.md b/doc/auth.md
new file mode 100644
index 0000000..ba7bc4b
--- /dev/null
+++ b/doc/auth.md
@@ -0,0 +1,213 @@
+## 注册用户
+
+#### URL：
+POST http://$address$/auth/register
+
+#### Request
+
+Body:
+```
+{
+    "user_id":"$user name$",
+    "password":"$user password$"
+}
+```
+
+变量名 | 类型 | 描述 | 是否可为空
+---|---|---|---
+user_id | string | 用户名 | N
+password | string | 登陆密码 | N
+
+#### Response
+
+Status Code:
+
+
+码 | 描述
+--- | ---
+200 | 注册成功
+5XX | 注册失败，用户名重复
+
+Body:
+```
+{
+    "message":"$error message$"
+}
+```
+变量名 | 类型 | 描述 | 是否可为空
+---|---|---|---
+message | string | 返回错误消息，成功时为"ok" | N
+
+## 注销用户
+
+#### URL：
+POST http://$address$/auth/unregister
+
+#### Request
+
+Body:
+```
+{
+    "user_id":"$user name$",
+    "password":"$user password$"
+}
+```
+
+变量名 | 类型 | 描述 | 是否可为空
+---|---|---|---
+user_id | string | 用户名 | N
+password | string | 登陆密码 | N
+
+#### Response
+
+Status Code:
+
+
+码 | 描述
+--- | ---
+200 | 注销成功
+401 | 注销失败，用户名不存在或密码不正确
+
+
+Body:
+```
+{
+    "message":"$error message$"
+}
+```
+变量名 | 类型 | 描述 | 是否可为空
+---|---|---|---
+message | string | 返回错误消息，成功时为"ok" | N
+
+## 用户登录
+
+#### URL：
+POST http://$address$/auth/login
+
+#### Request
+
+Body:
+```
+{
+    "user_id":"$user name$",
+    "password":"$user password$",
+    "terminal":"$terminal code$"
+}
+```
+
+变量名 | 类型 | 描述 | 是否可为空
+---|---|---|---
+user_id | string | 用户名 | N
+password | string | 登陆密码 | N
+terminal | string | 终端代码 | N
+
+#### Response
+
+Status Code:
+
+码 | 描述
+--- | ---
+200 | 登录成功
+401 | 登录失败，用户名或密码错误
+
+Body:
+```
+{
+    "message":"$error message$",
+    "token":"$access token$"
+}
+```
+变量名 | 类型 | 描述 | 是否可为空
+---|---|---|---
+message | string | 返回错误消息，成功时为"ok" | N
+token | string | 访问token，用户登录后每个需要授权的请求应在headers中传入这个token | 成功时不为空
+
+#### 说明 
+
+1.terminal标识是哪个设备登录的，不同的设备拥有不同的ID，测试时可以随机生成。 
+
+2.token是登录后，在客户端中缓存的令牌，在用户登录时由服务端生成，用户在接下来的访问请求时不需要密码。token会定期地失效，对于不同的设备，token是不同的。token只对特定的时期特定的设备是有效的。
+
+## 用户更改密码
+
+#### URL：
+POST http://$address$/auth/password
+
+#### Request
+
+Body:
+```
+{
+    "user_id":"$user name$",
+    "oldPassword":"$old password$",
+    "newPassword":"$new password$"
+}
+```
+
+变量名 | 类型 | 描述 | 是否可为空
+---|---|---|---
+user_id | string | 用户名 | N
+oldPassword | string | 旧的登陆密码 | N
+newPassword | string | 新的登陆密码 | N
+
+#### Response
+
+Status Code:
+
+码 | 描述
+--- | ---
+200 | 更改密码成功
+401 | 更改密码失败
+
+Body:
+```
+{
+    "message":"$error message$",
+}
+```
+变量名 | 类型 | 描述 | 是否可为空
+---|---|---|---
+message | string | 返回错误消息，成功时为"ok" | N
+
+## 用户登出
+
+#### URL：
+POST http://$address$/auth/logout
+
+#### Request
+
+Headers:
+
+key | 类型 | 描述
+---|---|---
+token | string | 访问token
+
+Body:
+```
+{
+    "user_id":"$user name$"
+}
+```
+
+变量名 | 类型 | 描述 | 是否可为空
+---|---|---|---
+user_id | string | 用户名 | N
+
+#### Response
+
+Status Code:
+
+码 | 描述
+--- | ---
+200 | 登出成功
+401 | 登出失败，用户名或token错误
+
+Body:
+```
+{
+    "message":"$error message$"
+}
+```
+变量名 | 类型 | 描述 | 是否可为空
+---|---|---|---
+message | string | 返回错误消息，成功时为"ok" | N
diff --git a/doc/buyer.md b/doc/buyer.md
new file mode 100644
index 0000000..5f415d2
--- /dev/null
+++ b/doc/buyer.md
@@ -0,0 +1,144 @@
+## 买家下单
+
+#### URL：
+POST http://[address]/buyer/new_order
+
+#### Request
+
+##### Header:
+
+key | 类型 | 描述 | 是否可为空
+---|---|---|---
+token | string | 登录产生的会话标识 | N
+
+##### Body:
+```json
+{
+  "user_id": "buyer_id",
+  "store_id": "store_id",
+  "books": [
+    {
+      "id": "1000067",
+      "count": 1
+    },
+    {
+      "id": "1000134",
+      "count": 4
+    }
+  ]
+}
+```
+
+##### 属性说明：
+
+变量名 | 类型 | 描述 | 是否可为空
+---|---|---|---
+user_id | string | 买家用户ID | N
+store_id | string | 商铺ID | N
+books | class | 书籍购买列表 | N
+
+books数组：
+
+变量名 | 类型 | 描述 | 是否可为空
+---|---|---|---
+id | string | 书籍的ID | N
+count | string | 购买数量 | N
+
+
+#### Response
+
+Status Code:
+
+码 | 描述
+--- | ---
+200 | 下单成功
+5XX | 买家用户ID不存在
+5XX | 商铺ID不存在
+5XX | 购买的图书不存在
+5XX | 商品库存不足
+
+##### Body:
+```json
+{
+  "order_id": "uuid"
+}
+```
+
+##### 属性说明：
+
+变量名 | 类型 | 描述 | 是否可为空
+---|---|---|---
+order_id | string | 订单号，只有返回200时才有效 | N
+
+
+## 买家付款
+
+#### URL：
+POST http://[address]/buyer/payment
+
+#### Request
+
+##### Body:
+```json
+{
+  "user_id": "buyer_id",
+  "order_id": "order_id",
+  "password": "password"
+}
+```
+
+##### 属性说明：
+
+变量名 | 类型 | 描述 | 是否可为空
+---|---|---|---
+user_id | string | 买家用户ID | N
+order_id | string | 订单ID | N
+password | string | 买家用户密码 | N 
+
+
+#### Response
+
+Status Code:
+
+码 | 描述
+--- | ---
+200 | 付款成功
+5XX | 账户余额不足
+5XX | 无效参数
+401 | 授权失败 
+
+
+## 买家充值
+
+#### URL：
+POST http://[address]/buyer/add_funds
+
+#### Request
+
+
+
+##### Body:
+```json
+{
+  "user_id": "user_id",
+  "password": "password",
+  "add_value": 10
+}
+```
+
+##### 属性说明：
+
+key | 类型 | 描述 | 是否可为空
+---|---|---|---
+user_id | string | 买家用户ID | N
+password | string | 用户密码 | N
+add_value | int | 充值金额，以分为单位 | N
+
+
+Status Code:
+
+码 | 描述
+--- | ---
+200 | 充值成功
+401 | 授权失败
+5XX | 无效参数
diff --git a/doc/seller.md b/doc/seller.md
new file mode 100644
index 0000000..0513122
--- /dev/null
+++ b/doc/seller.md
@@ -0,0 +1,178 @@
+## 创建商铺
+
+
+
+#### URL
+
+POST http://[address]/seller/create_store
+
+#### Request
+Headers:
+
+key | 类型 | 描述 | 是否可为空
+---|---|---|---
+token | string | 登录产生的会话标识 | N
+
+Body:
+
+```json
+{
+  "user_id": "$seller id$",
+  "store_id": "$store id$"
+}
+```
+
+key | 类型 | 描述 | 是否可为空
+---|---|---|---
+user_id | string | 卖家用户ID | N
+store_id | string | 商铺ID | N
+
+#### Response
+
+Status Code:
+
+码 | 描述
+--- | ---
+200 | 创建商铺成功
+5XX | 商铺ID已存在
+
+
+## 商家添加书籍信息
+
+#### URL：
+POST http://[address]/seller/add_book
+
+#### Request
+Headers:
+
+key | 类型 | 描述 | 是否可为空
+---|---|---|---
+token | string | 登录产生的会话标识 | N
+
+Body:
+
+```json
+{
+  "user_id": "$seller user id$",
+  "store_id": "$store id$",
+  "book_info": {
+    "tags": [
+      "tags1",
+      "tags2",
+      "tags3",
+      "..."
+    ],
+    "pictures": [
+      "$Base 64 encoded bytes array1$",
+      "$Base 64 encoded bytes array2$",
+      "$Base 64 encoded bytes array3$",
+      "..."
+    ],
+    "id": "$book id$",
+    "title": "$book title$",
+    "author": "$book author$",
+    "publisher": "$book publisher$",
+    "original_title": "$original title$",
+    "translator": "translater",
+    "pub_year": "$pub year$",
+    "pages": 10,
+    "price": 10,
+    "binding": "平装",
+    "isbn": "$isbn$",
+    "author_intro": "$author introduction$",
+    "book_intro": "$book introduction$",
+    "content": "$chapter1 ...$"
+  },
+  "stock_level": 0
+}
+
+```
+
+属性说明：
+
+变量名 | 类型 | 描述 | 是否可为空
+---|---|---|---
+user_id | string | 卖家用户ID | N
+store_id | string | 商铺ID | N
+book_info | class | 书籍信息 | N
+stock_level | int | 初始库存，大于等于0 | N
+
+book_info类：
+
+变量名 | 类型 | 描述 | 是否可为空
+---|---|---|---
+id | string | 书籍ID | N
+title | string | 书籍题目 | N
+author | string | 作者 | Y
+publisher | string | 出版社 | Y
+original_title | string | 原书题目 | Y
+translator | string | 译者 | Y
+pub_year | string | 出版年月 | Y
+pages | int | 页数 | Y
+price | int | 价格(以分为单位) | N
+binding | string | 装帧，精状/平装 | Y
+isbn | string | ISBN号 | Y
+author_intro | string | 作者简介 | Y
+book_intro | string | 书籍简介 | Y
+content | string | 样章试读 | Y
+tags | array | 标签 | Y
+pictures | array | 照片 | Y
+
+tags和pictures：
+
+    tags 中每个数组元素都是string类型  
+    picture 中每个数组元素都是string（base64表示的bytes array）类型
+
+
+#### Response
+
+Status Code:
+
+码 | 描述
+--- | ---
+200 | 添加图书信息成功
+5XX | 卖家用户ID不存在
+5XX | 商铺ID不存在
+5XX | 图书ID已存在
+
+
+## 商家添加书籍库存
+
+
+#### URL
+
+POST http://[address]/seller/add_stock_level
+
+#### Request
+Headers:
+
+key | 类型 | 描述 | 是否可为空
+---|---|---|---
+token | string | 登录产生的会话标识 | N
+
+Body:
+
+```json
+{
+  "user_id": "$seller id$",
+  "store_id": "$store id$",
+  "book_id": "$book id$",
+  "add_stock_level": 10
+}
+```
+key | 类型 | 描述 | 是否可为空
+---|---|---|---
+user_id | string | 卖家用户ID | N
+store_id | string | 商铺ID | N
+book_id | string | 书籍ID | N
+add_stock_level | int | 增加的库存量 | N
+
+#### Response
+
+Status Code:
+
+码 | 描述
+--- | :--
+200 | 创建商铺成功
+5XX | 商铺ID不存在 
+5XX | 图书ID不存在 
diff --git a/fe/__init__.py b/fe/__init__.py
new file mode 100644
index 0000000..e5a0d9b
--- /dev/null
+++ b/fe/__init__.py
@@ -0,0 +1 @@
+#!/usr/bin/env python3
diff --git a/fe/access/__init__.py b/fe/access/__init__.py
new file mode 100644
index 0000000..e5a0d9b
--- /dev/null
+++ b/fe/access/__init__.py
@@ -0,0 +1 @@
+#!/usr/bin/env python3
diff --git a/fe/access/auth.py b/fe/access/auth.py
new file mode 100644
index 0000000..04309fb
--- /dev/null
+++ b/fe/access/auth.py
@@ -0,0 +1,49 @@
+import requests
+from urllib.parse import urljoin
+
+
+class Auth:
+    def __init__(self, url_prefix):
+        self.url_prefix = urljoin(url_prefix, "auth/")
+
+    def login(self, user_id: str, password: str, terminal: str) -> (int, str):
+        json = {"user_id": user_id, "password": password, "terminal": terminal}
+        url = urljoin(self.url_prefix, "login")
+        r = requests.post(url, json=json)
+        return r.status_code, r.json().get("token")
+
+    def register(
+        self,
+        user_id: str,
+        password: str
+    ) -> int:
+        json = {
+            "user_id": user_id,
+            "password": password
+        }
+        url = urljoin(self.url_prefix, "register")
+        r = requests.post(url, json=json)
+        return r.status_code
+
+    def password(self, user_id: str, old_password: str, new_password: str) -> int:
+        json = {
+            "user_id": user_id,
+            "oldPassword": old_password,
+            "newPassword": new_password,
+        }
+        url = urljoin(self.url_prefix, "password")
+        r = requests.post(url, json=json)
+        return r.status_code
+
+    def logout(self, user_id: str, token: str) -> int:
+        json = {"user_id": user_id}
+        headers = {"token": token}
+        url = urljoin(self.url_prefix, "logout")
+        r = requests.post(url, headers=headers, json=json)
+        return r.status_code
+
+    def unregister(self, user_id: str, password: str) -> int:
+        json = {"user_id": user_id, "password": password}
+        url = urljoin(self.url_prefix, "unregister")
+        r = requests.post(url, json=json)
+        return r.status_code
diff --git a/fe/access/book.py b/fe/access/book.py
new file mode 100644
index 0000000..5dc6347
--- /dev/null
+++ b/fe/access/book.py
@@ -0,0 +1,97 @@
+import os
+import sqlite3 as sqlite
+import random
+import base64
+import simplejson as json
+
+
+class Book:
+    id: str
+    title: str
+    author: str
+    publisher: str
+    original_title: str
+    translator: str
+    pub_year: str
+    pages: int
+    price: int
+    binding: str
+    isbn: str
+    author_intro: str
+    book_intro: str
+    content: str
+    tags: [str]
+    pictures: [bytes]
+
+    def __init__(self):
+        self.tags = []
+        self.pictures = []
+
+
+class BookDB:
+    def __init__(self, large: bool = False):
+        parent_path = os.path.dirname(os.path.dirname(__file__))
+        self.db_s = os.path.join(parent_path, "data/book.db")
+        self.db_l = os.path.join(parent_path, "data/book_lx.db")
+        if large:
+            self.book_db = self.db_l
+        else:
+            self.book_db = self.db_s
+
+    def get_book_count(self):
+        conn = sqlite.connect(self.book_db)
+        cursor = conn.execute(
+            "SELECT count(id) FROM book")
+        row = cursor.fetchone()
+        return row[0]
+
+    def get_book_info(self, start, size) -> [Book]:
+        books = []
+        conn = sqlite.connect(self.book_db)
+        cursor = conn.execute(
+            "SELECT id, title, author, "
+            "publisher, original_title, "
+            "translator, pub_year, pages, "
+            "price, currency_unit, binding, "
+            "isbn, author_intro, book_intro, "
+            "content, tags, picture FROM book ORDER BY id "
+            "LIMIT ? OFFSET ?", (size, start))
+        for row in cursor:
+            book = Book()
+            book.id = row[0]
+            book.title = row[1]
+            book.author = row[2]
+            book.publisher = row[3]
+            book.original_title = row[4]
+            book.translator = row[5]
+            book.pub_year = row[6]
+            book.pages = row[7]
+            book.price = row[8]
+
+            book.currency_unit = row[9]
+            book.binding = row[10]
+            book.isbn = row[11]
+            book.author_intro = row[12]
+            book.book_intro = row[13]
+            book.content = row[14]
+            tags = row[15]
+
+            picture = row[16]
+
+            for tag in tags.split("\n"):
+                if tag.strip() != "":
+                    book.tags.append(tag)
+            for i in range(0, random.randint(0, 9)):
+                if picture is not None:
+                    encode_str = base64.b64encode(picture).decode('utf-8')
+                    book.pictures.append(encode_str)
+            books.append(book)
+            # print(tags.decode('utf-8'))
+
+            # print(book.tags, len(book.picture))
+            # print(book)
+            # print(tags)
+
+        return books
+
+
diff --git a/fe/access/buyer.py b/fe/access/buyer.py
new file mode 100644
index 0000000..507c62a
--- /dev/null
+++ b/fe/access/buyer.py
@@ -0,0 +1,42 @@
+import requests
+import simplejson
+from urllib.parse import urljoin
+from fe.access.auth import Auth
+
+
+class Buyer:
+    def __init__(self, url_prefix, user_id, password):
+        self.url_prefix = urljoin(url_prefix, "buyer/")
+        self.user_id = user_id
+        self.password = password
+        self.token = ""
+        self.terminal = "my terminal"
+        self.auth = Auth(url_prefix)
+        code, self.token = self.auth.login(self.user_id, self.password, self.terminal)
+        assert code == 200
+
+    def new_order(self, store_id: str, book_id_and_count: [(str, int)]) -> (int, str):
+        books = []
+        for id_count_pair in book_id_and_count:
+            books.append({"id": id_count_pair[0], "count": id_count_pair[1]})
+        json = {"user_id": self.user_id, "store_id": store_id, "books": books}
+        #print(simplejson.dumps(json))
+        url = urljoin(self.url_prefix, "new_order")
+        headers = {"token": self.token}
+        r = requests.post(url, headers=headers, json=json)
+        response_json = r.json()
+        return r.status_code, response_json.get("order_id")
+
+    def payment(self,  order_id: str):
+        json = {"user_id": self.user_id, "password": self.password, "order_id": order_id}
+        url = urljoin(self.url_prefix, "payment")
+        headers = {"token": self.token}
+        r = requests.post(url, headers=headers, json=json)
+        return r.status_code
+
+    def add_funds(self, add_value: str) -> int:
+        json = {"user_id": self.user_id, "password": self.password, "add_value": add_value}
+        url = urljoin(self.url_prefix, "add_funds")
+        headers = {"token": self.token}
+        r = requests.post(url, headers=headers, json=json)
+        return r.status_code
diff --git a/fe/access/new_buyer.py b/fe/access/new_buyer.py
new file mode 100644
index 0000000..d67092a
--- /dev/null
+++ b/fe/access/new_buyer.py
@@ -0,0 +1,10 @@
+from fe import conf
+from fe.access import buyer, auth
+
+
+def register_new_buyer(user_id, password) -> buyer.Buyer:
+    a = auth.Auth(conf.URL)
+    code = a.register(user_id, password)
+    assert code == 200
+    s = buyer.Buyer(conf.URL, user_id, password)
+    return s
diff --git a/fe/access/new_seller.py b/fe/access/new_seller.py
new file mode 100644
index 0000000..0782991
--- /dev/null
+++ b/fe/access/new_seller.py
@@ -0,0 +1,10 @@
+from fe import conf
+from fe.access import seller, auth
+
+
+def register_new_seller(user_id, password) -> seller.Seller:
+    a = auth.Auth(conf.URL)
+    code = a.register(user_id, password)
+    assert code == 200
+    s = seller.Seller(conf.URL, user_id, password)
+    return s
diff --git a/fe/access/seller.py b/fe/access/seller.py
new file mode 100644
index 0000000..6e20ae8
--- /dev/null
+++ b/fe/access/seller.py
@@ -0,0 +1,52 @@
+import requests
+from urllib.parse import urljoin
+from fe.access import book
+from fe.access.auth import Auth
+
+
+class Seller:
+    def __init__(self, url_prefix, seller_id: str, password: str):
+        self.url_prefix = urljoin(url_prefix, "seller/")
+        self.seller_id = seller_id
+        self.password = password
+        self.terminal = "my terminal"
+        self.auth = Auth(url_prefix)
+        code, self.token = self.auth.login(self.seller_id, self.password, self.terminal)
+        assert code == 200
+
+    def create_store(self, store_id):
+        json = {
+            "user_id": self.seller_id,
+            "store_id": store_id,
+        }
+        #print(simplejson.dumps(json))
+        url = urljoin(self.url_prefix, "create_store")
+        headers = {"token": self.token}
+        r = requests.post(url, headers=headers, json=json)
+        return r.status_code
+
+    def add_book(self, store_id: str, stock_level: int, book_info: book.Book) -> int:
+        json = {
+            "user_id": self.seller_id,
+            "store_id": store_id,
+            "book_info": book_info.__dict__,
+            "stock_level": stock_level
+        }
+        #print(simplejson.dumps(json))
+        url = urljoin(self.url_prefix, "add_book")
+        headers = {"token": self.token}
+        r = requests.post(url, headers=headers, json=json)
+        return r.status_code
+
+    def add_stock_level(self, seller_id: str, store_id: str, book_id: str, add_stock_num: int) -> int:
+        json = {
+            "user_id": seller_id,
+            "store_id": store_id,
+            "book_id": book_id,
+            "add_stock_level": add_stock_num
+        }
+        #print(simplejson.dumps(json))
+        url = urljoin(self.url_prefix, "add_stock_level")
+        headers = {"token": self.token}
+        r = requests.post(url, headers=headers, json=json)
+        return r.status_code
diff --git a/fe/bench/__init__.py b/fe/bench/__init__.py
new file mode 100644
index 0000000..e5a0d9b
--- /dev/null
+++ b/fe/bench/__init__.py
@@ -0,0 +1 @@
+#!/usr/bin/env python3
diff --git a/fe/bench/bench.md b/fe/bench/bench.md
new file mode 100644
index 0000000..ab70cd1
--- /dev/null
+++ b/fe/bench/bench.md
@@ -0,0 +1 @@
+add performance test here
diff --git a/fe/bench/run.py b/fe/bench/run.py
new file mode 100644
index 0000000..80043db
--- /dev/null
+++ b/fe/bench/run.py
@@ -0,0 +1,22 @@
+from fe.bench.workload import Workload
+from fe.bench.session import Session
+
+
+def run_bench():
+    wl = Workload()
+    wl.gen_database()
+
+    sessions = []
+    for i in range(0, wl.session):
+        ss = Session(wl)
+        sessions.append(ss)
+
+    for ss in sessions:
+        ss.start()
+
+    for ss in sessions:
+        ss.join()
+
+
+#if __name__ == "__main__":
+#    run_bench()
\ No newline at end of file
diff --git a/fe/bench/session.py b/fe/bench/session.py
new file mode 100644
index 0000000..e0ef1df
--- /dev/null
+++ b/fe/bench/session.py
@@ -0,0 +1,53 @@
+from fe.bench.workload import Workload
+from fe.bench.workload import NewOrder
+from fe.bench.workload import Payment
+import time
+import threading
+
+
+class Session(threading.Thread):
+    def __init__(self, wl: Workload):
+        threading.Thread.__init__(self)
+        self.workload = wl
+        self.new_order_request = []
+        self.payment_request = []
+        self.payment_i = 0
+        self.new_order_i = 0
+        self.payment_ok = 0
+        self.new_order_ok = 0
+        self.time_new_order = 0
+        self.time_payment = 0
+        self.thread = None
+        self.gen_procedure()
+
+    def gen_procedure(self):
+        for i in range(0, self.workload.procedure_per_session):
+            new_order = self.workload.get_new_order()
+            self.new_order_request.append(new_order)
+
+    def run(self):
+        self.run_gut()
+
+    def run_gut(self):
+        for new_order in self.new_order_request:
+            before = time.time()
+            ok, order_id = new_order.run()
+            after = time.time()
+            self.time_new_order = self.time_new_order + after - before
+            self.new_order_i = self.new_order_i + 1
+            if ok:
+                self.new_order_ok = self.new_order_ok + 1
+                payment = Payment(new_order.buyer, order_id)
+                self.payment_request.append(payment)
+            if self.new_order_i % 100 or self.new_order_i == len(self.new_order_request):
+                self.workload.update_stat(self.new_order_i, self.payment_i, self.new_order_ok, self.payment_ok,
+                                          self.time_new_order, self.time_payment)
+                for payment in self.payment_request:
+                    before = time.time()
+                    ok = payment.run()
+                    after = time.time()
+                    self.time_payment = self.time_payment + after - before
+                    self.payment_i = self.payment_i + 1
+                    if ok:
+                        self.payment_ok = self.payment_ok + 1
+                self.payment_request = []
diff --git a/fe/bench/workload.py b/fe/bench/workload.py
new file mode 100644
index 0000000..d7c9e6e
--- /dev/null
+++ b/fe/bench/workload.py
@@ -0,0 +1,166 @@
+import logging
+import uuid
+import random
+import threading
+from fe.access import book
+from fe.access.new_seller import register_new_seller
+from fe.access.new_buyer import register_new_buyer
+from fe.access.buyer import Buyer
+from fe import conf
+
+
+class NewOrder:
+    def __init__(self, buyer: Buyer, store_id, book_id_and_count):
+        self.buyer = buyer
+        self.store_id = store_id
+        self.book_id_and_count = book_id_and_count
+
+    def run(self) -> (bool, str):
+        code, order_id = self.buyer.new_order(self.store_id, self.book_id_and_count)
+        return code == 200, order_id
+
+
+class Payment:
+    def __init__(self, buyer:Buyer, order_id):
+        self.buyer = buyer
+        self.order_id = order_id
+
+    def run(self) -> bool:
+        code = self.buyer.payment(self.order_id)
+        return code == 200
+
+
+class Workload:
+    def __init__(self):
+        self.uuid = str(uuid.uuid1())
+        self.book_ids = []
+        self.buyer_ids = []
+        self.store_ids = []
+        self.book_db = book.BookDB(conf.Use_Large_DB)
+        self.row_count = self.book_db.get_book_count()
+
+        self.book_num_per_store = conf.Book_Num_Per_Store
+        if self.row_count < self.book_num_per_store:
+            self.book_num_per_store = self.row_count
+        self.store_num_per_user = conf.Store_Num_Per_User
+        self.seller_num = conf.Seller_Num
+        self.buyer_num = conf.Buyer_Num
+        self.session = conf.Session
+        self.stock_level = conf.Default_Stock_Level
+        self.user_funds = conf.Default_User_Funds
+        self.batch_size = conf.Data_Batch_Size
+        self.procedure_per_session = conf.Request_Per_Session
+
+        self.n_new_order = 0
+        self.n_payment = 0
+        self.n_new_order_ok = 0
+        self.n_payment_ok = 0
+        self.time_new_order = 0
+        self.time_payment = 0
+        self.lock = threading.Lock()
+        # 存储上一次的值，用于两次做差
+        self.n_new_order_past = 0
+        self.n_payment_past = 0
+        self.n_new_order_ok_past = 0
+        self.n_payment_ok_past = 0
+
+    def to_seller_id_and_password(self, no: int) -> (str, str):
+        return "seller_{}_{}".format(no, self.uuid), "password_seller_{}_{}".format(no, self.uuid)
+
+    def to_buyer_id_and_password(self, no: int) -> (str, str):
+        return "buyer_{}_{}".format(no, self.uuid), "buyer_seller_{}_{}".format(no, self.uuid)
+
+    def to_store_id(self, seller_no: int, i):
+        return "store_s_{}_{}_{}".format(seller_no, i, self.uuid)
+
+    def gen_database(self):
+        logging.info("load data")
+        for i in range(1, self.seller_num + 1):
+            user_id, password = self.to_seller_id_and_password(i)
+            seller = register_new_seller(user_id, password)
+            for j in range(1, self.store_num_per_user + 1):
+                store_id = self.to_store_id(i, j)
+                code = seller.create_store(store_id)
+                assert code == 200
+                self.store_ids.append(store_id)
+                row_no = 0
+
+                while row_no < self.book_num_per_store:
+                    books = self.book_db.get_book_info(row_no, self.batch_size)
+                    if len(books) == 0:
+                        break
+                    for bk in books:
+                        code = seller.add_book(store_id, self.stock_level, bk)
+                        assert code == 200
+                        if i == 1 and j == 1:
+                            self.book_ids.append(bk.id)
+                    row_no = row_no + len(books)
+        logging.info("seller data loaded.")
+        for k in range(1, self.buyer_num + 1):
+            user_id, password = self.to_buyer_id_and_password(k)
+            buyer = register_new_buyer(user_id, password)
+            buyer.add_funds(self.user_funds)
+            self.buyer_ids.append(user_id)
+        logging.info("buyer data loaded.")
+
+    def get_new_order(self) -> NewOrder:
+        n = random.randint(1, self.buyer_num)
+        buyer_id, buyer_password = self.to_buyer_id_and_password(n)
+        store_no = int(random.uniform(0, len(self.store_ids) - 1))
+        store_id = self.store_ids[store_no]
+        books = random.randint(1, 10)
+        book_id_and_count = []
+        book_temp = []
+        for i in range(0, books):
+            book_no = int(random.uniform(0, len(self.book_ids) - 1))
+            book_id = self.book_ids[book_no]
+            if book_id in book_temp:
+                continue
+            else:
+                book_temp.append(book_id)
+                count = random.randint(1, 10)
+                book_id_and_count.append((book_id, count))
+        b = Buyer(url_prefix=conf.URL, user_id=buyer_id, password=buyer_password)
+        new_ord = NewOrder(b, store_id, book_id_and_count)
+        return new_ord
+
+    def update_stat(self, n_new_order, n_payment,
+                    n_new_order_ok, n_payment_ok,
+                    time_new_order, time_payment):
+        # 获取当前并发数
+        thread_num = len(threading.enumerate())
+        # 加索
+        self.lock.acquire()
+        self.n_new_order = self.n_new_order + n_new_order
+        self.n_payment = self.n_payment + n_payment
+        self.n_new_order_ok = self.n_new_order_ok + n_new_order_ok
+        self.n_payment_ok = self.n_payment_ok + n_payment_ok
+        self.time_new_order = self.time_new_order + time_new_order
+        self.time_payment = self.time_payment + time_payment
+        # 计算这段时间内新创建订单的总数目
+        n_new_order_diff = self.n_new_order - self.n_new_order_past
+        # 计算这段时间内新付款订单的总数目
+        n_payment_diff = self.n_payment - self.n_payment_past
+        
+        if self.n_payment != 0 and self. n_new_order != 0 \
+                and (self.time_payment + self.time_new_order):
+            # TPS_C(吞吐量):成功创建订单数量/(提交订单时间/提交订单并发数 + 提交付款订单时间/提交付款订单并发数)
+            # NO=OK:新创建订单数量
+            # Thread_num:以新提交订单的数量作为并发数(这一次的TOTAL-上一次的TOTAL)
+            # TOTAL:总提交订单数量
+            # LATENCY:提交订单时间/处理订单笔数(只考虑该线程延迟，未考虑并发)
+            # P=OK:新创建付款订单数量
+            # Thread_num:以新提交付款订单的数量作为并发数(这一次的TOTAL-上一次的TOTAL)
+            # TOTAL:总付款提交订单数量
+            # LATENCY:提交付款订单时间/处理付款订单笔数(只考虑该线程延迟，未考虑并发)
+            logging.info("TPS_C={}, NO=OK:{} Thread_num:{} TOTAL:{} LATENCY:{} , P=OK:{} Thread_num:{} TOTAL:{} LATENCY:{}".format(
+                        int(self.n_new_order_ok / (self.time_payment / n_payment_diff + self.time_new_order / n_new_order_diff)), # 吞吐量:完成订单数/((付款所用时间+订单所用时间)/并发数)
+                        self.n_new_order_ok, n_new_order_diff, self.n_new_order, self.time_new_order / self.n_new_order, # 订单延迟:(创建订单所用时间/并发数)/新创建订单数
+                        self.n_payment_ok, n_payment_diff, self.n_payment, self.time_payment / self.n_payment # 付款延迟:(付款所用时间/并发数)/付款订单数
+                        ))
+        self.lock.release()
+        # 旧值更新为新值，便于下一轮计算
+        self.n_new_order_past = self.n_new_order
+        self.n_payment_past = self.n_payment
+        self.n_new_order_ok_past = self.n_new_order_ok
+        self.n_payment_ok_past = self.n_payment_ok
diff --git a/fe/conf.py b/fe/conf.py
new file mode 100644
index 0000000..a0fbb2b
--- /dev/null
+++ b/fe/conf.py
@@ -0,0 +1,11 @@
+URL = "http://127.0.0.1:5000/"
+Book_Num_Per_Store = 2000
+Store_Num_Per_User = 2
+Seller_Num = 2
+Buyer_Num = 10
+Session = 1
+Request_Per_Session = 1000
+Default_Stock_Level = 1000000
+Default_User_Funds = 10000000
+Data_Batch_Size = 100
+Use_Large_DB = False
diff --git a/fe/conftest.py b/fe/conftest.py
new file mode 100644
index 0000000..e93cee2
--- /dev/null
+++ b/fe/conftest.py
@@ -0,0 +1,27 @@
+import requests
+import threading
+from urllib.parse import urljoin
+from be import serve
+from fe import conf
+
+thread: threading.Thread = None
+
+
+# 修改这里启动后端程序，如果不需要可删除这行代码
+def run_backend():
+    # rewrite this if rewrite backend
+    serve.be_run()
+
+
+def pytest_configure(config):
+    global thread
+    print("frontend begin test")
+    thread = threading.Thread(target=run_backend)
+    thread.start()
+
+
+def pytest_unconfigure(config):
+    url = urljoin(conf.URL, "shutdown")
+    requests.get(url)
+    thread.join()
+    print("frontend end test")
diff --git a/fe/data/book.db b/fe/data/book.db
new file mode 100644
index 0000000..5ee601c
Binary files /dev/null and b/fe/data/book.db differ
diff --git a/fe/data/scraper.py b/fe/data/scraper.py
new file mode 100644
index 0000000..c85e3d1
--- /dev/null
+++ b/fe/data/scraper.py
@@ -0,0 +1,425 @@
+# coding=utf-8
+
+from lxml import etree
+import sqlite3
+import re
+import requests
+import random
+import time
+import logging
+
+user_agent = [
+    "Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 "
+    "Safari/534.50",
+    "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 "
+    "Safari/534.50",
+    "Mozilla/5.0 (Windows NT 10.0; WOW64; rv:38.0) Gecko/20100101 Firefox/38.0",
+    "Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR "
+    "3.0.30729; .NET CLR 3.5.30729; InfoPath.3; rv:11.0) like Gecko",
+    "Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)",
+    "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)",
+    "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)",
+    "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)",
+    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0.1) Gecko/20100101 Firefox/4.0.1",
+    "Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/4.0.1",
+    "Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; en) Presto/2.8.131 Version/11.11",
+    "Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11",
+    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 "
+    "Safari/535.11",
+    "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Maxthon 2.0)",
+    "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; TencentTraveler 4.0)",
+    "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)",
+    "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; The World)",
+    "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SE 2.X MetaSr 1.0; SE 2.X MetaSr 1.0; .NET "
+    "CLR 2.0.50727; SE 2.X MetaSr 1.0)",
+    "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; 360SE)",
+    "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Avant Browser)",
+    "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)",
+    "Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) "
+    "Version/5.0.2 Mobile/8J2 Safari/6533.18.5",
+    "Mozilla/5.0 (iPod; U; CPU iPhone OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) "
+    "Version/5.0.2 Mobile/8J2 Safari/6533.18.5",
+    "Mozilla/5.0 (iPad; U; CPU OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) "
+    "Version/5.0.2 Mobile/8J2 Safari/6533.18.5",
+    "Mozilla/5.0 (Linux; U; Android 2.3.7; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) "
+    "Version/4.0 Mobile Safari/533.1",
+    "MQQBrowser/26 Mozilla/5.0 (Linux; U; Android 2.3.7; zh-cn; MB200 Build/GRJ22; CyanogenMod-7) "
+    "AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1",
+    "Opera/9.80 (Android 2.3.4; Linux; Opera Mobi/build-1107180945; U; en-GB) Presto/2.8.149 Version/11.10",
+    "Mozilla/5.0 (Linux; U; Android 3.0; en-us; Xoom Build/HRI39) AppleWebKit/534.13 (KHTML, like Gecko) "
+    "Version/4.0 Safari/534.13",
+    "Mozilla/5.0 (BlackBerry; U; BlackBerry 9800; en) AppleWebKit/534.1+ (KHTML, like Gecko) Version/6.0.0.337 "
+    "Mobile Safari/534.1+",
+    "Mozilla/5.0 (hp-tablet; Linux; hpwOS/3.0.0; U; en-US) AppleWebKit/534.6 (KHTML, like Gecko) "
+    "wOSBrowser/233.70 Safari/534.6 TouchPad/1.0",
+    "Mozilla/5.0 (SymbianOS/9.4; Series60/5.0 NokiaN97-1/20.0.019; Profile/MIDP-2.1 Configuration/CLDC-1.1) "
+    "AppleWebKit/525 (KHTML, like Gecko) BrowserNG/7.1.18124",
+    "Mozilla/5.0 (compatible; MSIE 9.0; Windows Phone OS 7.5; Trident/5.0; IEMobile/9.0; HTC; Titan)",
+    "UCWEB7.0.2.37/28/999",
+    "NOKIA5700/ UCWEB7.0.2.37/28/999",
+    "Openwave/ UCWEB7.0.2.37/28/999",
+    "Mozilla/4.0 (compatible; MSIE 6.0; ) Opera/UCWEB7.0.2.37/28/999",
+    # iPhone 6：
+    "Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 "
+    "Mobile/10A5376e Safari/8536.25",
+]
+
+
+def get_user_agent():
+    headers = {"User-Agent": random.choice(user_agent)}
+    return headers
+
+
+class Scraper:
+    database: str
+    tag: str
+    page: int
+
+    def __init__(self):
+        self.database = "book.db"
+        self.tag = ""
+        self.page = 0
+        self.pattern_number = re.compile(r"\d+\.?\d*")
+        logging.basicConfig(filename="scraper.log", level=logging.ERROR)
+
+    def get_current_progress(self) -> ():
+        conn = sqlite3.connect(self.database)
+        results = conn.execute("SELECT tag, page from progress where id = '0'")
+        for row in results:
+            return row[0], row[1]
+        return "", 0
+
+    def save_current_progress(self, current_tag, current_page):
+        conn = sqlite3.connect(self.database)
+        conn.execute(
+            "UPDATE progress set tag = '{}', page = {} where id = '0'".format(
+                current_tag, current_page
+            )
+        )
+        conn.commit()
+        conn.close()
+
+    def start_grab(self) -> bool:
+        self.create_tables()
+        scraper.grab_tag()
+        current_tag, current_page = self.get_current_progress()
+        tags = self.get_tag_list()
+        for i in range(0, len(tags)):
+            no = 0
+            if i == 0 and current_tag == tags[i]:
+                no = current_page
+            while self.grab_book_list(tags[i], no):
+                no = no + 20
+        return True
+
+    def create_tables(self):
+        conn = sqlite3.connect(self.database)
+        try:
+            conn.execute("CREATE TABLE tags (tag TEXT PRIMARY KEY)")
+            conn.commit()
+        except sqlite3.Error as e:
+            logging.error(str(e))
+            conn.rollback()
+
+        try:
+            conn.execute(
+                "CREATE TABLE book ("
+                "id TEXT PRIMARY KEY, title TEXT, author TEXT, "
+                "publisher TEXT, original_title TEXT, "
+                "translator TEXT, pub_year TEXT, pages INTEGER, "
+                "price INTEGER, currency_unit TEXT, binding TEXT, "
+                "isbn TEXT, author_intro TEXT, book_intro text, "
+                "content TEXT, tags TEXT, picture BLOB)"
+            )
+            conn.commit()
+        except sqlite3.Error as e:
+            logging.error(str(e))
+            conn.rollback()
+
+        try:
+            conn.execute(
+                "CREATE TABLE progress (id TEXT PRIMARY KEY, tag TEXT, page integer )"
+            )
+            conn.execute("INSERT INTO progress values('0', '', 0)")
+            conn.commit()
+        except sqlite3.Error as e:
+            logging.error(str(e))
+            conn.rollback()
+
+    def grab_tag(self):
+        url = "https://book.douban.com/tag/?view=cloud"
+        r = requests.get(url, headers=get_user_agent())
+        r.encoding = "utf-8"
+        h: etree.ElementBase = etree.HTML(r.text)
+        tags: [] = h.xpath(
+            '/html/body/div[@id="wrapper"]/div[@id="content"]'
+            '/div[@class="grid-16-8 clearfix"]/div[@class="article"]'
+            '/div[@class=""]/div[@class="indent tag_cloud"]'
+            "/table/tbody/tr/td/a/@href"
+        )
+        conn = sqlite3.connect(self.database)
+        c = conn.cursor()
+        try:
+            for tag in tags:
+                t: str = tag.strip("/tag")
+                c.execute("INSERT INTO tags VALUES ('{}')".format(t))
+            c.close()
+            conn.commit()
+            conn.close()
+        except sqlite3.Error as e:
+            logging.error(str(e))
+            conn.rollback()
+            return False
+        return True
+
+    def grab_book_list(self, tag="小说", pageno=1) -> bool:
+        logging.info("start to grab tag {} page {}...".format(tag, pageno))
+        self.save_current_progress(tag, pageno)
+        url = "https://book.douban.com/tag/{}?start={}&type=T".format(tag, pageno)
+        r = requests.get(url, headers=get_user_agent())
+        r.encoding = "utf-8"
+        h: etree.Element = etree.HTML(r.text)
+
+        li_list: [] = h.xpath(
+            '/html/body/div[@id="wrapper"]/div[@id="content"]'
+            '/div[@class="grid-16-8 clearfix"]'
+            '/div[@class="article"]/div[@id="subject_list"]'
+            '/ul/li/div[@class="info"]/h2/a/@href'
+        )
+        next_page = h.xpath(
+            '/html/body/div[@id="wrapper"]/div[@id="content"]'
+            '/div[@class="grid-16-8 clearfix"]'
+            '/div[@class="article"]/div[@id="subject_list"]'
+            '/div[@class="paginator"]/span[@class="next"]/a[@href]'
+        )
+        has_next = True
+        if len(next_page) == 0:
+            has_next = False
+        if len(li_list) == 0:
+            return False
+
+        for li in li_list:
+            li.strip("")
+            book_id = li.strip("/").split("/")[-1]
+            try:
+                delay = float(random.randint(0, 200)) / 100.0
+                time.sleep(delay)
+                self.crow_book_info(book_id)
+            except BaseException as e:
+                logging.error(
+                    logging.error("error when scrape {}, {}".format(book_id, str(e)))
+                )
+        return has_next
+
+    def get_tag_list(self) -> [str]:
+        ret = []
+        conn = sqlite3.connect(self.database)
+        results = conn.execute(
+            "SELECT tags.tag from tags join progress where tags.tag >= progress.tag"
+        )
+        for row in results:
+            ret.append(row[0])
+        return ret
+
+    def crow_book_info(self, book_id) -> bool:
+        conn = sqlite3.connect(self.database)
+        for _ in conn.execute("SELECT id from book where id = ('{}')".format(book_id)):
+            return
+
+        url = "https://book.douban.com/subject/{}/".format(book_id)
+        r = requests.get(url, headers=get_user_agent())
+        r.encoding = "utf-8"
+        h: etree.Element = etree.HTML(r.text)
+        e_text = h.xpath('/html/body/div[@id="wrapper"]/h1/span/text()')
+        if len(e_text) == 0:
+            return False
+
+        title = e_text[0]
+
+        elements = h.xpath(
+            '/html/body/div[@id="wrapper"]'
+            '/div[@id="content"]/div[@class="grid-16-8 clearfix"]'
+            '/div[@class="article"]'
+        )
+        if len(elements) == 0:
+            return False
+
+        e_article = elements[0]
+
+        book_intro = ""
+        author_intro = ""
+        content = ""
+        tags = ""
+
+        e_book_intro = e_article.xpath(
+            'div[@class="related_info"]'
+            '/div[@class="indent"][@id="link-report"]/*'
+            '/div[@class="intro"]/*/text()'
+        )
+        for line in e_book_intro:
+            line = line.strip()
+            if line != "":
+                book_intro = book_intro + line + "\n"
+
+        e_author_intro = e_article.xpath(
+            'div[@class="related_info"]'
+            '/div[@class="indent "]/*'
+            '/div[@class="intro"]/*/text()'
+        )
+        for line in e_author_intro:
+            line = line.strip()
+            if line != "":
+                author_intro = author_intro + line + "\n"
+
+        e_content = e_article.xpath(
+            'div[@class="related_info"]'
+            '/div[@class="indent"][@id="dir_' + book_id + '_full"]/text()'
+        )
+        for line in e_content:
+            line = line.strip()
+            if line != "":
+                content = content + line + "\n"
+
+        e_tags = e_article.xpath(
+            'div[@class="related_info"]/'
+            'div[@id="db-tags-section"]/'
+            'div[@class="indent"]/span/a/text()'
+        )
+        for line in e_tags:
+            line = line.strip()
+            if line != "":
+                tags = tags + line + "\n"
+
+        e_subject = e_article.xpath(
+            'div[@class="indent"]'
+            '/div[@class="subjectwrap clearfix"]'
+            '/div[@class="subject clearfix"]'
+        )
+        pic_href = e_subject[0].xpath('div[@id="mainpic"]/a/@href')
+        picture = None
+        if len(pic_href) > 0:
+            res = requests.get(pic_href[0], headers=get_user_agent())
+            picture = res.content
+
+        info_children = e_subject[0].xpath('div[@id="info"]/child::node()')
+
+        e_array = []
+        e_dict = dict()
+
+        for e in info_children:
+            if isinstance(e, etree._ElementUnicodeResult):
+                e_dict["text"] = e
+            elif isinstance(e, etree._Element):
+                if e.tag == "br":
+                    e_array.append(e_dict)
+                    e_dict = dict()
+                else:
+                    e_dict[e.tag] = e
+
+        book_info = dict()
+        for d in e_array:
+            label = ""
+            span = d.get("span")
+            a_label = span.xpath("span/text()")
+            if len(a_label) > 0 and label == "":
+                label = a_label[0].strip()
+            a_label = span.xpath("text()")
+            if len(a_label) > 0 and label == "":
+                label = a_label[0].strip()
+            label = label.strip(":")
+            text = d.get("text").strip()
+            e_a = d.get("a")
+            text.strip()
+            text.strip(":")
+            if label == "作者" or label == "译者":
+                a = span.xpath("a/text()")
+                if text == "" and len(a) == 1:
+                    text = a[0].strip()
+                if text == "" and e_a is not None:
+                    text_a = e_a.xpath("text()")
+                    if len(text_a) > 0:
+                        text = text_a[0].strip()
+                        text = re.sub(r"\s+", " ", text)
+            if text != "":
+                book_info[label] = text
+
+        sql = (
+            "INSERT INTO book("
+            "id, title, author, "
+            "publisher, original_title, translator, "
+            "pub_year, pages, price, "
+            "currency_unit, binding, isbn, "
+            "author_intro, book_intro, content, "
+            "tags, picture)"
+            "VALUES("
+            "?, ?, ?, "
+            "?, ?, ?, "
+            "?, ?, ?, "
+            "?, ?, ?, "
+            "?, ?, ?, "
+            "?, ?)"
+        )
+
+        unit = None
+        price = None
+        pages = None
+        conn = sqlite3.connect(self.database)
+        try:
+            s_price = book_info.get("定价")
+            if s_price is None:
+                # price cannot be NULL
+                logging.error(
+                    "error when scrape book_id {}, cannot retrieve price...", book_id
+                )
+                return None
+            else:
+                e = re.findall(self.pattern_number, s_price)
+                if len(e) != 0:
+                    number = e[0]
+                    unit = s_price.replace(number, "").strip()
+                    price = int(float(number) * 100)
+
+            s_pages = book_info.get("页数")
+            if s_pages is not None:
+                # pages can be NULL
+                e = re.findall(self.pattern_number, s_pages)
+                if len(e) != 0:
+                    pages = int(e[0])
+
+            conn.execute(
+                sql,
+                (
+                    book_id,
+                    title,
+                    book_info.get("作者"),
+                    book_info.get("出版社"),
+                    book_info.get("原作名"),
+                    book_info.get("译者"),
+                    book_info.get("出版年"),
+                    pages,
+                    price,
+                    unit,
+                    book_info.get("装帧"),
+                    book_info.get("ISBN"),
+                    author_intro,
+                    book_intro,
+                    content,
+                    tags,
+                    picture,
+                ),
+            )
+            conn.commit()
+        except sqlite3.Error as e:
+            logging(str(e))
+            conn.rollback()
+        except TypeError as e:
+            logging.error("error when scrape {}, {}".format(book_id, str(e)))
+            conn.rollback()
+            return False
+        conn.close()
+        return True
+
+
+if __name__ == "__main__":
+    scraper = Scraper()
+    scraper.start_grab()
diff --git a/fe/test/gen_book_data.py b/fe/test/gen_book_data.py
new file mode 100644
index 0000000..4bda418
--- /dev/null
+++ b/fe/test/gen_book_data.py
@@ -0,0 +1,57 @@
+import random
+from fe.access import book
+from fe.access.new_seller import register_new_seller
+
+
+class GenBook:
+    def __init__(self, user_id, store_id):
+        self.user_id = user_id
+        self.store_id = store_id
+        self.password = self.user_id
+        self.seller = register_new_seller(self.user_id, self.password)
+        code = self.seller.create_store(store_id)
+        assert code == 200
+        self.__init_book_list__()
+
+    def __init_book_list__(self):
+        self.buy_book_info_list = []
+        self.buy_book_id_list = []
+
+    def gen(self, non_exist_book_id: bool, low_stock_level, max_book_count: int = 100) -> (bool, []):
+        self.__init_book_list__()
+        ok = True
+        book_db = book.BookDB()
+        rows = book_db.get_book_count()
+        start = 0
+        if rows > max_book_count:
+            start = random.randint(0, rows - max_book_count)
+        size = random.randint(1, max_book_count)
+        books = book_db.get_book_info(start, size)
+        book_id_exist = []
+        book_id_stock_level = {}
+        for bk in books:
+            if low_stock_level:
+                stock_level = random.randint(0, 100)
+            else:
+                stock_level = random.randint(2, 100)
+            code = self.seller.add_book(self.store_id, stock_level, bk)
+            assert code == 200
+            book_id_stock_level[bk.id] = stock_level
+            book_id_exist.append(bk)
+
+        for bk in book_id_exist:
+            stock_level = book_id_stock_level[bk.id]
+            if stock_level > 1:
+                buy_num = random.randint(1, stock_level)
+            else:
+                buy_num = 0
+            # add a new pair
+            if non_exist_book_id:
+                bk.id = bk.id + "_x"
+            if low_stock_level:
+                buy_num = stock_level + 1
+            self.buy_book_info_list.append((bk, buy_num))
+
+        for item in self.buy_book_info_list:
+            self.buy_book_id_list.append((item[0].id, item[1]))
+        return ok, self.buy_book_id_list
diff --git a/fe/test/test.md b/fe/test/test.md
new file mode 100644
index 0000000..c7fe16e
--- /dev/null
+++ b/fe/test/test.md
@@ -0,0 +1 @@
+add functionality test here
diff --git a/fe/test/test_add_book.py b/fe/test/test_add_book.py
new file mode 100644
index 0000000..dcc6106
--- /dev/null
+++ b/fe/test/test_add_book.py
@@ -0,0 +1,51 @@
+import pytest
+
+from fe.access.new_seller import register_new_seller
+from fe.access import book
+import uuid
+
+
+class TestAddBook:
+    @pytest.fixture(autouse=True)
+    def pre_run_initialization(self):
+        # do before test
+        self.seller_id = "test_add_books_seller_id_{}".format(str(uuid.uuid1()))
+        self.store_id = "test_add_books_store_id_{}".format(str(uuid.uuid1()))
+        self.password = self.seller_id
+        self.seller = register_new_seller(self.seller_id, self.password)
+
+        code = self.seller.create_store(self.store_id)
+        assert code == 200
+        book_db = book.BookDB()
+        self.books = book_db.get_book_info(0, 2)
+
+        yield
+        # do after test
+
+    def test_ok(self):
+        for b in self.books:
+            code = self.seller.add_book(self.store_id, 0, b)
+            assert code == 200
+
+    def test_error_non_exist_store_id(self):
+        for b in self.books:
+            # non exist store id
+            code = self.seller.add_book(self.store_id + "x", 0, b)
+            assert code != 200
+
+    def test_error_exist_book_id(self):
+        for b in self.books:
+            code = self.seller.add_book(self.store_id, 0, b)
+            assert code == 200
+        for b in self.books:
+            # exist book id
+            code = self.seller.add_book(self.store_id, 0, b)
+            assert code != 200
+
+    def test_error_non_exist_user_id(self):
+        for b in self.books:
+            # non exist user id
+            self.seller.seller_id = self.seller.seller_id + "_x"
+            code = self.seller.add_book(self.store_id, 0, b)
+            assert code != 200
+
diff --git a/fe/test/test_add_funds.py b/fe/test/test_add_funds.py
new file mode 100644
index 0000000..de5b525
--- /dev/null
+++ b/fe/test/test_add_funds.py
@@ -0,0 +1,29 @@
+import pytest
+import uuid
+from fe.access.new_buyer import register_new_buyer
+
+
+class TestAddFunds:
+    @pytest.fixture(autouse=True)
+    def pre_run_initialization(self):
+        self.user_id = "test_add_funds_{}".format(str(uuid.uuid1()))
+        self.password = self.user_id
+        self.buyer = register_new_buyer(self.user_id, self.password)
+        yield
+
+    def test_ok(self):
+        code = self.buyer.add_funds(1000)
+        assert code == 200
+
+        code = self.buyer.add_funds(-1000)
+        assert code == 200
+
+    def test_error_user_id(self):
+        self.buyer.user_id = self.buyer.user_id + "_x"
+        code = self.buyer.add_funds(10)
+        assert code != 200
+
+    def test_error_password(self):
+        self.buyer.password = self.buyer.password + "_x"
+        code = self.buyer.add_funds(10)
+        assert code != 200
diff --git a/fe/test/test_add_stock_level.py b/fe/test/test_add_stock_level.py
new file mode 100644
index 0000000..db2cd37
--- /dev/null
+++ b/fe/test/test_add_stock_level.py
@@ -0,0 +1,46 @@
+import pytest
+from fe.access.new_seller import register_new_seller
+from fe.access import book
+import uuid
+
+
+class TestAddStockLevel:
+    @pytest.fixture(autouse=True)
+    def pre_run_initialization(self):
+        self.user_id = "test_add_book_stock_level1_user_{}".format(str(uuid.uuid1()))
+        self.store_id = "test_add_book_stock_level1_store_{}".format(str(uuid.uuid1()))
+        self.password = self.user_id
+        self.seller = register_new_seller(self.user_id, self.password)
+
+        code = self.seller.create_store(self.store_id)
+        assert code == 200
+        book_db = book.BookDB()
+        self.books = book_db.get_book_info(0, 5)
+        for bk in self.books:
+            code = self.seller.add_book(self.store_id, 0, bk)
+            assert code == 200
+        yield
+
+    def test_error_user_id(self):
+        for b in self.books:
+            book_id = b.id
+            code = self.seller.add_stock_level(self.user_id + "_x", self.store_id, book_id, 10)
+            assert code != 200
+
+    def test_error_store_id(self):
+        for b in self.books:
+            book_id = b.id
+            code = self.seller.add_stock_level(self.user_id, self.store_id + "_x", book_id, 10)
+            assert code != 200
+
+    def test_error_book_id(self):
+        for b in self.books:
+            book_id = b.id
+            code = self.seller.add_stock_level(self.user_id, self.store_id, book_id + "_x", 10)
+            assert code != 200
+
+    def test_ok(self):
+        for b in self.books:
+            book_id = b.id
+            code = self.seller.add_stock_level(self.user_id, self.store_id, book_id, 10)
+            assert code == 200
diff --git a/fe/test/test_bench.py b/fe/test/test_bench.py
new file mode 100644
index 0000000..969c18b
--- /dev/null
+++ b/fe/test/test_bench.py
@@ -0,0 +1,8 @@
+from fe.bench.run import run_bench
+
+
+def test_bench():
+    try:
+        run_bench()
+    except Exception as e:
+        assert 200==100,"test_bench过程出现异常"
\ No newline at end of file
diff --git a/fe/test/test_create_store.py b/fe/test/test_create_store.py
new file mode 100644
index 0000000..8d94244
--- /dev/null
+++ b/fe/test/test_create_store.py
@@ -0,0 +1,26 @@
+import pytest
+
+from fe.access.new_seller import register_new_seller
+import uuid
+
+
+class TestCreateStore:
+    @pytest.fixture(autouse=True)
+    def pre_run_initialization(self):
+        self.user_id = "test_create_store_user_{}".format(str(uuid.uuid1()))
+        self.store_id = "test_create_store_store_{}".format(str(uuid.uuid1()))
+        self.password = self.user_id
+        yield
+
+    def test_ok(self):
+        self.seller = register_new_seller(self.user_id, self.password)
+        code = self.seller.create_store(self.store_id)
+        assert code == 200
+
+    def test_error_exist_store_id(self):
+        self.seller = register_new_seller(self.user_id, self.password)
+        code = self.seller.create_store(self.store_id)
+        assert code == 200
+
+        code = self.seller.create_store(self.store_id)
+        assert code != 200
diff --git a/fe/test/test_login.py b/fe/test/test_login.py
new file mode 100644
index 0000000..e11c6ef
--- /dev/null
+++ b/fe/test/test_login.py
@@ -0,0 +1,39 @@
+import time
+
+import pytest
+
+from fe.access import auth
+from fe import conf
+
+
+class TestLogin:
+    @pytest.fixture(autouse=True)
+    def pre_run_initialization(self):
+        self.auth = auth.Auth(conf.URL)
+        # register a user
+        self.user_id = "test_login_{}".format(time.time())
+        self.password = "password_" + self.user_id
+        self.terminal = "terminal_" + self.user_id
+        assert self.auth.register(self.user_id, self.password) == 200
+        yield
+
+    def test_ok(self):
+        code, token = self.auth.login(self.user_id, self.password, self.terminal)
+        assert code == 200
+
+        code = self.auth.logout(self.user_id + "_x", token)
+        assert code == 401
+
+        code = self.auth.logout(self.user_id, token + "_x")
+        assert code == 401
+
+        code = self.auth.logout(self.user_id, token)
+        assert code == 200
+
+    def test_error_user_id(self):
+        code, token = self.auth.login(self.user_id + "_x", self.password, self.terminal)
+        assert code == 401
+
+    def test_error_password(self):
+        code, token = self.auth.login(self.user_id, self.password + "_x", self.terminal)
+        assert code == 401
diff --git a/fe/test/test_new_order.py b/fe/test/test_new_order.py
new file mode 100644
index 0000000..8acc09c
--- /dev/null
+++ b/fe/test/test_new_order.py
@@ -0,0 +1,48 @@
+import pytest
+
+from fe.test.gen_book_data import GenBook
+from fe.access.new_buyer import register_new_buyer
+import uuid
+
+
+class TestNewOrder:
+    @pytest.fixture(autouse=True)
+    def pre_run_initialization(self):
+        self.seller_id = "test_new_order_seller_id_{}".format(str(uuid.uuid1()))
+        self.store_id = "test_new_order_store_id_{}".format(str(uuid.uuid1()))
+        self.buyer_id = "test_new_order_buyer_id_{}".format(str(uuid.uuid1()))
+        self.password = self.seller_id
+        self.buyer = register_new_buyer(self.buyer_id, self.password)
+        self.gen_book = GenBook(self.seller_id, self.store_id)
+        yield
+
+    def test_non_exist_book_id(self):
+        ok, buy_book_id_list = self.gen_book.gen(non_exist_book_id=True, low_stock_level=False)
+        assert ok
+        code, _ = self.buyer.new_order(self.store_id, buy_book_id_list)
+        assert code != 200
+
+    def test_low_stock_level(self):
+        ok, buy_book_id_list = self.gen_book.gen(non_exist_book_id=False, low_stock_level=True)
+        assert ok
+        code, _ = self.buyer.new_order(self.store_id, buy_book_id_list)
+        assert code != 200
+
+    def test_ok(self):
+        ok, buy_book_id_list = self.gen_book.gen(non_exist_book_id=False, low_stock_level=False)
+        assert ok
+        code, _ = self.buyer.new_order(self.store_id, buy_book_id_list)
+        assert code == 200
+
+    def test_non_exist_user_id(self):
+        ok, buy_book_id_list = self.gen_book.gen(non_exist_book_id=False, low_stock_level=False)
+        assert ok
+        self.buyer.user_id = self.buyer.user_id + "_x"
+        code, _ = self.buyer.new_order(self.store_id, buy_book_id_list)
+        assert code != 200
+
+    def test_non_exist_store_id(self):
+        ok, buy_book_id_list = self.gen_book.gen(non_exist_book_id=False, low_stock_level=False)
+        assert ok
+        code, _ = self.buyer.new_order(self.store_id + "_x", buy_book_id_list)
+        assert code != 200
diff --git a/fe/test/test_password.py b/fe/test/test_password.py
new file mode 100644
index 0000000..c1e2e76
--- /dev/null
+++ b/fe/test/test_password.py
@@ -0,0 +1,47 @@
+import uuid
+
+import pytest
+
+from fe.access import auth
+from fe import conf
+
+
+class TestPassword:
+    @pytest.fixture(autouse=True)
+    def pre_run_initialization(self):
+        self.auth = auth.Auth(conf.URL)
+        # register a user
+        self.user_id = "test_password_{}".format(str(uuid.uuid1()))
+        self.old_password = "old_password_" + self.user_id
+        self.new_password = "new_password_" + self.user_id
+        self.terminal = "terminal_" + self.user_id
+
+        assert self.auth.register(self.user_id, self.old_password) == 200
+        yield
+
+    def test_ok(self):
+        code = self.auth.password(self.user_id, self.old_password, self.new_password)
+        assert code == 200
+
+        code, new_token = self.auth.login(self.user_id, self.old_password, self.terminal)
+        assert code != 200
+
+        code, new_token = self.auth.login(self.user_id, self.new_password, self.terminal)
+        assert code == 200
+
+        code = self.auth.logout(self.user_id, new_token)
+        assert code == 200
+
+    def test_error_password(self):
+        code = self.auth.password(self.user_id, self.old_password + "_x", self.new_password)
+        assert code != 200
+
+        code, new_token = self.auth.login(self.user_id, self.new_password, self.terminal)
+        assert code != 200
+
+    def test_error_user_id(self):
+        code = self.auth.password(self.user_id + "_x", self.old_password, self.new_password)
+        assert code != 200
+
+        code, new_token = self.auth.login(self.user_id, self.new_password, self.terminal)
+        assert code != 200
diff --git a/fe/test/test_payment.py b/fe/test/test_payment.py
new file mode 100644
index 0000000..4b53e7e
--- /dev/null
+++ b/fe/test/test_payment.py
@@ -0,0 +1,70 @@
+import pytest
+
+from fe.access.buyer import Buyer
+from fe.test.gen_book_data import GenBook
+from fe.access.new_buyer import register_new_buyer
+from fe.access.book import Book
+import uuid
+
+
+class TestPayment:
+    seller_id: str
+    store_id: str
+    buyer_id: str
+    password:str
+    buy_book_info_list: [Book]
+    total_price: int
+    order_id: str
+    buyer: Buyer
+
+    @pytest.fixture(autouse=True)
+    def pre_run_initialization(self):
+        self.seller_id = "test_payment_seller_id_{}".format(str(uuid.uuid1()))
+        self.store_id = "test_payment_store_id_{}".format(str(uuid.uuid1()))
+        self.buyer_id = "test_payment_buyer_id_{}".format(str(uuid.uuid1()))
+        self.password = self.seller_id
+        gen_book = GenBook(self.seller_id, self.store_id)
+        ok, buy_book_id_list = gen_book.gen(non_exist_book_id=False, low_stock_level=False, max_book_count=5)
+        self.buy_book_info_list = gen_book.buy_book_info_list
+        assert ok
+        b = register_new_buyer(self.buyer_id, self.password)
+        self.buyer = b
+        code, self.order_id = b.new_order(self.store_id, buy_book_id_list)
+        assert code == 200
+        self.total_price = 0
+        for item in self.buy_book_info_list:
+            book: Book = item[0]
+            num = item[1]
+            if book.price is None:
+                continue
+            else:
+                self.total_price = self.total_price + book.price * num
+        yield
+
+    def test_ok(self):
+        code = self.buyer.add_funds(self.total_price)
+        assert code == 200
+        code = self.buyer.payment(self.order_id)
+        assert code == 200
+
+    def test_authorization_error(self):
+        code = self.buyer.add_funds(self.total_price)
+        assert code == 200
+        self.buyer.password = self.buyer.password + "_x"
+        code = self.buyer.payment(self.order_id)
+        assert code != 200
+
+    def test_not_suff_funds(self):
+        code = self.buyer.add_funds(self.total_price - 1)
+        assert code == 200
+        code = self.buyer.payment(self.order_id)
+        assert code != 200
+
+    def test_repeat_pay(self):
+        code = self.buyer.add_funds(self.total_price)
+        assert code == 200
+        code = self.buyer.payment(self.order_id)
+        assert code == 200
+
+        code = self.buyer.payment(self.order_id)
+        assert code != 200
diff --git a/fe/test/test_register.py b/fe/test/test_register.py
new file mode 100644
index 0000000..42acc5e
--- /dev/null
+++ b/fe/test/test_register.py
@@ -0,0 +1,43 @@
+import time
+
+import pytest
+
+from fe.access import auth
+from fe import conf
+
+
+class TestRegister:
+    @pytest.fixture(autouse=True)
+    def pre_run_initialization(self):
+        self.user_id = "test_register_user_{}".format(time.time())
+        self.password = "test_register_password_{}".format(time.time())
+        self.auth = auth.Auth(conf.URL)
+        yield
+
+    def test_register_ok(self):
+        code = self.auth.register(self.user_id, self.password)
+        assert code == 200
+
+    def test_unregister_ok(self):
+        code = self.auth.register(self.user_id, self.password)
+        assert code == 200
+
+        code = self.auth.unregister(self.user_id, self.password)
+        assert code == 200
+
+    def test_unregister_error_authorization(self):
+        code = self.auth.register(self.user_id, self.password)
+        assert code == 200
+
+        code = self.auth.unregister(self.user_id + "_x", self.password)
+        assert code != 200
+
+        code = self.auth.unregister(self.user_id, self.password + "_x")
+        assert code != 200
+
+    def test_register_error_exist_user_id(self):
+        code = self.auth.register(self.user_id, self.password)
+        assert code == 200
+
+        code = self.auth.register(self.user_id, self.password)
+        assert code != 200
diff --git a/requirements.txt b/requirements.txt
new file mode 100644
index 0000000..f25106e
--- /dev/null
+++ b/requirements.txt
@@ -0,0 +1,9 @@
+simplejson
+lxml
+codecov
+coverage
+flask
+pre-commit
+pytest
+PyJWT
+requests
diff --git a/script/test.sh b/script/test.sh
new file mode 100644
index 0000000..ae7bfb0
--- /dev/null
+++ b/script/test.sh
@@ -0,0 +1,6 @@
+#!/bin/sh
+export PATHONPATH=`pwd`
+coverage run --timid --branch --source fe,be --concurrency=thread -m pytest -v --ignore=fe/data
+coverage combine
+coverage report
+coverage html
diff --git a/setup.py b/setup.py
new file mode 100644
index 0000000..3910635
--- /dev/null
+++ b/setup.py
@@ -0,0 +1,22 @@
+import setuptools
+
+with open("README.md", "r") as fh:
+    long_description = fh.read()
+
+setuptools.setup(
+    name="bookstore",
+    version="0.0.1",
+    author="DaSE-DBMS",
+    author_email="DaSE-DBMS@DaSE-DBMS.com",
+    description="Buy Books Online",
+    long_description=long_description,
+    long_description_content_type="text/markdown",
+    url="https://github.com/DaSE-DBMS/bookstore.git",
+    packages=setuptools.find_packages(),
+    classifiers=[
+        "Programming Language :: Python :: 3",
+        "License :: OSI Approved :: MIT License",
+        "Operating System :: OS Independent",
+    ],
+    python_requires=">=3.6",
+)
