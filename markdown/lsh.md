## 搜索图书（附加功能）
### 接口
#### 搜索
**请求地址** `POST` `/searcher/search`

**Request**

Headers:

| key   | 类型   | 描述      |
| ----- | ------ | --------- |
| token | string | 访问token |

Body:

```
{
    "user_id":"$user name$",
    "store_id":"$store name$",
    "keyword":"$search content$"
    "variable":"$error test judgment$"
}
```

| 变量名      | 类型     | 描述          | 是否可为空     |
|----------|--------|-------------|-----------|
| user_id  | string | 用户名         | N         |
| store_id | string | 店铺名         | 全站搜索时为空   |
| keyword  | string | 搜索内容（已分词）   | N         |
| variable | bool   | 判断是否为错误测试   | N         |

**Response**

Status Code:

| 码   | 描述             |
|-----|----------------|
| 200 | 搜索成功，返回相应内容    |
| 511 | 不存在用户名         |
| 513 | 不存在店铺名         |
| 522 | 无相关搜索结果        |
| 528 | SQLAlchemyError |
| 530 | BaseException  |

Body:

```
{   
    "message":"$error message$",
    "pagenum":"number of pages",
    "row":"search result",
    "show":"the content displayed on the page"
}
```

| 变量名     | 类型     | 描述                    | 是否可为空      |
|---------|--------|-----------------------|------------|
| message | string | 返回错误消息，成功时为"ok"       | N          |
| pagenum | int    | 搜索内容共可分成多少页（5条一页）     | 不成功时不返回该字段 |
| row     | list   | 所有的搜索结果               | 不成功时不返回该字段 |
| show    | list   | 第一页应该显示的内容（长度一定小于等于5） | 不成功时不返回该字段           |

#### 分页显示
**请求地址** `POST` `/searcher/show_pages`

**Request**

Headers:

| key   | 类型   | 描述      |
| ----- | ------ | --------- |
| token | string | 访问token |

Body:

```
{
    "user_id":"$user name$",
    "page":"$the selected page$",
    "content":"$search content$"
    "variable":"$error test judgment$"
}
```

| 变量名      | 类型     | 描述        | 是否可为空 |
|----------|--------|-----------|-------|
| user_id  | string | 用户名       | N     |
| page     | string | 选中的要显示的页面 | N     |
| content  | string | 全部搜索结果    | N     |
| variable | bool   | 判断是否为错误测试 | N     |

**Response**

Status Code:

| 码   | 描述          |
|-----|-------------|
| 200 | 搜索成功，返回相应内容 |
| 511 | 不存在用户名      |
| 528 | SQLAlchemyError |
| 530 | BaseException   |

Body:

```
{   
    "message":"$error message$",
    "pagenum":"number of pages",
    "row":"search result",
    "show":"the content displayed on the page"
}
```

| 变量名     | 类型     | 描述                      | 是否可为空 |
|---------|--------|-------------------------|-------|
| message | string | 返回错误消息，成功时为"ok"         | N     |
| row     | list   | 所有的搜索结果                 | N     |
| show    | list   | 选中的页面应该显示的内容（长度一定小于总页数） | N     |

### 函数实现 be\model\search.py
#### 搜索 def search()
传入三个参数：用户名、店铺名和查询关键字。先调用 user_id_exist 函数判断用户名是否存在，否则返回相应 code and message。接下来判断是店铺内搜索还是全站搜索，如果店铺名为空则为全站搜索。  
具体的搜索功能实现，我一开始使用 .like("%" + keyword + "%") 实现了初步的模糊搜索，后面进一步实现了 GIN索引全文检索，代码里两种方法都有，下文仅描述后者。  
**创建索引 be\model\jieba_book.py**  
首先，在原来的 book 表中新建一个 token 字段，用于储存 GIN索引。读取数据库，对搜索的范围（标题、作者、关键词、图书信息）使用 jieba 进行分词，用空格隔开，以便后面使用 to_tsvector 函数的 simple 
方法进行转换。再使用 setweight 对不同的内容赋予权重，我设置的是标题优先于关键词优先于图书信息优先于作者。最后将对应内容更新至token字段，成功创建索引。  
一开始我遇到很多问题，包括对 GIN索引的不熟悉，分词失败等，后来在助教的指导下找到了好的方法。我这里是直接用 sql 语句创建的索引，我尝试使用 ORM 但是一直出错，可能是语法有点问题。我后面还遇到了一个问题就是
后面查找时发现每本书计算出的分数都相同，后面才发现是我把所有 book 元组的 token 整合到一起最后每个元组都重复储存了同一个，之后我分别用列表储存标题和分词结果对应赋值 token 解决了问题。  
**全文搜索过程**  
创建子查询，得到与搜索关键字有关的每本书的标题，和使用 ts_rank 函数计算得到的对应的分数。再创建查询，搜索 book 表中对应子查询的书的标题、作者、出版商、翻译、作者信息、图书信息、关键词，按照分数降序排序，
即越符合搜索关键字的越靠前，且图书必须在 store 表有记录且库存须大于0，即搜索范围实际是 bookstore 中有库存的书。对于店铺内搜索，限制 store_id 为输入的店铺名即可。得到所有搜索结果（row），需要判断是否为空，
否则返回相应 code and message。以5条结果为1页，计算总页数（pagenum），再另外储存前5条结果为第一页显示的内容（show）以显示在当前页面。最后返回所有所需参数。  
#### 分页显示 def show_pages()
传入三个参数：用户名、选中的页数和搜索得到的全部结果。类似地，先调用 user_id_exist 函数判断用户名是否存在，否则返回相应 code and message。该函数实现很简单，计算得到在选中页面需要显示的结果（show）即可，
最后返回显示内容和所有搜索结果（以便可以连续选择页面）。其实我最后发现这里好像可以再查询一次得到结果，然后显示相应页面，就不要传递整个搜索结果，但是我感觉搜索结果也不是很多，而且这样也能实现所以就没管了
，而且我也不清楚是每次都查询一次的消耗更大还是直接传递结果的消耗更大。。。
### 测试过程
整个搜索功能的测试分为五个部分，分别测试：店铺内搜索、全站搜索、搜索结果不存在、用户名不存在、店铺名不存在。  
在测试之前使用函数 def pre_run_initialization() 定义相关参数：self.store_id1 为随机生 成的店铺名，self.store_id0 为空字符串表示全站搜索；self.add1 和 self.add0 新建 AddStoreBook 类。
该类实现代码我写在 fe\test\add_store_book.py 中，接收参数store_id，当店铺名为空时随机创建5到 20个店铺，向其中随机插入图书，否则就根据传入的店铺名指定创建并插入图书；self.keyword1 为查询关键字
，self.keyword0为一个生僻字，为了后面查询不到结果的test。  
在具体的5个test中，先调用 AddStoreBook 类的 add 方法新建店铺并插入图书。在两个 test_ok 中，赋值布尔变量 True，接收 search 的正确的四个返回参数，如果总页数超过1，随机选中1个页面（小于总页数），调用 show_pages 实现
分页显示，判断两个 code 都等于200。在三个 error测试中，赋值布尔变量 False，接收 search 的一个返回参数 code，判断其不等于200。
### 心得体会
对整个搜索功能的实现，我主要遇到以下问题：前后端传参，如何结合正确测试和错误测试以及 GIN索引的创建和使用。  
对于前后端传参，一是数量的匹配，二是参数类型。因为正确测试和错误测试传递到前端的参数数量不同，所以不能以同一个格式来接收。而在参数类型方面，一开始我发现后端传回的搜索结果前端一直接收不到，后来经过一系列的
类型转换才成功传递。对于如何结合正确测试和错误测试，主要就是在参数数量上体现的差别，所以我设置了一个布尔变量，通过判断这个变量选择不同的传参语句。对于 GIN索引的创建和使用，这是整个实现过程对于我挑战最大的地方，
因为之前没有接触过，网上参考的资料也不是很多，所以一度陷入困境。感谢助教对我不厌其烦地答疑和发给我的知乎链接，非常有用！后面我又找到两个类似的，虽然是 JAVA 的，但是参考价值很大。我深入理解了 GIN索引的创建逻辑
和查找时的使用方法，学会了相关函数的定义和使用，进一步提升了使用 jieba 分词的能力。  
当然，还有不得不提的各种配置环境和安包的问题。每次做大作业这个环节都是最费时和让人烦躁的。一开始我运行出来始终 response 500，困扰我很久，但同样的代码在组员的电脑上又可以成功运行。所以挣扎了很久，最后还是重新
创建 conda 的虚拟环境并安装相关的各种包，幸好是成功解决了问题。后面安装 jieba 包也挺麻烦，具体的倒也不讲了。  
总之，我收获了很多实际应用的经验，编程能力也有所提高。